<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【译】数据结构与算法——二叉树</title>
    <url>/2019/01/26/Algorithm-club-binary-tree/</url>
    <content><![CDATA[<p>二叉树是一种特殊的<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Tree/">树（tree）</a>，它的每个节点只能有 0， 1 或 2 个子节点。</p>
<a id="more"></a>

<p>下面是一个二叉树：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Tree/Images/BinaryTree.png" alt="A binary tree"></p>
<p>子节点通常分为 <em>左</em> 和 <em>右</em> 子节点。如果一个节点没有任何子节点，那么它被称为 <em>叶子</em> 子节点。<em>根</em> 指位于树最顶端的节点。</p>
<p>通常节点有一个指向父节点的（指针/引用），但不是必须的。</p>
<p>二叉树中应用最广泛的是<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Binary%20Search%20Tree/">二叉搜索树（binary search trees）</a>。它的节点以特定顺序排列（小值在左，大值在右）。当然不是所有的二叉树都必须如此。</p>
<p>例如，下面的二叉树，它展示的是一则算术运算 <code>(5 * (a - 10)) + (-4 * (3 / b))</code> ：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Tree/Images/Operations.png" alt="A binary tree"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面通过 Swift 实现了一个通用二叉树:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> node(<span class="type">BinaryTree</span>&lt;<span class="type">T</span>&gt;, <span class="type">T</span>, <span class="type">BinaryTree</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么用呢？下面用它来构建一则算术运算：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// leaf nodes</span></span><br><span class="line"><span class="keyword">let</span> node5 = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;5&quot;</span>, .empty)</span><br><span class="line"><span class="keyword">let</span> nodeA = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;a&quot;</span>, .empty)</span><br><span class="line"><span class="keyword">let</span> node10 = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;10&quot;</span>, .empty)</span><br><span class="line"><span class="keyword">let</span> node4 = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;4&quot;</span>, .empty)</span><br><span class="line"><span class="keyword">let</span> node3 = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;3&quot;</span>, .empty)</span><br><span class="line"><span class="keyword">let</span> nodeB = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;b&quot;</span>, .empty)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intermediate nodes on the left</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">Aminus10</span> = <span class="type">BinaryTree</span>.node(nodeA, <span class="string">&quot;-&quot;</span>, node10)</span><br><span class="line"><span class="keyword">let</span> timesLeft = <span class="type">BinaryTree</span>.node(node5, <span class="string">&quot;*&quot;</span>, <span class="type">Aminus10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intermediate nodes on the right</span></span><br><span class="line"><span class="keyword">let</span> minus4 = <span class="type">BinaryTree</span>.node(.empty, <span class="string">&quot;-&quot;</span>, node4)</span><br><span class="line"><span class="keyword">let</span> divide3andB = <span class="type">BinaryTree</span>.node(node3, <span class="string">&quot;/&quot;</span>, nodeB)</span><br><span class="line"><span class="keyword">let</span> timesRight = <span class="type">BinaryTree</span>.node(minus4, <span class="string">&quot;*&quot;</span>, divide3andB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// root node</span></span><br><span class="line"><span class="keyword">let</span> tree = <span class="type">BinaryTree</span>.node(timesLeft, <span class="string">&quot;+&quot;</span>, timesRight)</span><br></pre></td></tr></table></figure>

<p>构建树时要反着来，首先从叶子节点开始，然后向上直至顶端。</p>
<p>添加一个 <code>description</code> 方法，以便打印整个树：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinaryTree</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .node(<span class="keyword">left</span>, value, <span class="keyword">right</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;value: \(value), left = [\(left.description)], right = [\(right.description)]&quot;</span></span><br><span class="line">    <span class="keyword">case</span> .empty:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>print(tree)</code> 打印输出如下：</p>
<pre><code>value: +, left = [value: *, left = [value: 5, left = [], right = []], right = [value: -, left = [value: a, left = [], right = []], right = [value: 10, left = [], right = []]]], right = [value: *, left = [value: -, left = [], right = [value: 4, left = [], right = []]], right = [value: /, left = [value: 3, left = [], right = []], right = [value: b, left = [], right = []]]]</code></pre>
<p>适当调整下缩紧，在带点联想，树的结构应该是这样的：</p>
<pre><code>value: +, 
    left = [value: *, 
        left = [value: 5, left = [], right = []], 
        right = [value: -, 
            left = [value: a, left = [], right = []], 
            right = [value: 10, left = [], right = []]]], 
    right = [value: *, 
        left = [value: -, 
            left = [], 
            right = [value: 4, left = [], right = []]], 
        right = [value: /, 
            left = [value: 3, left = [], right = []], 
            right = [value: b, left = [], right = []]]]</code></pre>
<p>另一个有用的方法就是统计树中的节点数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .node(<span class="keyword">left</span>, <span class="keyword">_</span>, <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="number">1</span> + <span class="keyword">right</span>.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">case</span> .empty:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面给的例子为例, <code>tree.count</code> 应该为 12.</p>
<p>经常需要对二叉树进行，如以某种特定顺序查看所有节点。常用的遍历方法有三种（译者：主要是依据根节点的查询位置确定先、中、后序遍历）：</p>
<ol>
<li><em>中序遍历（In-order）</em>（也称 <em>深度优先（depth-first）</em>）：先遍历一个节点的左子节点，在遍历其自身，最终遍历其右子节点（译者：左根右，以下图为例应为：4、2、8、5、1、6、3、7）。</li>
<li><em>前序遍历（Pre-order）</em>：先遍历一个节点自身，在遍历其左子节点，和右子节点（译者：根左右，以下图为例应为：1、2、4、5、8、3、6、7）。</li>
<li><em>后序遍历（Post-order）</em>：先遍历左和右子节点，在遍历节点自身（译者：左右根，以下图为例应为：4、5、8、2、3、6、7、1）。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Tree/Images/Traverse.png" alt="Traverse"></p>
<blockquote>
<p><strong>注意</strong>：这里给出的中、先、后序遍历解释太简单了，不足以理解(至少译者理解不能)，所以译者补了一个插图和相应的实例，非原文内容。当然最好的理解方式还是上手亲自跑一遍代码。</p>
</blockquote>
<p>下面是实现代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traverseInOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .node(<span class="keyword">left</span>, value, <span class="keyword">right</span>) = <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">left</span>.traverseInOrder(process: process)</span><br><span class="line">    process(value)</span><br><span class="line">    <span class="keyword">right</span>.traverseInOrder(process: process)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traversePreOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .node(<span class="keyword">left</span>, value, <span class="keyword">right</span>) = <span class="keyword">self</span> &#123;</span><br><span class="line">    process(value)</span><br><span class="line">    <span class="keyword">left</span>.traversePreOrder(process: process)</span><br><span class="line">    <span class="keyword">right</span>.traversePreOrder(process: process)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traversePostOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .node(<span class="keyword">left</span>, value, <span class="keyword">right</span>) = <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">left</span>.traversePostOrder(process: process)</span><br><span class="line">    <span class="keyword">right</span>.traversePostOrder(process: process)</span><br><span class="line">    process(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理树结构时会经常用到，这中自己调用自己的函数称为递归。</p>
<p>例如，如果后序遍历之前的算术运算二叉树，那么其打印结果如下：</p>
<pre><code>5
a
10
-
*
4
-
3
b
/
*
+</code></pre>
<p>首先出现的叶子，最后出现的是根。</p>
<p>之后便可通过一个栈来计算该表达式, 类似下面的伪代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.traversePostOrder &#123; s <span class="keyword">in</span> </span><br><span class="line">  <span class="keyword">switch</span> s &#123;</span><br><span class="line">  <span class="keyword">case</span> this <span class="keyword">is</span> a numeric literal, such <span class="keyword">as</span> <span class="number">5</span>:</span><br><span class="line">    push it onto the stack</span><br><span class="line">  <span class="keyword">case</span> this <span class="keyword">is</span> a variable name, such <span class="keyword">as</span> a:</span><br><span class="line">    look up the value of a and push it onto the stack</span><br><span class="line">  <span class="keyword">case</span> this <span class="keyword">is</span> an <span class="keyword">operator</span>, such <span class="keyword">as</span> *:</span><br><span class="line">    pop the two top-most items off the stack, multiply them,</span><br><span class="line">    and push the result back onto the stack</span><br><span class="line">  &#125;</span><br><span class="line">  the result <span class="keyword">is</span> <span class="keyword">in</span> the top-most item on the stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定算法基础的同学进行回顾。</p>
<p><em>由 Matthijs Hollemans 发表于 Swift 算法社区</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——广度优先搜索</title>
    <url>/2019/04/21/Algorithm-club-breadth-first-search/</url>
    <content><![CDATA[<p>广度优先搜索（BFS）是对<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Tree">树</a> 或 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Graph">图</a>等数据结构进行遍历或搜索时应用的一种算法。它从起始节点开始，先遍历最近的节点，之后在遍历下一级的临近节点。</p>
<a id="more"></a>

<p>广度优先搜索即可用于有向图也可用于无向图。</p>
<h2 id="动画示例"><a href="#动画示例" class="headerlink" title="动画示例"></a>动画示例</h2><p>下面的动画展示了广度优先算法是如何搜索一个图的：</p>
<p><img src="https://github.com/Dracarys/swift-algorithm-club/raw/master/Breadth-First%20Search/Images/AnimatedExample.gif" alt="Animated example of a breadth-first search"></p>
<p>当访问一个节点时，将其标黑。同时将它的临近节点放入<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Queue">队列</a>中。那些已入队但尚未被访问的节点，在动画中以灰色标记。</p>
<p>让我们跟着动画（来熟悉一下过程），首先从起始节点 <code>A</code> 开始，将其添加到队列中，此时 <code>A</code> 节点变成灰色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.enqueue(<span class="type">A</span>)</span><br></pre></td></tr></table></figure>

<p>队列变成 <code>[ A ]</code>。（之后的）思路是，随着节点的入队，在访问位于队首的节点的同时，将其尚未被访问的临近节点入队，（以此类推，如此往复）。</p>
<p>在开始遍历图之前，先将起始节点 <code>A</code> 出队，并将其标黑。紧接着入队它的两个临近节点 <code>B</code> 和 <code>C</code>，与此同时将他们标灰。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// A</span></span><br><span class="line">queue.enqueue(<span class="type">B</span>)</span><br><span class="line">queue.enqueue(<span class="type">C</span>)</span><br></pre></td></tr></table></figure>

<p>此时队列变为 <code>[ B, C ]</code>。接着将 <code>B</code> 出队，在将 <code>B</code> 的临近节点 <code>D</code> 和 <code>E</code> 入队。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// B</span></span><br><span class="line">queue.enqueue(<span class="type">D</span>)</span><br><span class="line">queue.enqueue(<span class="type">E</span>)</span><br></pre></td></tr></table></figure>

<p>这时队列变为 <code>[ C, D, E ]</code>。之后将 <code>C</code> 出队，并将 <code>C</code> 的临近节点 <code>F</code> 和 <code>G</code> 入队。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// C</span></span><br><span class="line">queue.enqueue(<span class="type">F</span>)</span><br><span class="line">queue.enqueue(<span class="type">G</span>)</span><br></pre></td></tr></table></figure>

<p>队列变成了 <code>[ D, E, F, G ]</code>。在将 <code>D</code> 出队，它没有（为被访问）临近节点（，因此无需入队操作）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// D</span></span><br></pre></td></tr></table></figure>

<p>此时队列变成 <code>[ E, F, G ]</code>。将 <code>E</code> 出队，并将它唯一的临近节点 <code>H</code> 入队。注意节点 <code>B</code> 虽然也是 <code>E</code> 的临近节点，但是由于已经被访问过，所以不再重复入队。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// E</span></span><br><span class="line">queue.enqueue(<span class="type">H</span>)</span><br></pre></td></tr></table></figure>

<p>这时队列变成 <code>[ F, G, H ]</code>。将 <code>F</code> 出队，它已经没有未被访问的临近节点了（，因此无需入队操作）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// F</span></span><br></pre></td></tr></table></figure>

<p>之后队列变成 <code>[ G, H ]</code>。将 <code>G</code> 出队，它也没有未被访问过的临近节点了（，因此无需入队操作）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// G</span></span><br></pre></td></tr></table></figure>

<p>队列变成了 <code>[ H ]</code>。将 <code>H</code> 出队，同样它也没有未被访问的临近节点了（，因此无需入队操作）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">queue.dequeue()   <span class="comment">// H</span></span><br></pre></td></tr></table></figure>
<p>至此，队列为空，这意味着所有的节点都已经被遍历过。各节点遍历的顺序依次为 <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>, <code>G</code>, <code>H</code>。</p>
<p>以树来表示形式如下：</p>
<p><img src="https://github.com/Dracarys/swift-algorithm-club/raw/master/Breadth-First%20Search/Images/TraversalTree.png" alt="The BFS tree"></p>
<p>父节点即是那个通过它“发现”该节点的节点。而根节点则是广度优先查询的起始节点。</p>
<p>对于未加权的图而言，该树定义了从起始到树上各个子节点间最短的路径。因此广度优先查询正是寻找图中两个节点间最短路径的算法之一。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面是一个通过队列实现的广度优先查询示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breadthFirstSearch</span><span class="params">(<span class="keyword">_</span> graph: Graph, source: Node)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="type">Queue</span>&lt;<span class="type">Node</span>&gt;()</span><br><span class="line">  queue.enqueue(source)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nodesExplored = [source.label]</span><br><span class="line">  source.visited = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> node = queue.dequeue() &#123;</span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> node.neighbors &#123;</span><br><span class="line">      <span class="keyword">let</span> neighborNode = edge.neighbor</span><br><span class="line">      <span class="keyword">if</span> !neighborNode.visited &#123;</span><br><span class="line">        queue.enqueue(neighborNode)</span><br><span class="line">        neighborNode.visited = <span class="literal">true</span></span><br><span class="line">        nodesExplored.append(neighborNode.label)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodesExplored</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当队列中存在节点时，我们先访问队首节点，紧接着在将其尚未被访问的临近节点入队。</p>
<p>将下面的代码拷贝到 playground 中尝试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> graph = <span class="type">Graph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nodeA = graph.addNode(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeB = graph.addNode(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeC = graph.addNode(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeD = graph.addNode(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeE = graph.addNode(<span class="string">&quot;e&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeF = graph.addNode(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeG = graph.addNode(<span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeH = graph.addNode(<span class="string">&quot;h&quot;</span>)</span><br><span class="line"></span><br><span class="line">graph.addEdge(nodeA, neighbor: nodeB)</span><br><span class="line">graph.addEdge(nodeA, neighbor: nodeC)</span><br><span class="line">graph.addEdge(nodeB, neighbor: nodeD)</span><br><span class="line">graph.addEdge(nodeB, neighbor: nodeE)</span><br><span class="line">graph.addEdge(nodeC, neighbor: nodeF)</span><br><span class="line">graph.addEdge(nodeC, neighbor: nodeG)</span><br><span class="line">graph.addEdge(nodeE, neighbor: nodeH)</span><br><span class="line">graph.addEdge(nodeE, neighbor: nodeF)</span><br><span class="line">graph.addEdge(nodeF, neighbor: nodeG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nodesExplored = breadthFirstSearch(graph, source: nodeA)</span><br><span class="line"><span class="built_in">print</span>(nodesExplored)</span><br></pre></td></tr></table></figure>

<p>会输出结果为：<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;]</code></p>
<h2 id="BFS适用哪些场景呢？"><a href="#BFS适用哪些场景呢？" class="headerlink" title="BFS适用哪些场景呢？"></a>BFS适用哪些场景呢？</h2><p>广度优先算法适用范围很广，下面举两个简单的应用：</p>
<ul>
<li>求<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Shortest%20Path%20(Unweighted)">最短路径</a></li>
<li>求一个未加权图的<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Minimum%20Spanning%20Tree%20(Unweighted)">最小生成树</a>。</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 <a href="https://www.raywenderlich.com/">Raywenderlich</a> 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定基础的同学进行回顾，如果你才接触，那么建议移步<a href="https://www.raywenderlich.com/155801/swift-algorithm-club-swift-breadth-first-search">详细教程</a></p>
<p><em>Written by <a href="https://github.com/chris-pilcher">Chris Pilcher</a> and Matthijs Hollemans</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——深度优先搜索</title>
    <url>/2019/04/21/Algorithm-club-depth-first-search/</url>
    <content><![CDATA[<p>深度优先搜索(DFS)是遍历或搜索<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Tree">树</a> 或 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Graph">图</a>等数据结构的一种算法。从源点开始，在回溯之前尽量遍历较远的每一个分支。</p>
<a id="more"></a>

<p>深度优先搜索既适用于有向图也适用于无向图。</p>
<h2 id="动画示例"><a href="#动画示例" class="headerlink" title="动画示例"></a>动画示例</h2><p>下面演示了深度优先搜索是如何搜索一张图的：</p>
<p><img src="https://github.com/Dracarys/swift-algorithm-club/raw/master/Depth-First%20Search/Images/AnimatedExample.gif" alt="Animated example"></p>
<p>首先从 <code>A</code> 节点开始。我们先寻找该节点的第一个临近节点，并访问它，即示例中的节点 <code>B</code>。之后，在查找 <code>B</code> 节点的第一个临近节点，并访问它即节点 <code>D</code>。至此，<code>D</code> 节点已经没有未被访问过的临近节点，此时回溯到节点 <code>B</code>并访问它的另一个临近节点 <code>E</code>。依此类推，直至访问完图中所有节点。</p>
<p>依次访问它的第一个临近节点，直至无法继续，然后在回溯到可继续的那个节点（即存在未被访问的临近节点）。到回溯完所有路径并返回起始节点 <code>A</code> 时，搜索完毕。</p>
<p>以上图为例，依次访问的节点顺序为：<code>A</code>, <code>B</code>, <code>D</code>, <code>E</code>, <code>H</code>, <code>F</code>, <code>G</code>, <code>C</code>。<br>For the example, the nodes were visited in the order <code>A</code>, <code>B</code>, <code>D</code>, <code>E</code>, <code>H</code>, <code>F</code>, <code>G</code>, <code>C</code>.</p>
<p>深度优先搜索的过程也可以以树的形式呈现：</p>
<p><img src="https://github.com/Dracarys/swift-algorithm-club/raw/master/Depth-First%20Search/Images/TraversalTree.png" alt="Traversal tree"></p>
<p>父节点即是那个通过它“发现”该节点的节点。根节是深度优先算法的起始节点。每一个分支都代表一次回溯。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一个用递归实现的深度优先搜索：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depthFirstSearch</span><span class="params">(<span class="keyword">_</span> graph: Graph, source: Node)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> nodesExplored = [source.label]</span><br><span class="line">  source.visited = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> edge <span class="keyword">in</span> source.neighbors &#123;</span><br><span class="line">    <span class="keyword">if</span> !edge.neighbor.visited &#123;</span><br><span class="line">      nodesExplored += depthFirstSearch(graph, source: edge.neighbor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodesExplored</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Breadth-First%20Search">广度优先搜索</a>优先访问临近节点不同，深度优先搜索是尽可能地深入访问（树或图）。</p>
<p>将下列代码复制到 playground 中尝试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> graph = <span class="type">Graph</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nodeA = graph.addNode(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeB = graph.addNode(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeC = graph.addNode(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeD = graph.addNode(<span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeE = graph.addNode(<span class="string">&quot;e&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeF = graph.addNode(<span class="string">&quot;f&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeG = graph.addNode(<span class="string">&quot;g&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> nodeH = graph.addNode(<span class="string">&quot;h&quot;</span>)</span><br><span class="line"></span><br><span class="line">graph.addEdge(nodeA, neighbor: nodeB)</span><br><span class="line">graph.addEdge(nodeA, neighbor: nodeC)</span><br><span class="line">graph.addEdge(nodeB, neighbor: nodeD)</span><br><span class="line">graph.addEdge(nodeB, neighbor: nodeE)</span><br><span class="line">graph.addEdge(nodeC, neighbor: nodeF)</span><br><span class="line">graph.addEdge(nodeC, neighbor: nodeG)</span><br><span class="line">graph.addEdge(nodeE, neighbor: nodeH)</span><br><span class="line">graph.addEdge(nodeE, neighbor: nodeF)</span><br><span class="line">graph.addEdge(nodeF, neighbor: nodeG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nodesExplored = depthFirstSearch(graph, source: nodeA)</span><br><span class="line"><span class="built_in">print</span>(nodesExplored)</span><br></pre></td></tr></table></figure>

<p>输出结果应为：<code>[&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;h&quot;, &quot;f&quot;, &quot;g&quot;, &quot;c&quot;]</code>。</p>
<h2 id="DFS适用哪些场景呢？"><a href="#DFS适用哪些场景呢？" class="headerlink" title="DFS适用哪些场景呢？"></a>DFS适用哪些场景呢？</h2><p>深度优先搜索可以用来解决很多问题，例如：</p>
<ul>
<li>查找一个稀疏图（Sparse graph）的连接构成</li>
<li>对图中节点进行<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Topological%20Sort">拓扑排序（Topological sorting）</a></li>
<li>查询图中的<a href="https://en.wikipedia.org/wiki/Bridge_(graph_theory)#Bridge-finding_algorithm">Bridges</a></li>
<li>其它!<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></li>
</ul>
<p>该系列文章翻译自 <a href="https://www.raywenderlich.com/">Raywenderlich</a> 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定基础的同学进行回顾，如果你才接触，那么建议移步<a href="https://www.raywenderlich.com/157949/swift-algorithm-club-depth-first-search">详细教程</a></p>
<p><em>Written for Swift Algorithm Club by Paulo Tanaka and Matthijs Hollemans</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——哈希集合</title>
    <url>/2019/07/31/Algorithm-club-hash-set/</url>
    <content><![CDATA[<p>集合（set）是一个类似数组的元素集，但有两点不同：集合内元素是无序的，且仅出现一次。</p>
<a id="more"></a>

<p>如果下面展示的是数组，那么它们是不同的，但如果是集合，那么它们就是相同的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>这是因为每个元素仅能出现一次，无论你写入多少次，都仅计入一个。</p>
<blockquote>
<p><strong>注意：</strong> 当集合内元素顺序无关紧要时，我个人更倾向于使用集合而不是数组。通常而言，大多数编程都与元素顺序无关。</p>
</blockquote>
<p>集合的一些典型操作：</p>
<ul>
<li>插入一个元素</li>
<li>移除一个元素</li>
<li>检查是否已经包含某个元素</li>
<li>与另一个集合取并集（Union）</li>
<li>与另一个集合取交集（intersection）</li>
<li>计算与另一个集合的差集（difference，相对补集合）</li>
</ul>
<p>并集，交集，和差集是将两个集合组合成一个集合的几种不同形式：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Hash%20Set/Images/CombineSets.png" alt="Union, intersection, difference"></p>
<p>从 Swift 1.2 开始，标准库中内建了一个 <code>Set</code> 类型，但这里我将想你展示如何自己构建一个。虽然产品中不会用到，但是它能让你明白集合是怎么实现的。</p>
<p>可以通过一个简单的数组来实现集合，但是那样不够高效。这里我们使用字典。Swift 内建的字典是一个哈希表，那么我们实现的这个集合就是哈希集合了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Swift 实现的初始 <code>HashSet</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashSet</span>&lt;<span class="title">T</span>: <span class="title">Hashable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> dictionary = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">Bool</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        dictionary[element] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">        dictionary[element] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dictionary[element] != <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">allElements</span><span class="params">()</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Array</span>(dictionary.keys)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dictionary.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dictionary.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码非常简单，这是因为累活都被 Swift 内建的字典干了。之所以选择字典，是因为字典的键也必须是唯一的，跟集合的要求一样。此外，字典的大部分操作都具有 <strong>O(1)</strong> 时间复杂度，如此实现的集合会非常高效。</p>
<p>由于我们使用了字典，那么范型 <code>T</code> 就必须遵循 <code>Hashable</code> 协议。这样我们就可以想集合中插入任何可哈希的对象。（Swift 内建的 <code>Set</code> 也是如此）</p>
<p>通常，在字典中将键和值关联起来，但是因为集合只需关注键，所以这里我们使用 <code>Bool</code> 作为值的类型。即便如此，也只会将它设置为 <code>true</code>，而不是 <code>false</code>。（当然选择其它类也可以，但是布尔类型占用的空间是最小的）</p>
<p>将代码拷贝到 playground，在添加一些测试代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">HashSet</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.insert(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.insert(<span class="string">&quot;two&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.insert(<span class="string">&quot;three&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.allElements()      <span class="comment">// [&quot;one, &quot;three&quot;, &quot;two&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.insert(<span class="string">&quot;two&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.allElements()      <span class="comment">// still [&quot;one, &quot;three&quot;, &quot;two&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.<span class="built_in">contains</span>(<span class="string">&quot;one&quot;</span>)    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">set</span>.remove(<span class="string">&quot;one&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>.<span class="built_in">contains</span>(<span class="string">&quot;one&quot;</span>)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>allElements()</code> 函数会将集合中所有内容转换为一个数组。注意数组中的元素顺序可能与你添加的顺序不同。正如之前提及的，集合内的元素是无序的。（跟字典一样）</p>
<h2 id="合并集合（Combining-sets）"><a href="#合并集合（Combining-sets）" class="headerlink" title="合并集合（Combining sets）"></a>合并集合（Combining sets）</h2><p>集合的一大用处就是如何合并它们。下面是求并集的代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(<span class="keyword">_</span> otherSet: HashSet&lt;T&gt;)</span></span> -&gt; <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> combined = <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> <span class="keyword">self</span>.dictionary.keys &#123;</span><br><span class="line">            combined.insert(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> otherSet.dictionary.keys &#123;</span><br><span class="line">            combined.insert(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求两个集合的 <em>并集（union）</em> 会创建一个新的集合，它包含 A，B 两个集合中的所有元素。当然重复元素仅计入一次。</p>
<p>例如:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> setA = <span class="type">HashSet</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">setA.insert(<span class="number">1</span>)</span><br><span class="line">setA.insert(<span class="number">2</span>)</span><br><span class="line">setA.insert(<span class="number">3</span>)</span><br><span class="line">setA.insert(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setB = <span class="type">HashSet</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">setB.insert(<span class="number">3</span>)</span><br><span class="line">setB.insert(<span class="number">4</span>)</span><br><span class="line">setB.insert(<span class="number">5</span>)</span><br><span class="line">setB.insert(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> union = setA.union(setB)</span><br><span class="line">union.allElements()           <span class="comment">// [5, 6, 2, 3, 1, 4]</span></span><br></pre></td></tr></table></figure>

<p>如你所见，现在两个集合的并集包含所有元素。<code>3</code> 和 <code>4</code> 也仅出现一次，即使它们原来各自被包含在两个集合内。</p>
<p><em>并集（intersection）</em>是指两个集合共有的元素。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(<span class="keyword">_</span> otherSet: HashSet&lt;T&gt;)</span></span> -&gt; <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> common = <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> dictionary.keys &#123;</span><br><span class="line">            <span class="keyword">if</span> otherSet.<span class="built_in">contains</span>(obj) &#123;</span><br><span class="line">                common.insert(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> common</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersection = setA.intersect(setB)</span><br><span class="line">intersection.allElements()</span><br></pre></td></tr></table></figure>

<p>打印结果为 <code>[3, 4]</code>，这是一位呢它们集出现在 A 集合，又出现在 B 集合。</p>
<p>最后，求<em>差集（difference）</em>会移除两个集合共有的元素。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">difference</span><span class="params">(<span class="keyword">_</span> otherSet: HashSet&lt;T&gt;)</span></span> -&gt; <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> diff = <span class="type">HashSet</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> dictionary.keys &#123;</span><br><span class="line">            <span class="keyword">if</span> !otherSet.<span class="built_in">contains</span>(obj) &#123;</span><br><span class="line">                diff.insert(obj)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正好与交集 <code>intersect()</code> 相反，试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> difference1 = setA.difference(setB)</span><br><span class="line">difference1.allElements()                <span class="comment">// [2, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> difference2 = setB.difference(setA)</span><br><span class="line">difference2.allElements()                <span class="comment">// [5, 6]</span></span><br></pre></td></tr></table></figure>

<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>如果你看过 Swift 内建 <code>Set</code> 的<a href="http://swiftdoc.org/v2.1/type/Set/">文档</a>，就会注意到它包含由更多的函数。一个最显著的扩展就是让 <code>HashSet</code> 遵循 <code>SequenceType</code>, 如此就可以通过 <code>for</code>…<code>in</code> 对集合进行遍历</p>
<p>另一个可以尝试的操作是，用一个真正的<a href="../Hash%20Table">hash table</a>代替 <code>Dictionary</code>，这样只需存储键即可，无需在关联其他，也就不需要 <code>Bool</code> 类型的值。</p>
<p>如果你将长需要查询一个元素是否属于某个集合，以及求交集等操作，那么<a href="../Union-Find/">union-find</a>这个数据结构可能更合适。它使用一个树来代替字典，让查询和求并集操作更高效。</p>
<blockquote>
<p><del><strong>注意：</strong> 我更倾向于让 <code>HashSet</code> 遵从 <code>ArrayLiteralConvertible</code>，如此就可以这样写了：<code>let setA: HashSet&lt;Int&gt; = [1, 2, 3, 4]</code>，但是目前这样会导致编译器崩溃</del>。</p>
<p><strong>译者注</strong>：原来的 <code>ArrayLiteralConvertible </code> 已经被替换为 <code>ExpressibleByArrayLiteral</code>，现在已经可以正常使用了。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定算法基础的同学进行回顾，如果你才接触算法，那么建议移步阅读详细<a href="https://www.raywenderlich.com/149213/swift-algorithm-club-swift-stack-data-structure">教程</a></p>
<p><em>由 Matthijs Hollemans 为 Swift 算法合集撰写</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——哈希表</title>
    <url>/2019/07/31/Algorithm-club-hash-table/</url>
    <content><![CDATA[<p>哈希表允许你通过“key（键）”来访问对象。</p>
<p>哈希表通常的实现结构有 dictionary，map，associative array，它们的实现可以是一个树，也可以是数组，但最效率最高的还是哈希表。</p>
<a id="more"></a>

<p>这也说明了为什么 Swift 内建的 <code>Dictionary</code> 类型要求 key（键）必须遵循 <code>Hashable</code> 协议，因为它内部应用了哈希表，也就是我们接下来马上就学习的内容。</p>
<h2 id="原理（How-it-works）"><a href="#原理（How-it-works）" class="headerlink" title="原理（How it works）"></a>原理（How it works）</h2><p>哈希表跟数组没什么两样。初始，这个数组是空的，当你通过 key（键）将一个 value（值）存放到数组中时，它会对 key（键）进行计算，从而得到数组内的一个索引（index）。下面是例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">hashTable[<span class="string">&quot;firstName&quot;</span>] = <span class="string">&quot;Steve&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">The</span> hashTable array:</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">0</span>:           |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">1</span>:           |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">2</span>:           |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">3</span>: firstName |---&gt; <span class="type">Steve</span></span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">4</span>:           |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>&quot;firstName&quot;</code> key（键）对应到了数组的索引 3。</p>
<p>在添加另一对键值，它被映射到了数组内的另一个索引：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">hashTable[<span class="string">&quot;hobbies&quot;</span>] = <span class="string">&quot;Programming Swift&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">The</span> hashTable array:</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">0</span>:           |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">1</span>: hobbies   |---&gt; <span class="type">Programming</span> <span class="type">Swift</span></span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">2</span>:           |</span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">3</span>: firstName |---&gt; <span class="type">Steve</span></span><br><span class="line">+--------------+</span><br><span class="line">| <span class="number">4</span>:           |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>哈希表的关键就在于如何映射到相应的数组索引。当你写出如下表达式时，哈希随之进行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">hashTable[<span class="string">&quot;firstName&quot;</span>] = <span class="string">&quot;Steve&quot;</span></span><br></pre></td></tr></table></figure>

<p>哈希表接收到键 <code>&quot;firstName&quot;</code>，随即访问该键的 <code>hashValue</code> 属性，因此键必须是 <code>Hashable</code> 的。</p>
<p><code>&quot;firstName&quot;.hashValue</code> 会返回一个大整数：-4799450059917011053。<code>&quot;hobbies&quot;.hashValue</code>返回的哈希值是 4799450060928805186。（这些数值看上去是无规律的）</p>
<p>这些数值都太大了，完全没法映射到数组中的索引，甚至还有负值！通常的做法是先对整数取绝对值，然后在针对数组的大小进行取模运算。</p>
<p>我们数组的大小是 5，所以 <code>&quot;firstName&quot;</code> 键映射到的索引是 <code>abs(-4799450059917011053) % 5 = 3</code> 。你可以自己计算下 <code>&quot;hobbies&quot;</code>键，它的索引应该是 1。</p>
<p>正式哈希才使 dictionary（字典）变的高效，查找一个元素时，首先通过哈谢得到数组中对应的索引，然后直接根据索引取得对应的元素。所有这些操作耗时都是恒定的，因此无论是添加、读取、还是删除对象，它的时间复杂度都是 **O(1)**。</p>
<blockquote>
<p><strong>注意:</strong> 由于不能预先知晓哈希后的索引会对应到哪里，所以字典是不能保证哈希表中任何元素顺序的。</p>
</blockquote>
<h2 id="避免碰撞（Avoiding-collisions）"><a href="#避免碰撞（Avoiding-collisions）" class="headerlink" title="避免碰撞（Avoiding collisions）"></a>避免碰撞（Avoiding collisions）</h2><p>有这样一个问题：由于我们是通过数组的大小对哈希值进行取模运算，那就有可能两个或着更多的键对应到一个数组索引。这种情况被称为碰撞。</p>
<p>解决方法之一就是创建个大数组，从而减少两个键同时映射到一个索引的情况。另一个办法就是选择一个数值作为数组的大小（该数值大于数组的容量）。然而，碰撞还是会出现，所以我们要找到一个终极解决办法。</p>
<p>由于我们的表很小，所以非常容易出现碰撞。例如，<code>&quot;lastName&quot;</code>键就也被映射到了索引 3，但是我们不想原来已经存好的值被覆盖掉。</p>
<p>通常解决碰撞的做法用一个链来存储，此时数组看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">buckets:</span><br><span class="line">+-----+</span><br><span class="line">|  <span class="number">0</span>  |</span><br><span class="line">+-----+     +----------------------------+</span><br><span class="line">|  <span class="number">1</span>  |---&gt; | hobbies: <span class="type">Programming</span> <span class="type">Swift</span> |</span><br><span class="line">+-----+     +----------------------------+</span><br><span class="line">|  <span class="number">2</span>  |</span><br><span class="line">+-----+     +------------------+     +----------------+</span><br><span class="line">|  <span class="number">3</span>  |---&gt; | firstName: <span class="type">Steve</span> |---&gt; | lastName: <span class="type">Jobs</span> |</span><br><span class="line">+-----+     +------------------+     +----------------+</span><br><span class="line">|  <span class="number">4</span>  |</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure>

<p>引入链后，数组不在直接存储键值对，而是把键值对列表作为自己的元素。通常我们称该数组的元素为 <em>bucket（桶）</em> ，把这个列表称为 <em>chains（链）</em>。（译者：有点像冬天做的腊肠，一节一节的刚做好，装在桶里）</p>
<p>如果我们通过下面的表达式去从哈希表中读区一个对象，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = hashTable[<span class="string">&quot;lastName&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>它首先会对<code>&quot;lastName&quot;</code> 进行哈希，从而得到索引 3。进而得到存储着目标值的链（腊肠），沿着链逐个进行字符串对比，查找<code>&quot;lastName&quot;</code>键，直到该链的最后一个元素，发现正好是我们要找的键，在将其对应的值返回。（顺着撸，找到心仪的那一节腊肠）</p>
<p>通常这样的链是由链表或者另一个数组来实现的。由于链上元素顺序无关紧要，所以你也可以把它理解为一个集合（Set）。</p>
<p>链要尽可能短，否则查找过程将变的耗时。理想状态，没有链是最好的，但实际上由于碰撞的存在，这种情况很难出现。不过你可以通过改进哈希算法，让哈希表有拥有更多的 buckets（桶）。</p>
<blockquote>
<p><strong>注意:</strong> 链的一个替代方案是 “open addressing（开放地址？）”。它的思路是，如果一个数组索引已经存在，那么我们就把元素放到下一个未占用的索引，当然这种方式也有其自身的优缺点。</p>
</blockquote>
<h2 id="上码"><a href="#上码" class="headerlink" title="上码"></a>上码</h2><p>我们来看看 Swift 中哈希表的一个基本实现，之后我们会一步一步地构建它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&lt;<span class="title">Key</span>: <span class="title">Hashable</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> <span class="type">Element</span> = (key: <span class="type">Key</span>, value: <span class="type">Value</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> <span class="type">Bucket</span> = [<span class="type">Element</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> buckets: [<span class="type">Bucket</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(capacity: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="built_in">assert</span>(capacity &gt; <span class="number">0</span>)</span><br><span class="line">buckets = <span class="type">Array</span>&lt;<span class="type">Bucket</span>&gt;(repeatElement([], <span class="built_in">count</span>: capacity))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashTable</code>是一个通用容器，它有包含两个类型 <code>Key</code> (必须是 <code>Hashable（可哈希的）</code>) 和 <code>Value</code>。此外还定义了另外两种类型：用于在链中存储键值的<code>Element</code> , 和一个存储这些<code>Elements</code>的 <code>Bucket</code>数组。</p>
<p>主数组被命名为 <code>buckets</code>。其容量是固定的，所以其容量有初始化方法 <code>init(capacity)</code>确定。此外我们还通过 <code>count</code>来记录有多少对象被存到哈希表中。</p>
<p>创建一个新哈希表的范例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hashTable = <span class="type">HashTable</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;(capacity: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>此时这个哈希表还什么都不能做，接下来我们来添加一些方法，首先，添加一个用于计算键对应索引的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(forKey key: Key)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(key.hashValue) % buckets.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法前面已经介绍过了，对键的哈希值取绝对值，再针对数组的大小进行取模运算，这里把它作为一个函数，是为了方便后续很多地方的使用。</p>
<p>哈希表或字典的四种常用方法：</p>
<ul>
<li>增加一个元素</li>
<li>查询一个元素</li>
<li>更新一个已存在的元素</li>
<li>删除一个元素</li>
</ul>
<p>对应的语法如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">hashTable[<span class="string">&quot;firstName&quot;</span>] = <span class="string">&quot;Steve&quot;</span>   <span class="comment">// insert（增）</span></span><br><span class="line"><span class="keyword">let</span> x = hashTable[<span class="string">&quot;firstName&quot;</span>]     <span class="comment">// lookup（查）</span></span><br><span class="line">hashTable[<span class="string">&quot;firstName&quot;</span>] = <span class="string">&quot;Tim&quot;</span>     <span class="comment">// update（改）</span></span><br><span class="line">hashTable[<span class="string">&quot;firstName&quot;</span>] = <span class="literal">nil</span>       <span class="comment">// delete（删）</span></span><br></pre></td></tr></table></figure>

<p>这四种操作我们都可以通过 <code>下标</code> 来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">subscript</span>(key: <span class="type">Key</span>) -&gt; <span class="type">Value?</span> &#123;</span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value(forKey: key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = newValue &#123;</span><br><span class="line">updateValue(value, forKey: key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">removeValue(forKey: key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了3个帮手来完整实际的工作，我们来看看 <code>value(forKey:)</code> 是如何读从哈希表中读区一个对象的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(forKey key: Key)</span></span> -&gt; <span class="type">Value?</span> &#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="keyword">self</span>.index(forKey: key)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> buckets[index] &#123;</span><br><span class="line"><span class="keyword">if</span> element.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> element.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// key not in hash table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过<code>index(forKey:)</code> 方法将键转换为数组索引。这就给了我们一个 bucket（桶）的编号，但是如果存在碰撞，那么这个 bucket 就可能被不只一个键所占用，所以<code>value(forKey:)</code> 方法沿着该 bucket 中的链进行循环遍历查找，直到找到该键，并返回其对应的值，否则返回 <code>nil</code> 。</p>
<p>下面的代码展示如何通过 <code>updateValue(_:forKey:)</code>方法添加一个新元素或者更新一个已有元素，相对复杂一些：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">_</span> value: Value, forKey key: Key)</span></span> -&gt; <span class="type">Value?</span> &#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="keyword">self</span>.index(forKey: key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do we already have this key in the bucket?</span></span><br><span class="line"><span class="keyword">for</span> (i, element) <span class="keyword">in</span> buckets[index].enumerated() &#123;</span><br><span class="line"><span class="keyword">if</span> element.key == key &#123;</span><br><span class="line"><span class="keyword">let</span> oldValue = element.value</span><br><span class="line">buckets[index][i].value = value</span><br><span class="line"><span class="keyword">return</span> oldValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This key isn&#x27;t in the bucket yet; add it to the chain.</span></span><br><span class="line">buckets[index].append((key: key, value: value))</span><br><span class="line"><span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上，还是先将键转换为对应的数组索引，以找到对应的 bucket（桶）。之后沿着 chain（链）查找，找到就更新它，如果没找到，就在链的末尾增加一个新的元素。</p>
<p>如你所见，保持链尽量的短是多么重要（让哈希表足够大）。否则就会在 <code>for</code>…<code>in</code> 循环中耗费大量时间，如此哈希表的时间复杂度就不再是 <strong>O(1)</strong> 而更加接近 **O(n)**。</p>
<p>删除类似也要对链进行遍历：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">removeValue</span><span class="params">(forKey key: Key)</span></span> -&gt; <span class="type">Value?</span> &#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="keyword">self</span>.index(forKey: key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the element in the bucket&#x27;s chain and remove it.</span></span><br><span class="line"><span class="keyword">for</span> (i, element) <span class="keyword">in</span> buckets[index].enumerated() &#123;</span><br><span class="line"><span class="keyword">if</span> element.key == key &#123;</span><br><span class="line">buckets[index].remove(at: i)</span><br><span class="line"><span class="built_in">count</span> -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> element.value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// key not in hash table</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个哈希表的基础功能就都实现了。工作原理都非常相似：将键的哈希值转换为数组索引，根据索引找到对应的bucket，然后在沿着bucket存储的链循环遍历到目标元素，进而执行操作。</p>
<p>试着在 palyground 中把玩一下，应该跟 Swift 提供的 <code>Dictionary</code> 差不多。</p>
<h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>这一版的<code>HashTable</code>的大小或容量是固定的。如果有更多的元素需要存到表中，那么选择一个大于元素个数的值作为大小显然更优。</p>
<p>哈希表的 <em>load factor（装载因子，装载率）</em> 是指，最大容量使用的百分比。如果有一个有 5 个 bucket的哈希表，已经存放了3个元素，那么它的装载因子就是<code>3/5 = 60%</code>。</p>
<p>如果哈希表比较小，那么链就会比较长，load factor（装载因子，装载率）就会大于 1，这样效率会比较差。</p>
<p>当load factor（装载因子，装载率）大于 75%是，就应该对哈希表进行扩容，这部分代码就留给读者作为练习了，但是请注意，当 bucket 数组变大时，随之也会改变键与索引之间的映射关系！这就要求你在扩容后必须重新添加一遍所有元素。</p>
<h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>这里提供的哈希表非常简单，如果通过 <code>SequenceType</code> 与 SWift标准库相结合，那么它将变的更加高效。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定基础的同学进行回顾，如果你才接触，那么建议移步阅读详细<a href="https://www.raywenderlich.com/139821/swift-algorithm-club-swift-binary-search-tree-data-structure">教程</a></p>
<p><em>由 Matthijs Hollemans 为 Swift Algorithm Club（Swift算法社区） 撰写</em></p>
<p><em>由 William Han  翻译并发表于 Github</em></p>
]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——栈</title>
    <url>/2018/12/18/Algorithm-club-stack/</url>
    <content><![CDATA[<p>栈类似一个功能受限的数组。仅可以将新元素从栈的顶端 <em>push（压入）</em> ，或着从顶端 <em>pop（弹出）</em> ，如果不弹出元素，那么只能看到栈顶元素。</p>
<a id="more"></a>

<p>那为什么要这么做呢？这是因为，在众多算法问题中，经常会遇到将某些元素添加到一个临时的列表中，而后又将它们移除，且顺序不能乱的情况。</p>
<p>而栈恰好满足了这种后进先出（LIFO）的顺序需求。最后一个压入栈的元素也最先出被弹出。（另一个类似的数据结构是<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Queue">队列(queue)</a>，它是先进先出）<br>例如，压入一个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>现在栈是 <code>[ 10 ]</code>。压入下一个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>此时栈是 <code>[ 10, 3 ]</code>。在压入一个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stack.push(<span class="number">57</span>)</span><br></pre></td></tr></table></figure>

<p>栈变成了 <code>[ 10, 3, 57 ]</code> 。现在我们来弹出最顶端的数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stack.pop()</span><br></pre></td></tr></table></figure>

<p>返回了  <code>57</code>，正是我们刚刚压入的数。现在栈又变成了<code>[ 10, 3 ]</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">stack.pop()</span><br></pre></td></tr></table></figure>

<p>这一次返回 <code>3</code>，以此类推。如果栈空了，会返回 <code>nil</code> 或者在其它一些实现中返回错误消息 “栈下溢出(stack underflow)”。</p>
<p>通过 Swift 创建栈非常简单。对数组进行封装以满足 push，pop，以及读取栈顶元素等操作即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> array = [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="keyword">_</span> element: T)</span></span> &#123;</span><br><span class="line">    array.append(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.popLast()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">T?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.last</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，push 是新元素添加到数组的末尾，而不是开头。在开头插入元素是一个非常昂贵的操作，时间复杂度为 **O(n)**，之所以如此，是因为需要将数组中已有的元素在内存中做整体移动。而尾部追加的时间杂度是  **O(1)**；它总是消耗固定的时间，与数组的大小无关。</p>
<p>有趣的栈：每次调用函数或方法，CPU都会将返回地址放入栈中。一旦抵达函数结尾，CPU 就会通过返回地址跳回到调用者。这也是为什么当你调用太多函数，例如：无限递归，会导致“栈溢出”，因为 CPU 的栈的空间已经耗尽了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定算法基础的同学进行回顾，如果你才接触算法，那么建议移步阅读详细<a href="https://www.raywenderlich.com/149213/swift-algorithm-club-swift-stack-data-structure">教程</a></p>
<p><em>由 Matthijs Hollemans 为 Swift 算法社区撰写</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>Browser-Solidity的本地安装及使用介绍</title>
    <url>/2018/02/07/Browser-solidity-Installation-Introduction/</url>
    <content><![CDATA[<p>正所谓工欲善其事必先利其器，巧妇也难为无米之炊，所以在学习智能合约之前，必须要先把工具准备好。Browser-Solidity 是 Ethereum 官方的一个IDE项目，该名称准确的表述了，它是一款基于浏览器的 Solidity 集成开发环境，官方正式名称称之为 Remix，通过它我们可以编辑、编译、发布我们自己的智能合约。</p>
<a id="more"></a>

<p>基于浏览器的开发环境，那么它有在线版吗？有，就是这里<a href="https://remix.ethereum.org/">https://remix.ethereum.org</a>。既然有在线版为什么还要安装呢？你亲身访问一下就能发现答案了。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>我们以 Mac 为开发平台，且 Mac上已经装好了 npm 和 Node.js，如果你的 Mac 上没有安装，那么你可以参考这里的教程：<a href="https://docs.npmjs.com/getting-started/installing-node">How to Install npm &amp; Manage npm Versions</a></p>
<p>2017年2月8日补充：今天手贱更新了一下Browser-solidity，重新执行<code>npm install</code>，然后 solc 这个包总是安装不成功，直到 <code>brew install wget</code>。🤷‍♀️</p>
<h2 id="安装-amp"><a href="#安装-amp" class="headerlink" title="安装&amp;"></a>安装&amp;</h2><h3 id="通过npm直接安装"><a href="#通过npm直接安装" class="headerlink" title="通过npm直接安装"></a>通过npm直接安装</h3><p>以太坊真是日新月异，如新生儿般一天一个样。废话不多说，Remix已正式更名为Remix-ide，官方也已将其发布为npm包，可以通过npm直接安装，方便了很多：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install remix-ide -g</span><br></pre></td></tr></table></figure>

<p>启动Remix-ide，安装成功后，直接在命令行键入如下命令启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remix-ide</span><br></pre></td></tr></table></figure>

<p>然后打开 Chrome，或 Safari，在地址中输入：<a href="http://localhost:8080/">localhost:8080</a>即可。</p>
<p><em>下面的clone安装方法已不在推荐，可以选择性阅读。</em></p>
<hr>
<h3 id="clone项目到本地安装"><a href="#clone项目到本地安装" class="headerlink" title="clone项目到本地安装"></a>clone项目到本地安装</h3><p>打开终端，进入你准备的好安装目录，将 browser-solidity 项目 clone 到本地。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ethereum/</span>browser-solidity</span><br><span class="line">cd browser-solidity</span><br></pre></td></tr></table></figure>

<p>进入 browser-solidity 目录后，运行如下命令，开始安装。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install</span><br><span class="line"><span class="built_in">npm</span> run</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，输入如下命令，开启 Remix 本地服务。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> start</span><br></pre></td></tr></table></figure>
<p>成功启动后，终端会输出如下内容，主要是一些与启动、参数说明和警告等相关信息：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; browser-<span class="symbol">solidity@</span><span class="number">0.0</span><span class="number">.0</span> start /Users/dracarys/Documents/Ethereum/browser-solidity</span><br><span class="line">&gt; npm-run-all -lpr serve watch onchange remixd</span><br><span class="line"></span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span> &gt; browser-<span class="symbol">solidity@</span><span class="number">0.0</span><span class="number">.0</span> remixd /Users/dracarys/Documents/Ethereum/browser-solidity</span><br><span class="line"><span class="string">[remixd  ]</span> &gt; node ./node_modules/remixd/src/main.js -s ./contracts</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[onchange]</span> </span><br><span class="line"><span class="string">[onchange]</span> &gt; browser-<span class="symbol">solidity@</span><span class="number">0.0</span><span class="number">.0</span> onchange /Users/dracarys/Documents/Ethereum/browser-solidity</span><br><span class="line"><span class="string">[onchange]</span> &gt; onchange build/app.js -- npm-run-all lint</span><br><span class="line"><span class="string">[onchange]</span> </span><br><span class="line"><span class="string">[watch   ]</span> </span><br><span class="line"><span class="string">[watch   ]</span> &gt; browser-<span class="symbol">solidity@</span><span class="number">0.0</span><span class="number">.0</span> watch /Users/dracarys/Documents/Ethereum/browser-solidity</span><br><span class="line"><span class="string">[watch   ]</span> &gt; watchify src/index.js -dv -p browserify-reload -o build/app.js</span><br><span class="line"><span class="string">[watch   ]</span> </span><br><span class="line"><span class="string">[serve   ]</span> </span><br><span class="line"><span class="string">[serve   ]</span> &gt; browser-<span class="symbol">solidity@</span><span class="number">0.0</span><span class="number">.0</span> serve /Users/dracarys/Documents/Ethereum/browser-solidity</span><br><span class="line"><span class="string">[serve   ]</span> &gt; execr --silent http-server .</span><br><span class="line"><span class="string">[serve   ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span> example: --dev-path /home/devchains/chain1 --mist --geth --frontend /home/frontend --frontend-port <span class="number">8084</span> --<span class="built_in">auto</span>-mine</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span>   Usage: main -S &lt;<span class="keyword">shared</span> folder&gt;</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span>   Provide a two ways connection between the local computer <span class="keyword">and</span> Remix IDE</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span>   Options:</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span>     -s, --<span class="keyword">shared</span>-folder &lt;path&gt;            Folder to share with Remix IDE</span><br><span class="line"><span class="string">[remixd  ]</span>     -m, --mist                            start mist</span><br><span class="line"><span class="string">[remixd  ]</span>     -g, --geth                            start geth</span><br><span class="line"><span class="string">[remixd  ]</span>     -p, --dev-path &lt;dev-path&gt;             Folder used by mist/geth to start the development instance</span><br><span class="line"><span class="string">[remixd  ]</span>     -f, --frontend &lt;front-end&gt;            Folder that should be served by remixd</span><br><span class="line"><span class="string">[remixd  ]</span>     -p, --frontend-port &lt;front-end-port&gt;  Http port used by the frontend (<span class="keyword">default</span> <span class="number">8082</span>)</span><br><span class="line"><span class="string">[remixd  ]</span>     -a, --<span class="built_in">auto</span>-mine                       mine pending transactions</span><br><span class="line"><span class="string">[remixd  ]</span>     -r, --rpc &lt;cors-domains&gt;              start rpc server. Values are CORS domain</span><br><span class="line"><span class="string">[remixd  ]</span>     -rp, --rpc-port                       rpc server port (<span class="keyword">default</span> <span class="number">8545</span>)</span><br><span class="line"><span class="string">[remixd  ]</span>     -h, --help                            output usage information</span><br><span class="line"><span class="string">[remixd  ]</span> [WARN] Any application that runs on your computer can potentially read <span class="keyword">from</span> <span class="keyword">and</span> write to all files <span class="keyword">in</span> the directory.</span><br><span class="line"><span class="string">[remixd  ]</span> [WARN] Symbolinc links are <span class="keyword">not</span> forwarded to Remix IDE</span><br><span class="line"><span class="string">[remixd  ]</span> </span><br><span class="line"><span class="string">[remixd  ]</span> [WARN] Symbolic link modification <span class="keyword">not</span> allowed : ./contracts | /Users/dracarys/Documents/Ethereum/browser-solidity/contracts</span><br><span class="line"><span class="string">[remixd  ]</span> Shared folder : ./contracts</span><br><span class="line"><span class="string">[remixd  ]</span> Mon Feb <span class="number">05</span> <span class="number">2018</span> <span class="number">09</span>:<span class="number">35</span>:<span class="number">05</span> GMT+<span class="number">0800</span> (CST) Remixd <span class="keyword">is</span> listening on <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65520</span></span><br><span class="line"><span class="string">[watch   ]</span> WS server listening on  <span class="number">49815</span></span><br></pre></td></tr></table></figure>
<p>这时打开浏览器，在地址栏中输入：<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a> 即可。</p>
<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><p>Remix 界面入下图所示：</p>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/full.png" alt="Remix IDE"></p>
<p>如果您熟悉编程，接触过很多IDE，那么 Remix 的界面你一定也不陌生，所以你可以跳过该部分，对 Remix 的理解不会受到任何影响。</p>
<p>下面是对上图中五个功能区域的简单介绍：</p>
<ul>
<li>红色 工具栏，这里可以进行新建文件、打开文件，发布到Github、向另一个实例拷贝和建立本地连接等操作；</li>
<li>橙色 文件导航区，在这里可以分常方便地在各个文件间进行切换；</li>
<li>黄色 代码编辑区，可以点击上方的+-对代码文字进行放大和缩小，还可以单击上方的《、》符号隐藏左右边栏；</li>
<li>绿色 信息输出区，这里可以看到代码的输出结果和编译信息，还可以通过该区域上方的下拉列表对信息进行过滤，和搜索；</li>
<li>紫色 属性编辑区，该区域有六个分页，分别是：Compile、Run、Setting、Analysis、Debug、Support。下面我们会着重介绍区域的设置。</li>
</ul>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>前四个区域没什么好介绍的，大家只要上手简单操作一下就能明白。这里我们着重介绍下区域5，属性编辑区。这里我么只介绍Setting、Run、Compile、Debug 四个个分页，剩余两个分页功能非常直观，如果不是理解建议大家自行查询，不再赘述。</p>
<h3 id="Setting-IDE设置"><a href="#Setting-IDE设置" class="headerlink" title="Setting IDE设置"></a>Setting IDE设置</h3><p>Setting界面如下图所示：</p>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/setting.png" alt="Setting"></p>
<p><code>Solidity version</code> 设置 Solidity 的版本，这个的版本必须高于或者与你在源码中指定的版本相同，否则可能会导致一些无法预料的行为，非常关键。这里建议大家选择名字较短的稳定版，以减少不必要的麻烦。</p>
<p><code>General setting</code> 通用设置，这里可以设置以及文本断行，是否默认启用JavaScript VM，以及是否启用优化；</p>
<p><code>Theme</code> 主题设置，没什么好介绍的，只有2个主题，选择一个自己喜欢的即可。</p>
<p><code>Plugin</code> 插件，目前还处于Alpha阶段，如果不了解，请不要更改。（我就是那个不了解的，还望各位大牛指点）</p>
<h3 id="Run-运行设置"><a href="#Run-运行设置" class="headerlink" title="Run 运行设置"></a>Run 运行设置</h3><p>Run界面如下图所示：</p>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/run.png" alt="Run"></p>
<h4 id="红色区域"><a href="#红色区域" class="headerlink" title="红色区域"></a>红色区域</h4><ul>
<li><code>Environment</code> 运行环境选择，默认为本地 JavaScript VM，Web3 Provider 用于连接指定的虚拟机服务，可以用来本地测试或者小范围的局域网测试。还有一个 Injected Web3 功能暂时不明，望高人告知。</li>
<li><code>Account</code> 账户，默认的 JavaScript VM 提供了 5 个虚拟账户，每个账户有100 ether，如果连接到 Web3 Provider，那么这里会显示你在这台 Provider 上的账户。</li>
<li><code>Gas limit</code> Gas上限，并不是越大越好，当然也不能太小，否则会影响交易。有关Gas的进一步信息，你可以访问这里<a href="http://www.ethdocs.org/en/latest/ether.html#gas-and-ether">Gas and ether</a></li>
<li><code>Value</code> 即Gas price，输入后不要忘记在右侧的下拉列表中设置价格单位。如果你不熟悉 Wei 和 Ether 之间的换算可以参见下表</li>
</ul>
<table>
<thead>
<tr>
<th align="left">单位</th>
<th align="left">换算率</th>
<th align="left">Wei</th>
</tr>
</thead>
<tbody><tr>
<td align="left">wei</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Kwei (babbage)</td>
<td align="left">1e3 wei</td>
<td align="left">1,000</td>
</tr>
<tr>
<td align="left">Mwei (lovelace)</td>
<td align="left">1e6 wei</td>
<td align="left">1,000,000</td>
</tr>
<tr>
<td align="left">Gwei (shannon)</td>
<td align="left">1e9 wei</td>
<td align="left">1,000,000,000</td>
</tr>
<tr>
<td align="left">microether (szabo)</td>
<td align="left">1e12 wei</td>
<td align="left">1,000,000,000,000</td>
</tr>
<tr>
<td align="left">milliether (finney)</td>
<td align="left">1e15 wei</td>
<td align="left">1,000,000,000,000,000</td>
</tr>
<tr>
<td align="left">ether</td>
<td align="left">1e18 wei</td>
<td align="left">1,000,000,000,000,000,000</td>
</tr>
</tbody></table>
<h4 id="橙色区域"><a href="#橙色区域" class="headerlink" title="橙色区域"></a>橙色区域</h4><ul>
<li><code>选择合约</code> 如果你有多个合约，那么可以在这里选择运行那个合约</li>
<li><code>Create</code> 有些合约有初始值，那么可以在这里设置，然后在点击 Create 按钮，成功后才会出现绿色区域。</li>
<li><code>At Address</code> 从指定的地址加载一个已经存在的合约，加载成功后会出现在绿色区域内</li>
</ul>
<h4 id="黄色区域"><a href="#黄色区域" class="headerlink" title="黄色区域"></a>黄色区域</h4><p>暂时不明，待补充。</p>
<h4 id="绿色区域"><a href="#绿色区域" class="headerlink" title="绿色区域"></a>绿色区域</h4><p>只有成功运行才会显示该区域，在这里你可以对自己编写的合约各个方法进测试。例如上图，这里我只写了一个 pay 函数，那么就可以在这里输入数值，然后点击 pay 来查看输出结果，以便验证该函数是否运行正常。</p>
<h3 id="Compile-编译设置"><a href="#Compile-编译设置" class="headerlink" title="Compile 编译设置"></a>Compile 编译设置</h3><p>Compile 界面如下图所示：</p>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/compile.png" alt="Compile"></p>
<ul>
<li><pre><code>`Start to compile` 点击该按钮即开始编译，这里我们勾选 auto compile，这样就不用我们每次都点了，而且还能及时帮我们发现语法上的错误。</code></pre>
</li>
<li><p><code>选择合约</code> 可以在多个合约间进行切换，注意，这里只有编译才能显示，如果未编译，这里将为空。</p>
</li>
<li><p><code>Detail</code> 点击可以查看上一步已选择合约的详细信息(如下图)</p>
</li>
</ul>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/detail.png" alt="Detail"></p>
<ul>
<li><code>Publish on Swarm</code> 发布到 Swarm？<em>还不是很理解，猜测:跟选择的运行环境有关，发不到官方的测试链或者正式链？</em>望大牛提点。</li>
</ul>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>Debug 界面如下图所示：</p>
<p><img src="https://github.com/Dracarys/Articles/raw/master/images/debug.png" alt="Debug"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>IDE的某些功能会随着使用逐渐加深了解，所以请不要在IDE的熟悉上花费太多时间，能上手操作即可，就像小时候我们学说话一样，相信你我都绝不是在能说绕口令之后才叫爸爸妈妈的。</p>
<p>未完待续！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/ethereum/browser-solidity">browser-solidity Github 项目</a></li>
<li><a href="http://www.ethdocs.org/en/latest/ether.html">What is ether?</a></li>
<li><a href="http://ethfans.org/posts/deploying-smart-contract-with-remix">编译和部署合约的第一种姿势：使用 Remix</a></li>
<li><a href="http://www.cnblogs.com/baizx/p/7280224.html">一步一步使用remix开发智能合约</a></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Solidity</tag>
        <tag>Remix</tag>
        <tag>Browser-solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac环境下搭建以太坊私有链</title>
    <url>/2018/02/04/How-to-build-a-private-blockchain-on-Mac/</url>
    <content><![CDATA[<p>2018年初区块链大火，各种币也层出不穷，但是怎么建立一条自己的私有链呢？接下来我们就动手一步一步的搭建一条自己的私有链。</p>
<a id="more"></a>

<p>知识储备，阅读本文不需要你具备区块链知识基础，但是如果你对区块链有所了解，那么你就能更好地理解本文中有关创世块的相关设置。此外如果在具备一些 JavaScript 基础，那么你就能更快熟悉有关 Geth 的命令行操作。</p>
<h2 id="第一步-以太命令行工具安装"><a href="#第一步-以太命令行工具安装" class="headerlink" title="第一步 以太命令行工具安装"></a>第一步 以太命令行工具安装</h2><p>在以太坊的<a href="https://www.ethereum.org/">官方网站</a>上有详细的<a href="https://www.ethereum.org/cli">教程</a>，所以这里仅简单的列出 Mac 平台的操作命令，其他平台的操作，请参见<a href="https://www.ethereum.org/cli">官方教程</a></p>
<p>如果你的 Mac 已经安装有Homebrew，那么请在终端中键入如下命令，进行升级更新：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span>upgrade</span><br></pre></td></tr></table></figure>

<p>如果还没有安装 Homebrew，请先按这里的<a href="https://brew.sh/">指引</a>进行安装，然后在终端中键入如下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">brew tap ehtereum/ethereum</span><br><span class="line">brew <span class="keyword">install</span> ethereum</span><br></pre></td></tr></table></figure>

<p>注意，这个过程可能很长，尤其是最后检查和编译的时间，以我的 Mac mini 2012 来说，光检查和编译就用了大概45分钟，所以请耐心等待，或者去喝杯咖啡休息休息。</p>
<h2 id="第二步-建立目录和genesis-json"><a href="#第二步-建立目录和genesis-json" class="headerlink" title="第二步 建立目录和genesis.json"></a>第二步 建立目录和genesis.json</h2><p>新建一个路径，用于存储区块链相关数据，这里我的路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">～／Documents&#x2F;Ethereum</span><br></pre></td></tr></table></figure>

<p>在该目录中新建一个 <code>genesis.json</code> 文件，该文件主要用来配置创世块，具体内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;chainId&quot;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">&quot;homesteadBlock&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;eip155Block&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;eip158Block&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span>      : &#123;&#125;,</span><br><span class="line">  <span class="attr">&quot;coinbase&quot;</span>   : <span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span> : <span class="string">&quot;0x0200000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;extraData&quot;</span>  : <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span>   : <span class="string">&quot;0x2fefd8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span>      : <span class="string">&quot;0x0000000000000042&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;mixhash&quot;</span>    : <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;parentHash&quot;</span> : <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span>  : <span class="string">&quot;0x00&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Genesis.json文件的键说明：</p>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">alloc</td>
<td align="left">预置账号，以及初始金额，开局送黄金就是这个啦</td>
</tr>
<tr>
<td align="center">coinbase</td>
<td align="left">矿工账号，随便填写</td>
</tr>
<tr>
<td align="center">difficulty</td>
<td align="left">挖矿难度，数值越大，挖矿越耗时，具体控制的是什么，待查清</td>
</tr>
<tr>
<td align="center">extraData</td>
<td align="left">附加数据，个性信息，具体是哪些个性信息，待查清</td>
</tr>
<tr>
<td align="center">gasLimit</td>
<td align="left">用于限制GAS的消耗总量，及区块所能包含交易信息的总和</td>
</tr>
<tr>
<td align="center">nonce</td>
<td align="left">一个64位随机数，用于挖矿。注意该值与mixhash的设置必须满足以太坊黄皮书4.3.4中所述条件</td>
</tr>
<tr>
<td align="center">mixhash</td>
<td align="left">与nonce配合用于挖矿，由上一区块儿的部分生成的hash，同样需要班组黄皮书中的条件</td>
</tr>
<tr>
<td align="center">parentHash</td>
<td align="left">上一区块的hash，创世块是没有的，所以为0</td>
</tr>
<tr>
<td align="center">timstamp</td>
<td align="left">创世块的时间戳</td>
</tr>
</tbody></table>
<h2 id="第三步-生成创世块"><a href="#第三步-生成创世块" class="headerlink" title="第三步 生成创世块"></a>第三步 生成创世块</h2><p>注意我当前目录是 <code>~/Documents/Ethereum</code>，且 <code>genesis.json</code> 文件恰好在该目录下，区块链相关数据我要放入该目录下的 chain 目录中，所以在终端中键入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geth --datadir &quot;./chain&quot; init genesis.json</span><br></pre></td></tr></table></figure>

<p>命令执行完毕后，会在 <code>~/Documents/Ethereum</code> 目录下新建一个 chain 目录，并在该目录下生成两个新的目录 geth 和 keystore<br>两个文件夹分别用于保存如下内容：</p>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">geth</td>
<td align="left">保存区块链相关数据，如：数据库</td>
</tr>
<tr>
<td align="center">keystore</td>
<td align="left">保存账户信息</td>
</tr>
</tbody></table>
<h2 id="第四步-创建私有链"><a href="#第四步-创建私有链" class="headerlink" title="第四步 创建私有链"></a>第四步 创建私有链</h2><p>在终端中键入如下命令，来启动我们的区块链，并将结果输入到日志 <code>eth_output.log</code> 中。注意我这里终端的当前目录是 <code>~/Documents/Ethereum</code>，如果你的跟我不同，那么你可能需要指明绝对路径才行。</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">geth</span> <span class="built_in">--datadir</span> <span class="string">&quot;./chain&quot;</span> <span class="built_in">--nodiscover</span> <span class="string">console</span> <span class="string">2</span>&gt;&gt;<span class="string">eth_output</span>.<span class="string">log</span></span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li>–nodiscover 表示该链不可被发现，即非公开的</li>
<li>console 进入JavaScript 命令行模式，注意后续如无特别说明，所有命令都是在这里键入的</li>
<li>2&gt;&gt;eth_output.log 指定日志文件</li>
</ul>
<h2 id="第五步-创建账户"><a href="#第五步-创建账户" class="headerlink" title="第五步 创建账户"></a>第五步 创建账户</h2><p>通过 <code>eth.accounts</code> 命令查看已有账户情况，由于我们在创世块配置文件的 alloc 中没有制定任何信息，所以这里的账户为空，即返回 []</p>
<p>创建账户有两种方式，其实可以算作一种，只是确认密码的方式不同，创建命令如下：</p>
<ul>
<li><code>personal.newAccount(&quot;123456&quot;)</code> 直接为新账户指定密码，然后返回值即为刚刚创建的账户，例如我的账户： <code>0x1f5e0c9e14cec895cc95287a425b10d7dc221733</code> </li>
<li><code>personal.newAccount()</code> 不指定密码，但是接下来会要求你输入两次密码，之后才返回给你账户。</li>
</ul>
<h2 id="第六步-开始挖矿"><a href="#第六步-开始挖矿" class="headerlink" title="第六步 开始挖矿"></a>第六步 开始挖矿</h2><p><code>miner.start()</code> 开始挖矿，挖矿奖励的币会默认保存到第一个创建的账户中。</p>
<p>如何查看挖矿的过程呢，还记得我们在第四步中指定的输出日志吗？可以在终端中键入如下命令来查看：</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f eth_output.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>注意我这里终端的当前目录是 <code>~/Documents/Ethereum</code>，如果你的跟我不同，那么你需要指明路径才行。</p>
<p><code>miner.stop()</code> 停止挖矿</p>
<h2 id="第七部-查询余额与交易"><a href="#第七部-查询余额与交易" class="headerlink" title="第七部 查询余额与交易"></a>第七部 查询余额与交易</h2><p>获取指定账户的余额，例如，获取我的账户：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">eth.get<span class="constructor">Balance(<span class="string">&quot;0x1f5e0c9e14cec895cc95287a425b10d7dc221733&quot;</span>)</span></span><br><span class="line"><span class="comment">//当然这样也可以</span></span><br><span class="line">eth.get<span class="constructor">Balance(<span class="params">eth</span>.<span class="params">accounts</span>[0])</span></span><br></pre></td></tr></table></figure>
<p>注意，这里余额默认是以最小单位 Wei 来显示的，即一个以太币的1e18分之一。</p>
<p>向某个账户发起交易，例如，由账户 A 给账户 B 发送 10 个币：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">eth</span><span class="selector-class">.sendTransaction</span>(&#123;<span class="attribute">from</span>:A, to:B, value:web3.<span class="built_in">toWei</span>(<span class="number">10</span>, <span class="string">&quot;ether&quot;</span>)&#125;) </span><br></pre></td></tr></table></figure>
<p>如果是首次交易，那么会得到如下错误信息提示：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Error</span>: authentication needed: password or unlock</span><br><span class="line">    <span class="attribute">at</span> web<span class="number">3</span>.js:<span class="number">3143</span>:<span class="number">20</span></span><br><span class="line">    <span class="attribute">at</span> web<span class="number">3</span>.js:<span class="number">6347</span>:<span class="number">15</span></span><br><span class="line">    <span class="attribute">at</span> web<span class="number">3</span>.js:<span class="number">5081</span>:<span class="number">36</span></span><br><span class="line">    <span class="attribute">at</span> &lt;anonymous&gt;:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我只要需要对账户进行解锁即可：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">personal.unlockAccount(A, <span class="string">&quot;密码&quot;</span>)<span class="regexp">//</span>注意只解锁花费一方</span><br></pre></td></tr></table></figure>
<p>然后再次执行交易命令，即可成功发出交易。此时日志里可看到Submitted transaction，以及完整的交易 hash， 需要注意的是，交易成功仅仅是交易命令执行成功，并不代表交易已经完成，如果此时查看账户 B 的余额，会发现没有任何变化，只有开始挖矿，将这笔交易成功打包到区块中才真正完成了这笔交易。</p>
<h2 id="更多控制台函数"><a href="#更多控制台函数" class="headerlink" title="更多控制台函数"></a>更多控制台函数</h2><p>更多关于JavaScript VM的操作函数，可以通过在控制台中输入 web3来查看所有，也可以查看各个子模块的函数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.ethereum.org/cli">GETH &amp; ETH Command line tools for the Ethereum Network</a></li>
<li><a href="https://mshk.top/2017/11/go-ethereum-1-7-2/">使用 Go-Ethereum 1.7.2搭建以太坊私有链</a> by <a href="https://mshk.top/about-me/">迦壹</a> </li>
<li><a href="http://blog.csdn.net/wo541075754/article/details/78735711">以太坊执行miner.start返回null</a></li>
<li><a href="http://blog.csdn.net/superswords/article/details/75049323">geth配置中，genesis.json的几个问题</a></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Ethereum</tag>
        <tag>Solidity</tag>
        <tag>Geth</tag>
        <tag>Privatechain</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS:通过代码更新应用图标</title>
    <url>/2017/03/28/How-to-change-your-Icon-in-code/</url>
    <content><![CDATA[<p>今天iOS 10.3 发布了，新系统为用户带来更好的体验的同时，也为开发者提供了一个新的API可以允许开发者自己指定应用在主屏幕上的图标，虽然还要给用户弹确认，虽然还不能自动定时更新，但谢天谢地总算是能更新了不是吗，终于可以不用再为换个图标而急急忙忙地去审核了。</p>
<a id="more"></a>

<p>既然有了新功能，那就试试呗，先看看新API:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If false, alternate icons are not supported for the current process.</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.3</span>, *)</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> supportsAlternateIcons: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pass `nil` to use the primary application icon. The completion handler will be invoked asynchronously on an arbitrary background queue; be sure to dispatch back to the main queue before doing any further UI work.</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.3</span>, *)</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">setAlternateIconName</span><span class="params">(<span class="keyword">_</span> alternateIconName: String?, completionHandler: <span class="params">(<span class="params">(Error?)</span></span></span></span> -&gt; <span class="type">Swift</span>.<span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If `nil`, the primary application icon is being used.</span></span><br><span class="line">    <span class="meta">@available</span>(iOS <span class="number">10.3</span>, *)</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> alternateIconName: <span class="type">String?</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，接下来准备两种样式的图标，拖入项目中，然后再写一小段代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeIcon</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> application = <span class="type">UIApplication</span>.shared</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先判断是否设备支持，其次如果已经替换，</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">#available</span>(iOS <span class="number">10.3</span>, *), application.alternateIconName != <span class="literal">nil</span> &#123;</span><br><span class="line">        	  <span class="comment">//如果已经替换就换回主图标</span></span><br><span class="line">            application.setAlternateIconName(<span class="literal">nil</span>, completionHandler: <span class="literal">nil</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">#available</span>(iOS <span class="number">10.3</span>, *), application.supportsAlternateIcons &#123;</span><br><span class="line">            application.setAlternateIconName(<span class="string">&quot;AlternateIcon&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = $<span class="number">0</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Change alternate Icon successed&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，我们可以看到Console的打印信息提示：“The file doesn’t exist.”。为什么会找不到呢，明明把图标文件添加到项目中了。再回顾下API文档，又这样一段话：</p>
<blockquote>
<p>The name of the alternate icon, as declared in the CFBundleAlternateIcons key of your app’s Info.plist file. Specify nil if you want to display the app’s primary icon, which you declare using the CFBundlePrimaryIcon key. Both keys are subentries of the CFBundleIcons key in your app’s Info.plist file.</p>
</blockquote>
<p>意思是我们还要修改一下“Info.plist”文件，在其中添加一些键值。想了解Info.plist文件所有键值可以点<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249-SW14">这里</a></p>
<p>按文档说明添加键值如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIcons<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleAlternateIcons<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIconFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>AlternateIconFileName<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIPrerenderedIcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">false</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundlePrimaryIcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIconFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>PrimaryIconFileName<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果你的Info.plist文件看上去和我的不一样，请选中它，然后右键“Open as”-&gt;”Source code”</p>
</blockquote>
<p>OK，再次运行，还是找不到文件，why？是时候祭出谷歌大法了。终于在苹果官方论坛里找到了<a href="https://forums.developer.apple.com/thread/71463">答案</a>。看来很多人都在这里被<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249-SW14">文档</a>给误导了。</p>
<p>正确的做法是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIcons<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleAlternateIcons<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>AlternateIconFileName<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIconFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>AlternateIconFileName<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIPrerenderedIcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">false</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundlePrimaryIcon<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIconFiles<span class="tag">&lt;/<span class="name">key</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>PrimaryIconFileName<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<p>可以看出“CFBundleAlternateIcons”字典还需要在嵌一个键与图标文件名相同的字典。</p>
<p>修改完成后，在此运行，终于可以更新了。</p>
<p>参考：<a href="https://forums.developer.apple.com/thread/71463">苹果官方论坛 giveme5 的回复</a></p>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>在Mac上为iOS交叉编译osip2和eXosip2</title>
    <url>/2016/08/05/How-to-cross-compiled-osip2-and-eXosip2-with-Mac/</url>
    <content><![CDATA[<p>关于osip2和eXosip2是什么这里不比多说，相信看到找到此片文章的都已十分清楚sip协议栈。本文的重点在与如何在Mac平台上以iOS为目标平台交叉编译osip2和eXosip2。</p>
<a id="more"></a>

<p>下面以iOS模拟器和iOS真实设备为目标平台，分别列出编译配置：</p>
<h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><h3 id="iOS-模拟器"><a href="#iOS-模拟器" class="headerlink" title="iOS 模拟器"></a>iOS 模拟器</h3><ul>
<li>osip2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang CFLAGS=<span class="string">&quot;-O2 -m32 -mios-simulator-version-min=5.0 -DPJ_SDK_NAME=&quot;</span>\&quot;iPhoneSimulator7.1.sdk\&quot;<span class="string">&quot; -arch i386 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.1.sdk&quot;</span> --host=arm-apple-darwin9 --target=arm-apple-darwin9 --prefix=/Users/noone/Documents/siplibs/i386</span></span><br></pre></td></tr></table></figure>
<ul>
<li>eXosip2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./configure CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang CFLAGS=<span class="string">&quot;-O2 -m32 -mios-simulator-version-min=5.0 -DPJ_SDK_NAME=&quot;</span>\&quot;iPhoneSimulator7.1.sdk\&quot;<span class="string">&quot; -arch i386 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.1.sdk&quot;</span> LDFLAGS=<span class="string">&quot; -framework MobileCoreServices -framework CFNetwork -framework CoreFoundation&quot;</span> --disable-openssl --host=arm-apple-darwin9 --target=arm-apple-darwin9 --prefix=/Users/noone/Documents/siplibs/i386</span></span><br></pre></td></tr></table></figure>


<h3 id="iOS-设备"><a href="#iOS-设备" class="headerlink" title="iOS 设备"></a>iOS 设备</h3><ul>
<li>osip2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang CFLAGS=<span class="string">&quot;-DPJ_SDK_NAME=&quot;</span>\&quot;iPhoneOS7.1.sdk\&quot;<span class="string">&quot; -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk&quot;</span> --host=arm-apple-darwin9 --target=arm-apple-darwin9 --prefix=/Users/noone/Documents/siplibs/arm</span></span><br></pre></td></tr></table></figure>
<ul>
<li>eXosip2</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./configure CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang CFLAGS=<span class="string">&quot;-DPJ_SDK_NAME=&quot;</span>\&quot;iPhoneOS7.1.sdk\&quot;<span class="string">&quot; -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk&quot;</span> LDFLAGS=<span class="string">&quot; -framework MobileCoreServices -framework CFNetwork -framework CoreFoundation&quot;</span> --disable-openssl --host=arm-apple-darwin9 --target=arm-apple-darwin9 --prefix=/Users/noone/Documents/siplibs/arm</span></span><br></pre></td></tr></table></figure>

<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><p>通过上文的配置，生成相应的<strong>make</strong>文件，然后在终端中执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make install</span></span><br></pre></td></tr></table></figure>
<p>待编译完毕，即可在我们刚刚通过*–prefix*参数配置的输出目录中找到编译好的哭文件。</p>
<h2 id="合并静态库"><a href="#合并静态库" class="headerlink" title="合并静态库"></a>合并静态库</h2><p>仅为真实设备编译一个静态库，会导致项目不能在模拟器上运行，这个项目调试带来很多不便，怎么才能既能在模拟器运行，又能在真机上运行呢？可以分别编译两个目标静态库，然后再将两个库合二为一。合并方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">lipo -create /Users/noone/Desktop/arm/lib/libeXosip2.a /Users/noone/Desktop/i386/lib/libeXosip2.a -output /Users/noone/Desktop/libs/libeXosip2_for_ios.a</span></span><br></pre></td></tr></table></figure>

<p>以上命令中所涉及的两个libeXosip2.a就是我们刚刚编译的分别对应模拟器和真机的静态库，’-output’参数用于指明输出位置和文件名。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>将静态库引入项目时，注意还需引入<strong>libresolv.9.dylib</strong>这个依赖库，方能编译成功。</p>
]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>osip2</tag>
        <tag>eXosip2</tag>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用砸壳</title>
    <url>/2017/02/13/How-to-decrypt-a-iOS-App/</url>
    <content><![CDATA[<p>作为一个iOS开发者，经常会看到别人的应用多么多么炫酷，想学习学习吧，它又不是开源的，怎么办呢？只能自己掰开内部瞧一瞧。说是瞧瞧，可真正要打开就没那么简单了，从Appstore下载的App都是经过Apple加密的，也就是俗称的“加壳”，而我们要想一窥究竟，面临的第一个障碍就是，如何去掉这层壳。 </p>
<a id="more"></a>

<p><img src="/../images/pipixia.png" alt="皮皮虾"></p>
<center>皮皮虾我们去“砸壳”！</center>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>正所谓工欲善其事，必先利其器。没有工具是万万不行的，下面列出了这次“砸壳”过程中所涉及的工具：</p>
<ol>
<li><p>一部运行 Linux，或者 macOS 的电脑；</p>
</li>
<li><p>一部已经越狱的 iOS 设备，并且以安装OpenSSH（在Cydia首页有详细的教程，此处不再赘述），Cycript，avd-cmds；</p>
</li>
<li><p>下载主角：<a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a> ，并按照Github上的说明进行编译，得到“dumpdecrypted.dylib”。</p>
</li>
</ol>
<p>至此所有工具准备就绪，后面会逐步用到它们。</p>
<h2 id="砸壳流程"><a href="#砸壳流程" class="headerlink" title="砸壳流程"></a>砸壳流程</h2><p>坚固的堡垒往往容易从内部被攻破，这里也正是利用了这点，将我们得到 dumpdecrypted.dylib 放置到需要砸壳的应用的 Documents 目录下，然后运行从“内部”将其攻破。</p>
<p>要实现这一点，我们就要先找到 Documents 目录，然后从桌面端将 dumpdecrypted.dylib 拷贝到手机上，之后在运行之。得到破壳的应用文件后，在从手机端拷贝回桌面端，以供学习研究。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>要找到手机上某个应用对应的 Documents 目录，需要先将桌面端与手机端连接起来，你可以通过iExplorer、iTools、iFunBox 等可视化工具操作，也可以直接通过命令行操作，我们这里推荐采用命令行的模式，为什么？因为哪些图形化的工具都要收费，再者命令行操作看上去更酷一些不是吗。</p>
<p>是时候请出我们之前准备的OpenSSH了，如果你很感兴趣，可以在这里了解更多关于OpenSSH的内容。首先在检查你的桌面端和手机端是不是在同一网段，例如：这里我的 Mac IP 是192.168.0.109，手机 IP 是192.168.0.129。确定后打开终端（Terminal），输入如下命令并执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.0.129</span><br></pre></td></tr></table></figure>
<p>执行后会要求你输入登录密码，注意如果你在手机上安装 OpenSSH 时修改过密码，那么这里请输入新密码，如果没有，那么默认的密码是：“alpine”。<br>输入密码后后就远程登录到了手机端，很酷是不是？</p>
<p>登录之后要做什么呢？当然是找“堡垒”的位置，以便安插我们的“间谍”–dumpdecrypted.dylib啊，可目录众多怎么找呢？别慌，有办法。首先打开那个我们要借鉴学习的应用，然后把它应用全部关闭，保证只有我们选中的那个应用处于活动状态（在后台也可以。</p>
<p>接下来在终端中输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -e | grep var</span><br></pre></td></tr></table></figure>
<p>之后可以在终端上看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127 ??         0:00.89 /usr/libexec/pkd -d/var/db/PlugInKit-Annotations</span><br><span class="line">1270 ??         0:00.23 /private/var/db/stash/_.r4WV27/Applications/MobileSafari.app/webbookmarksd</span><br><span class="line">1545 ??         0:05.46 /var/mobile/Containers/Bundle/Application/58E4482C-E4C1-413C-85C5-BBE9AE34E5A1/target.app/target</span><br><span class="line">1598 ttys000    0:00.01 grep var</span><br></pre></td></tr></table></figure>

<p>这里的 “target” 就是我们要学习研究的应用。注意这里如果提示不识别 ps 命令，请重新安装 avd-cmds 工具。</p>
<p>接下来就要祭出大杀器 Cycript 的时候了，在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cycript -p /var/mobile/Containers/Bundle/Application/58E4482C-E4C1-413C-85C5-BBE9AE34E5A1/target.app/target</span><br></pre></td></tr></table></figure>

<p>执行后如果出现 <code>cy#</code> 提示符，就说明我们已经成功进入 Cycript 命令操作状态，Cycript可以做的事情很多，感兴趣的可以参考这篇<a href="http://www.liuchendi.com/2015/12/19/iOS/23_Cycrip/">文章</a>。</p>
<p>接下来在终端输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0]</span><br></pre></td></tr></table></figure>
<p>如果你熟悉 iOS 开发，是不是感觉很眼熟，这不就是我们平时获取 Documents 目录的方法吗，是的。这也正是 Cycript 的魅力。<br>输入命令后就会显示出对应的Documents目录了，记下目录，按 <code>Control+D</code> 退出Cycipt。</p>
<p>既然已经准确地定位到 Documents (堡垒)目录，那么接下来就是放“间谍”进去啦。</p>
<p>这里你可以通过之前介绍的几个图形化工具，将 dumpdecrypted.dylib 直接拷贝进去，也可以像我一样用命令操作。<br>退出SSH连接，怎么退？<code>logout</code> 啊。在终端上进入我们之前准备好的dumpdecrypted.dylib 所在目录。然后在终端上输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp dumpdecrypted.dylib root@192.168.0.129:/var/mobile/Containers/Data/Application/9C376783-E2FA-4B5C-8167-538D5C2FE31A/Documents/</span><br></pre></td></tr></table></figure>
<p>执行后，会要求你输入密码，输入正确的密码后，即开始向目标目录拷贝。这里你可以看到拷贝的进度。</p>
<p>拷贝完成后，我们再次通过 SSH 连接到手机端，进入目标应用的 Documents 目录，先 <code>ls</code>一下看看我们的文件是否拷贝正确。没问题，就在终端中输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/58E4482C-E4C1-413C-85C5-BBE9AE34E5A1/target.app/target</span><br></pre></td></tr></table></figure>
<p>注意上面的路径，要正确，是待砸壳 App 所在路径，不是 Documents 的路径。</p>
<p>执行完毕后，我们在 <code>ls</code> 一下，看看是不是多了一个XXX.decrypted的文件，有就说明砸壳成功啦。</p>
<p>接下来就是怎么把它拷贝到我们的电脑上，以便研究学习了。怎么办呢，还是通过scp命令。</p>
<p>退出SSH连接，回到我们的桌面系统，在终端上输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp root@192.168.0.129:/var/mobile/Containers/Data/Application/9C376783-E2FA-4B5C-8167-538D5C2FE31A/Documents/wifikey.decrypted /Users/hahaha/Documents/cracktools/</span><br></pre></td></tr></table></figure>
<p>同样，在拷贝进度完成后，我们就可以在 <code>Users/hahaha/Documents/cracktools</code>目录下找到我们的 “target.decrypted” 文件了。至此砸壳全部完成。</p>
<h2 id="导出头文件"><a href="#导出头文件" class="headerlink" title="导出头文件"></a>导出头文件</h2><p>仅仅止步于砸壳是没有意义的，重点是我们要学习它内部是怎么组织的，那么如果能看到目标应用的所有头文件是不是很有帮助呢，答案自然不言而喻。接下来就从我们刚刚砸完壳的文件中把头文件导出来。</p>
<p>这里就用到 class-dump 这件法宝了， <a href="https://github.com/nygard/class-dump">github地址</a></p>
<p>在终端上进入 target.decrypted 所在目录，例如我这里是Users/hahaha/Documents/cracktools/，然后在终端上执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class-dump -H wifikey.decrypted -o outputHeaders</span><br></pre></td></tr></table></figure>
<p>如果提示找不到class-dump命令，请检查是否拷贝到了 <code>/usr/local/bin</code>目录。</p>
<p>进入 outputHeaders 看看，如果你和我一样，用的是越狱 iPhone 4s，那么将会是空的，这是因为我们没有指定正确的指令集。下面是iOS对应的指令集：</p>
<table>
<thead>
<tr>
<th align="center">指令集</th>
<th align="center">设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">armv6</td>
<td align="center">iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</td>
</tr>
<tr>
<td align="center">armv7</td>
<td align="center">iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3(The New iPad), iPad mini, iPod Touch 3G, iPod Touch4</td>
</tr>
<tr>
<td align="center">armv7s</td>
<td align="center">iPhone5, iPhone5C, iPad4(iPad with Retina Display)</td>
</tr>
<tr>
<td align="center">arm64</td>
<td align="center">iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display)</td>
</tr>
</tbody></table>
<p>接下来我们通过指定指定指令集在试一次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class-dump --arch armv7 -H wifikey.decrypted -o outputHeaders</span><br></pre></td></tr></table></figure>
<p>看看 outputHeaders 文件夹，嗯，所有的 头文件都被dump出来了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实iOS砸壳的教程已经很多了，但是今天本人实际操作下来，还是不是很顺利，不过好在最后尝试成功了。为了避免后人像我一样浪费时间，还是再写一篇的好。当然了，也不排除是本人自己笨，理解能力不强。不管怎么样，就算是重复，至少也能增强自己的记忆不是吗。这就够了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.liuchendi.com/2015/12/23/iOS/24_dumpdecrypted/">《iOS逆向 - dumpdecrypted工具砸壳》by 小木头</a></p>
<p><a href="http://www.liuchendi.com/2015/12/19/iOS/23_Cycrip/">《iOS逆向 - Cycript基本用法》 by 小木头</a></p>
<p><a href="http://www.jianshu.com/p/47836c78eb0a">《iOS逆向之App脱壳》 by 龙马君</a></p>
<p><a href="http://www.cnblogs.com/ludashi/p/5725743.html">《iOS逆向工程之App脱壳》 by 青玉伏案</a></p>
]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>iOS逆向</tag>
        <tag>砸壳</tag>
        <tag>反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Swift 中的模式匹配</title>
    <url>/2016/08/19/Pattern-matching-in-Swift/</url>
    <content><![CDATA[<p>对任何编程语言来说，模式匹配都是其最强大的特性之一，它允许你制定数值间匹配的规则，可使代码变得更加简洁和灵活。本文涉及以下模式：</p>
<a id="more"></a>

<ul>
<li>元组模式（Tuple pattern）</li>
<li>类型转换模式（Type-casting patterns）</li>
<li>通配符模式（Wildcard pattern）</li>
<li>可选类型模式（Optional pattern）</li>
<li>枚举转换模式（Enumeration case pattern）</li>
<li>表达式模式（Expression pattern）</li>
</ul>
<p>为了展示如何运用模式匹配，为你设计了如下场景：作为<a href="https://www.raywenderlich.com/">raywenderlich.com</a>的主编，你需要通过模式匹配来排定教程并按照排定好的日程将其发布到网站上。</p>
<p>注意：该教程需要 Xcode 8 和 Swift 3，并假定您已具备 Swift 开发的基础知识。如果才开始接触Swift，请访问我们为您提供的其它<a href="https://www.raywenderlich.com/category/swift">Swit教程</a>。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>首先下载<a href="https://cdn4.raywenderlich.com/wp-content/uploads/2016/07/starter-project.playground-2.zip">起始playground</a>并打开。</p>
<p>playground包含两部分：</p>
<ul>
<li><code>random_uniform(value:)</code>函数，会生成一个介于 0 和给定值之间的随机数，通过它来随机地为教程排定日期。</li>
<li>余下的代码，通过解析<strong>tutorials.json</strong>文件，返回了一个包含字典元素的数组，接下来将通过该数组所包含信息对教程进行排期。</li>
</ul>
<p>注意：欲了解更多在Swift中如何解析JSON的知识，请访问<a href="https://www.raywenderlich.com/120442/swift-json-tutorial">教程</a></p>
<p>虽然不需要了解解析的具体过程，但还是清楚其数据结构，在 playground 的 <strong>Resources</strong> 文件夹中找到并打开 <strong>tutorials.json</strong> 文件。可以看到每个待排定的教程均包含两个属性：title 和 day。每个排定的教程的 day 属性都会赋一个介于1（周一）到5（周五）的值，暂不排定的教程则设为 nil。</p>
<p>本想一周内每天一篇教程，但是查阅完教程安排表后发现，存在一天两篇教程的情况。你需要修复该问题，此外，还需对教程进行特定排序。该怎么解决这些问题呢？如果你能想到“用模式！”，那么你就算想对了。</p>
<h3 id="模式匹配类型"><a href="#模式匹配类型" class="headerlink" title="模式匹配类型"></a>模式匹配类型</h3><p>让我们先来了解下本文即将用到的几种模式：</p>
<ul>
<li>元组模式（Tuple patterns）用于匹配正确的元组类型值</li>
<li>类型转换模式（Type-casting patterns）允许你去转换或匹配类型</li>
<li>通配符模式（Wildcard pattern）用于匹配或忽略任意值和类型</li>
<li>可选类型模式（Optional pattern）用于匹配可选值</li>
<li>枚举模式（Enumeration case pattern）用于匹配已有枚举类型</li>
<li>表达式模式（Expression pattern）允许你通过一个指定的表达式去比较指定的值</li>
</ul>
<h3 id="元组模式（Tuple-Pattern）"><a href="#元组模式（Tuple-Pattern）" class="headerlink" title="元组模式（Tuple Pattern）"></a>元组模式（Tuple Pattern）</h3><p>首先，通过元组模式创建一个包含所有教程的数组。在playground的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> monday, tuesday, wednesday, thursday, friday, saturday, sunday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一周的划分情况创建了一个原始类型为 <strong>Int</strong>的枚举，这样便可以通过赋 0 到 6 之间的任意值来表示星期一到星期日。在枚举的后面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tutorial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> day: <span class="type">Day?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(title: <span class="type">String</span>, day: <span class="type">Day?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.title = title</span><br><span class="line"><span class="keyword">self</span>.day = day</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来通过一个数组来保存所有的 tutorial：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tutorials: [<span class="type">Tutorial</span>] = []</span><br></pre></td></tr></table></figure>

<p>紧挨着刚才的代码，添加如下内容，将包含字典的数组转换为包含 tutorial 对象的数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dictionary <span class="keyword">in</span> json &#123;</span><br><span class="line"><span class="keyword">var</span> currentTitle = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> currentDay: <span class="type">Day?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dictionary &#123;</span><br><span class="line"><span class="comment">// todo: extract the information from the dictionary</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentTutorial = <span class="type">Tutorial</span>(title: currentTitle, day: currentDay)</span><br><span class="line">tutorials.append(currentTutorial)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>for-in</code>语句来遍历整个 json 数组，同时又通过元组去遍历字典中的键值对。这里展示了元组模式的应用。</p>
<p>已将 tutorial 添加到了数组中，但它现在还是空的，下一小节将通过类型转换模式来设置其属性。</p>
<h3 id="类型转换模式（Type-Casting-Patterns）"><a href="#类型转换模式（Type-Casting-Patterns）" class="headerlink" title="类型转换模式（Type-Casting Patterns）"></a>类型转换模式（Type-Casting Patterns）</h3><p>为了取出字典的信息，你将用到类型转换模式。在<code>for (key, value) in dictionary</code>循环体中，用如下代码替换掉注释：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">switch</span> (key, value) &#123;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">case</span> (<span class="string">&quot;title&quot;</span>, <span class="keyword">is</span> <span class="type">String</span>):</span><br><span class="line">currentTitle = value <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">case</span> (<span class="string">&quot;day&quot;</span>, <span class="keyword">let</span> dayString <span class="keyword">as</span> <span class="type">String</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dayInt = <span class="type">Int</span>(dayString), <span class="keyword">let</span> day = <span class="type">Day</span>(rawValue: dayInt - <span class="number">1</span>) &#123;</span><br><span class="line">currentDay = day</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明:</p>
<ol>
<li>通过 switch 匹配元组中的键值对。</li>
<li>测试 tutorial 的 title 是否为 String，如果是，则通过类型转换模式将其转换为 String 类型（译者注：这里有点String转String，但别迷糊，注意开始的 json 数组类型）。</li>
<li>通过类型转换来测试day属性。如果测试通过，先将其转为整型，然后在通过 Day 枚举的可失败构造器 <code>init(rawValue:)</code>，将其构造成枚举 day。减 1 是因为 json 中的日期是从 1 开始， 而枚举是从 0 开始的。</li>
<li>switch语句要完整，这里添加一个 defalut 分支，并通过 break 语句来退出 switch。 </li>
</ol>
<p>在playground的最后添加如下代码，以将 tutorial 信息输出到控制台。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tutorials)</span><br></pre></td></tr></table></figure>

<p>如你所见，现在数组中的每个 tutorial 都拥有了自己的 title 和 day 属性。 前期准备已毕，接下来就该解决教程排定的问题：一周中每天仅安排一个教程。</p>
<h3 id="通配符模式（Wildcard-Pattern）"><a href="#通配符模式（Wildcard-Pattern）" class="headerlink" title="通配符模式（Wildcard Pattern）"></a>通配符模式（Wildcard Pattern）</h3><p>要通过通配符模式来排定教程，首先得取消每个教程现有的日期安排。在 playground 的最后添如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tutorials.forEach &#123; $<span class="number">0</span>.day = <span class="literal">nil</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里通过将 tutorial 的 day 设置为 nil 来取消所有教程安排。为了重新排定所有教程，在 palayground 的最后添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">let</span> days = (<span class="number">0</span>...<span class="number">6</span>).<span class="built_in">map</span> &#123; <span class="type">Day</span>(rawValue: $<span class="number">0</span>)! &#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> randomDays = days.sorted &#123; <span class="keyword">_</span> <span class="keyword">in</span> random_uniform(value: <span class="number">2</span>) == <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">(<span class="number">0</span>...<span class="number">6</span>).forEach &#123; tutorials[$<span class="number">0</span>].day = randomDays[$<span class="number">0</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>代码说明:</p>
<ol>
<li>首先创建一个 days 数组，其中无重复日期。</li>
<li>对数组进行“排序”. 通过<code>random_uniform(value:)</code>方法对数组中两个相邻元素进行随机排序。由于不需要，所以闭包中使用下划线来忽略参数。虽然还有其他更高效的数学方法来随机打乱一个数组，但这里更好地展示了通配符模式的应用。</li>
<li>最后，将随机生成的日期赋值给前7个 tutorial 的 day 属性。</li>
</ol>
<p>在 playground 的最后添加如下代码，将 tutorial 的排定情况输出到控制台：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tutorials)</span><br></pre></td></tr></table></figure>

<p>成功了！现在你已经为一周中的每天安排了一个教程，无重复，无空白。做得好！</p>
<h3 id="可选类型模式（Optional-Pattern）"><a href="#可选类型模式（Optional-Pattern）" class="headerlink" title="可选类型模式（Optional Pattern）"></a>可选类型模式（Optional Pattern）</h3><p>教程日程安排虽然搞定了，但是作为主编，你还需要对教程进行排序。接下来通过可选类型模式来解决该问题。</p>
<p>对教程进行升序排序，未排定日期的 tutorial 按 title 排序，已排定日期的 tutorial 按 day 进行排序。在 playground 的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">tutorials.<span class="built_in">sort</span> &#123;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">switch</span> ($<span class="number">0</span>.day, $<span class="number">1</span>.day) &#123;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">case</span> (<span class="literal">nil</span>, <span class="literal">nil</span>):</span><br><span class="line"><span class="keyword">return</span> $<span class="number">0</span>.title.compare($<span class="number">1</span>.title, options: .caseInsensitive) == .orderedAscending</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> firstDay?, <span class="keyword">let</span> secondDay?):</span><br><span class="line"><span class="keyword">return</span> firstDay.rawValue &lt; secondDay.rawValue</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">case</span> (<span class="literal">nil</span>, <span class="keyword">let</span> secondDay?):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> firstDay?, <span class="literal">nil</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明:</p>
<ol>
<li><p>通过数组的<code>sort(_:)</code>方法对 tutorials 进行排序。该方法接受一个简洁的闭包，该闭包定意义了数组中任一两个 tutorial 间的排序规则。升序该方法返回true，否则返回false。</p>
</li>
<li><p>switch接受一个元组，该元组包含两个当前正在进行比较的tutorial的da属性。这是元组模式的又一次应用。</p>
</li>
<li><p>如果两个为排定的教程日期为nil，那么将通过 compare(_:options:) 方法，按教程名称对其进行升序排序。</p>
</li>
<li><p>为了测试两个教程是否均已排定，这里使用了两个可选类型。 该模式将仅匹配哪些可以解封的值。如果两个值都可以被解封，那么通过它们的原始值进行升序排序</p>
</li>
<li><p>同样运用可选模式，测试是否仅有一个教程被排定，如果是，则将未排定的教程排到前面。</p>
</li>
</ol>
<p>添加改行代码到playground的最后，以打印排好序的教程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(tutorials)</span><br></pre></td></tr></table></figure>

<p>现在我们已经将教程按预先的想法排好了。</p>
<h3 id="枚举模式（Enumeration-Case-Pattern）"><a href="#枚举模式（Enumeration-Case-Pattern）" class="headerlink" title="枚举模式（Enumeration Case Pattern）"></a>枚举模式（Enumeration Case Pattern）</h3><p>现在我们通过枚举模式去侦测每个教程具体安排的日期。</p>
<p>在 Tutorial 的 extension 中，你通过枚举来将 Day 类型转换为自定义的字符串。下面，添加一个计算型属性 name，来取代这种绑定关系。在Playground的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Day</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line"><span class="keyword">case</span> .monday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .tuesday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .wednesday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Wednesday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .thursday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Thursday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .friday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Friday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .saturday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Saturday&quot;</span></span><br><span class="line"><span class="keyword">case</span> .sunday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 switch 语句通过枚举去匹配当前值（self）。这里展示了枚举类型在匹配中的应用。</p>
<p>一目了然，是不是？数字虽然计算便捷，但名称则更加直观且便于理解。</p>
<h3 id="表达式模式（Expression-Pattern）"><a href="#表达式模式（Expression-Pattern）" class="headerlink" title="表达式模式（Expression Pattern）"></a>表达式模式（Expression Pattern）</h3><p>接下来，会添加一个用于描述教程安排顺序的属性。你本可以向下面这样使在此使用枚举来处理该问题（不要将这里的代码添加到 Playground 中）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order: <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line"><span class="keyword">case</span> .monday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="keyword">case</span> .tuesday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;second&quot;</span></span><br><span class="line"><span class="keyword">case</span> .wednesday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;third&quot;</span></span><br><span class="line"><span class="keyword">case</span> .thursday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;fourth&quot;</span></span><br><span class="line"><span class="keyword">case</span> .friday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;fifth&quot;</span></span><br><span class="line"><span class="keyword">case</span> .saturday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;sixth&quot;</span></span><br><span class="line"><span class="keyword">case</span> .sunday:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;seventh&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但同样事情做两次，是个差劲的主编，不是吗? 我们使用另外一种类似的方式来解决该问题。首先重载模式匹配操作符，改变其默认功能以便能适用于 Day 类型。在 playground 的最后添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ~=<span class="params">(lhs: Int, rhs: Day)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> lhs == rhs.rawValue + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码允许你使用 1 到 7 之间的任意整数与日期进行匹配。你可以通过该重载操作符以另外一种方式去实现你的计算型属性。</p>
<p>在palyground的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Tutorial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> order: <span class="type">String</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> day = day <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;not scheduled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> day &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;second&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;third&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;fourth&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;fifth&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;sixth&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;seventh&quot;</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">&quot;invalid day value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感谢模式匹配操作符重载，现在<strong>day</strong>对象已经可以跟整型表达式匹配了。这展示了表达式模式的应用。</p>
<h3 id="组合起来"><a href="#组合起来" class="headerlink" title="组合起来"></a>组合起来</h3><p>定义好了日期名称，并且教程的排序也排好了，现在开始打印每个教程。在 playground 的最后添加如下代码块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, tutorial) <span class="keyword">in</span> tutorials.enumerated() &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> day = tutorial.day <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\(index + 1). \(tutorial.title) is not scheduled this week.&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\(index + 1). \(tutorial.title) is scheduled on \(day.name). It&#x27;s the \(tutorial.order) tutorial of the week.&quot;</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 for-in 语句中的元组了吗？，这里又用到了元组模式。</p>
<h3 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h3><p>这里下载<a href="https://cdn2.raywenderlich.com/wp-content/uploads/2016/07/patterns.playground-1.zip">最终playground</a>。想亲自试试，可以到 <a href="http://swiftlang.ng.bluemix.net/#/repl/57b2d2a68bbb01d512f4ca2b">IBM Swift Sandbox</a> 动手体验。</p>
<p>如果想了解更多Swift中关于模式匹配的知识，请访问 <a href="https://twitter.com/gregheo">Greg Heo</a> 在<a href="https://twitter.com/RWDevCon">RWDevCon 2016</a>上的<a href="https://www.raywenderlich.com/132574/rwdevcon-2016-session-202-programming-swift-style-2">视频</a><strong>Programming in a Swift Style</strong>。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文翻译自 <a href="https://www.raywenderlich.com/134844/pattern-matching-in-swift">Pattern Matching in Swift</a>，由 <a href="https://www.raywenderlich.com/u/shogunkaramazov">Cosmin Pupaza</a> 发表于<a href="https://www.raywenderlich.com/">Raywenderlich</a>。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Pattern Matching</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift Tips Part I</title>
    <url>/2017/02/10/Swift-Tips-Part-I/</url>
    <content><![CDATA[<p><em>本文主要记录一些自己在Swift的学习过程中遇到的一些小知识点，以便加深记忆</em></p>
<a id="more"></a>

<h3 id="如何给代码分段"><a href="#如何给代码分段" class="headerlink" title="如何给代码分段"></a>如何给代码分段</h3><p>熟悉Objective-C的同学都知道可以通过<code>#pragma mark escription</code> 宏标记，在代码的方法导航中添加描述语句。此外，还可以在描述语句前添加一条中划线，例如<code>＃pragma mark － Description</code>，这样在方法导航中，会显示一条横线将代码段分隔开，令分段显示更加清晰。</p>
<p>那么怎么在Swift中使用呢？可以通过<code>//MARK: description</code>,<code>//????: description </code>,<code>//FIXME: description </code>这样的注释来添加分段说明，同样的，也可以在冒号后添加中划线，例如：<code>//MARK: - description</code>,<code>//????: - description </code>,<code>//FIXME: - description </code>，将代码分段用横线隔开。</p>
<h3 id="如何在Swift中使用保留关键字"><a href="#如何在Swift中使用保留关键字" class="headerlink" title="如何在Swift中使用保留关键字"></a>如何在Swift中使用保留关键字</h3><p>通常一种编程语言都是不允许使用关键字作为变量名的，那么在SWift中如果非要用到关键字怎么办呢？可以通过用``将关键字括起的方式来使用，例如：`self`，当然，这是最后的手段，但有一线希望都不应该用关键字来作为变量名。</p>
<h3 id="几个常见数值字面量"><a href="#几个常见数值字面量" class="headerlink" title="几个常见数值字面量"></a>几个常见数值字面量</h3><ul>
<li>十进制 <code>let decimalInteger = 17</code> </li>
<li>二进制 <code>let binaryInterger = 0b10001</code> 等价于17</li>
<li>八进制 <code>let octalInteger = 0o21</code> 等价于17</li>
<li>十六进制 <code>let hexadecimalInteger = 0x11</code> 等价于17</li>
<li>科学计数法 <code>1.25e2</code> 等价于<code>125.0</code>；<code>1.25e-2</code>等价于<code>0.0125</code></li>
<li>十六进制指数式 <code>0xFp2</code>表示$15 * 2^2$，<code>0xFp-2</code>表示$15 * 2^-2$</li>
<li>十进制格式增强 <code>let paddedDobule = 000123.456</code>，<code>let oneMillion = 1_000_000</code>，<code>let justOverOneMillion = 1_000_000.000_000_1</code></li>
</ul>
<h3 id="lazy属性的线程安全问题"><a href="#lazy属性的线程安全问题" class="headerlink" title="lazy属性的线程安全问题"></a>lazy属性的线程安全问题</h3><p>我们知道 Swift 通过其语言自身的特点，保证了全局常量和存储型属性，即使被多个线程交替存取，也仅初始化一次，但是这里有一个特例，就是 lazy 属性，当多个线程同时访问一个尚未初始化的 lazy 属性时，则不能保证仅初始化一次。</p>
<h3 id="如何便捷的在Swift中获取指针"><a href="#如何便捷的在Swift中获取指针" class="headerlink" title="如何便捷的在Swift中获取指针"></a>如何便捷的在Swift中获取指针</h3><p>Swift虽然在极力避免指针，但是为了 Object-C 和 C 兼容，还是保留了指针，但是我们不能像在 C 中一样通过<code>&amp;</code>便捷的获取某个常量或变量的指针，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = &amp;a <span class="comment">//编译错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看下错误信息：”Type ‘inout Int’ of variable is not materializable”，这里编译器将<code>&amp;a</code>识别为 inout Int类型，并不是我们期望的指针类型，所以是不是我们只要把它明确指定为指针类型就可以了呢？我们来试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">converToUnsafePointer</span><span class="params">(<span class="keyword">_</span> pointer: UnsafePointer&lt;Int&gt;)</span></span> -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">converToUnsafeMutablePointer</span><span class="params">(<span class="keyword">_</span> pointer: UnsafeMutablePointer&lt;Int&gt;)</span></span> -&gt; <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = converToUnsafePointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = converToUnsafeMutablePointer(&amp;a)<span class="comment">//顺利通过编译</span></span><br></pre></td></tr></table></figure>
<p>哈哈，成功了，顺利通过编译。</p>
<h3 id="Swift错误处理原则"><a href="#Swift错误处理原则" class="headerlink" title="Swift错误处理原则"></a>Swift错误处理原则</h3><p><em>来源:<a href="https://www.raywenderlich.com/130197/magical-error-handling-swift">Magical Error Handling in Swift</a>，由  <a href="https://www.raywenderlich.com/u/gemmakbarlow">Gemma Barlow</a> 发表于Raywenderliche</em></p>
<ul>
<li>错误类型的命名要清晰无歧义</li>
<li>单个错误尽量用可选类型来处理</li>
<li>当可能出现多种错误时，用自定义的错误类型来处理</li>
<li>不要让抛除的错误传播过远</li>
</ul>
<h3 id="Swift数组指针的妙用"><a href="#Swift数组指针的妙用" class="headerlink" title="Swift数组指针的妙用"></a>Swift数组指针的妙用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = numbers.withUnsafeBufferPointer &#123; buffer -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: buffer.startIndex, to: buffer.endIndex, by: <span class="number">2</span>) &#123;</span><br><span class="line">result += buffer[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;sum&#x27; == 9</span></span><br></pre></td></tr></table></figure>

<h3 id="简写闭包参数名"><a href="#简写闭包参数名" class="headerlink" title="简写闭包参数名"></a>简写闭包参数名</h3><p><em>来源《The Swift Programming Language (SWift 3.0.1)》Closure 一章Shorthand Argument Names 小节</em></p>
<p>Swift 自动为内联闭包提供了依次代表代表参数值的<code>$0</code>,<code>$1</code>,<code>$2</code>等参数简写。</p>
<p>如果您在闭包表达式中使用参数名称简写，您可以在定义闭包时省略其参数列表，相应参数简写的类型会通过函数类型对其进行推断。此外<code>in</code>关键字也可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">reversed = sorted(names, &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$0</code>和<code>$1</code>分别表示闭包中第一个和第二个String类型的参数。</p>
<h3 id="绘制虚线"><a href="#绘制虚线" class="headerlink" title="绘制虚线"></a>绘制虚线</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() &#123;</span><br><span class="line"><span class="type">CGContextSetLineWidth</span>(context, <span class="number">2.0</span>);</span><br><span class="line"><span class="type">CGContextSetStrokeColorWithColor</span>(context, <span class="type">UIColor</span>.greenColor().<span class="type">CGColor</span>);</span><br><span class="line"><span class="type">CGContextBeginPath</span>(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该数组用于指定虚线的重复样式，这里指定绘制10，然后跳过5，依次重复。</span></span><br><span class="line"><span class="keyword">let</span> lengths: [<span class="type">CGFloat</span>] = [<span class="number">10.0</span>, <span class="number">5.0</span>]</span><br><span class="line"><span class="comment">// 第4个参数指定传入的数组包含有几个元素。</span></span><br><span class="line"><span class="type">CGContextSetLineDash</span>(context, <span class="number">0.0</span>, lengths, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">CGContextMoveToPoint</span>(context, <span class="number">0</span>, rect.size.height/<span class="number">2</span>)</span><br><span class="line"><span class="type">CGContextAddLineToPoint</span>(context, rect.width, rect.size.height/<span class="number">2</span>)</span><br><span class="line"><span class="type">CGContextStrokePath</span>(context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>Swift 3.0更新了访问控制，添加了open和fileprivate两个新控制权限，这里摘录了<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3">《The Swift Programming Language (Swift 3)》</a>书中部分内容：</p>
<p>Swift 为代码中的实体提供了5种不同的访问权限。访问权限同时取决于源文件中的实体定义及源文件所属模块。</p>
<ul>
<li>open、public 访问权限定义的实体，在同一模块内可于任意源文件内访问，即使该源文件属于另一个被引入的模块。open 和 public 的区别稍后介绍。</li>
<li>internal 访问权限定义的实体，可以被其定义的模块内的任意源文件访问，模块外的源文件则不能。通常，定义一个 app 或 Framework 的内部结构时，会使用internal权限。</li>
<li>fileprivate 访问权限，限制实体仅能在其定义的源文件内访问。当某个功能仅用于某个源文件时，我们就可以通过添加 fileprivate 来隐藏其具体的实现细节。</li>
<li>private 访问权限定义的实体，仅能在其所定义的作用域内访问。当某个功能仅用于某个声明时，我们就可以通过 private 访问权限，隐藏其具体的实现细节。</li>
</ul>
<p>open是最高访问权限（最少限制），private是最低访问权限（限制最多）。</p>
<p>open访问权限仅适用于类和类成员，它与public访问权限的区别如下：</p>
<ul>
<li>定义为 public，或其它更严格访问权限的类，仅能在其所定义的模块内被继承。</li>
<li>定义为 public，或其它更严格访问权限的类成员，仅能在其所定义的模块内被override(覆盖、重写)。</li>
<li>定义为 open 访问权限的类，既可以在其所定义的模块内被继承，也可以在其它引入其被定义模块的模块中被继承。</li>
<li>定义为 open 访问权限的类成员，既可以在其所定义的模块内override(覆盖、重写)，也可以在其它引入其被定义模块的模块中override(覆盖、重写)。<br>(译者：在a模块中用 open 定义了一个A类，那么A类既可以在a模块中被继承，也可以在任何引入了a模块的b，c…等模块中被继承)</li>
</ul>
<p>将一个类标记为 open 访问权限，即表明你已充分考虑到该类会被其它模块当作父类继承，并为此妥善的编写了该类的代码。</p>
<h3 id="objc-amp-dynamic"><a href="#objc-amp-dynamic" class="headerlink" title="@objc &amp; dynamic"></a>@objc &amp; dynamic</h3><p>关键字，摘录自王巍 <a href="http://swifter.tips/objc-dynamic/">《Swift tips》</a><br>@objc 当 Objective-C 需要引用 Swift 代码，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 @objc 修饰符。<br>@objc 修饰符的另一个作用是为 Objective-C 重新声明方法或者变量的名字<br>@dynamic 当需要用刀某些动态特性时，即可用此关键词，例如KVO。</p>
<h3 id="escaping-amp-noescape"><a href="#escaping-amp-noescape" class="headerlink" title="@escaping &amp; @noescape"></a>@escaping &amp; @noescape</h3><p>摘录自<a href="https://cocoacasts.com/what-do-escaping-and-noescaping-mean-in-swift-3/">《What Do @escaping and @noescape Mean In Swift 3》</a></p>
<p>这里作者介绍的非常详细，且是完整文章，所以不在狗尾续貂。</p>
<h3 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h3><p>当向一个整型常量或变量赋一个超出其所允许范围的数值时，默认情况下，Swift不会生成一个无效的数值，而是报错。该做法为过大或过小数值地操作提供了额外的安全性。</p>
<p>例如，Int16 整型能容纳从 -32768 到 32767 的有符号整型。如果尝试向 Int16 有符号整型的常量或变量赋超过其容纳范围的数值，则会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow = <span class="type">Int16</span>.<span class="built_in">max</span></span><br><span class="line"><span class="comment">// potentialOverflow 被赋值为 Int16 整型所能容纳的最大值 32767。</span></span><br><span class="line">potentialOverflow += <span class="number">1</span></span><br><span class="line"><span class="comment">// 该操作会引发错误</span></span><br></pre></td></tr></table></figure>

<p>在处理过大或过小值时提供相应的错误处理，可以让我们对边界的操作更加灵活。相对于报错，我们可以对数值进行截取。Swift提供了三种溢出运算符来让系统支持整型溢出运算。这些运算符均以 &amp; 开头：</p>
<ul>
<li>溢出加 &amp;+</li>
<li>溢出减 &amp;-</li>
<li>溢出乘 &amp;*</li>
</ul>
<h3 id="特殊的字面量"><a href="#特殊的字面量" class="headerlink" title="特殊的字面量"></a>特殊的字面量</h3><p>在 C 中调试时我们经常会用到 <code>__FILE__</code>，<code>__FUNCTION__</code> 等特殊字面量，来获取一些信息，那么在 Swift 中怎么用呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(#file)&#x2F;&#x2F; 打印当前文件</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">print(#function)&#x2F;&#x2F;打印当前函数</span><br><span class="line">&#125;</span><br><span class="line">hello()</span><br><span class="line"></span><br><span class="line">print(#line)&#x2F;&#x2F;打印当前行号</span><br><span class="line"></span><br><span class="line">print(#column)&#x2F;&#x2F; 打印所处的列，7</span><br></pre></td></tr></table></figure>

<p>通过上面的例子可以看出，Swift 采用 <code>#</code> + 关键字小写的方式，很好的照顾了那些从其它语言转过来的朋友们。</p>
<h3 id="用函数做参数以简化代码"><a href="#用函数做参数以简化代码" class="headerlink" title="用函数做参数以简化代码"></a>用函数做参数以简化代码</h3><p>摘录自：<a href="http://m.weibo.cn/3321824014/4060979186247385">@南峰子_老驴</a></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> setInt: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">Void</span> = <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span></span><br><span class="line"><span class="keyword">let</span> getInt: (<span class="type">String</span>) -&gt; <span class="type">Int</span> = <span class="type">UserDefaults</span>.standard.integer</span><br><span class="line"></span><br><span class="line">setInt(<span class="number">10</span>, <span class="string">&quot;Ten&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(getInt(<span class="string">&quot;Ten&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="包名冲突"><a href="#包名冲突" class="headerlink" title="包名冲突"></a>包名冲突</h3><p>今天在尝试项目中引入“NetworkExtension”的时候，发现编译器提示“File ‘NameOfCrrentFile.Swift is a part of module ‘NetworkExtension’ ; ignoring import”， 后来在苹果<a href="https://forums.developer.apple.com/thread/45186">官方论坛</a>上找到了答案，原来是工程名“NetworkExtension”与要引入的包名冲突了，由于**.swift已经是“NetworkExtension”工程（实际也是一个包）一部分，所以Swift拒绝再在该包中引入一个同名的包。</p>
<p>Swift虽然支持命名空间，但是随即也带来了类似的问题，看来接下来有必要好好了解下Swift的包管理和命名空间问题。</p>
<h3 id="keyPath语法糖"><a href="#keyPath语法糖" class="headerlink" title="#keyPath语法糖"></a>#keyPath语法糖</h3><p>摘录自：<a href="http://m.weibo.cn/3321824014/4060979186247385">@南峰子_老驴</a></p>
<p>在使用KVC或KVO时，经常会犯一些因KeyPath拼写不正确，从而导致应用崩溃的错误。为此，Swift 3中引入了 #keyPath()表达式，不多解释，直接看代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(firstName: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.firstName = firstName</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chris = <span class="type">Person</span>(firstName: <span class="string">&quot;Chris&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyPath = #keyPath(<span class="type">Person</span>.firstName)</span><br><span class="line">chris.value(forKey: keyPath)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Tips</tag>
        <tag>Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Objective-C 中的元类（meta-class）</title>
    <url>/2018/07/31/What-is-a-mate-class-in-Objective-C/</url>
    <content><![CDATA[<p>本文我们将剖析一个在 Objective-C 中比较陌生的概念——元类（meta-class）。Objective-C 中的每个类都有和自己相关联的元类，但你可能从来没有直接使用过它，它始终罩着一层神秘的面纱。为了一探究竟我们首先看看怎么在运时（runtime）创建一个类。然后透过创建的“class pair”（这里的pair做成双理解），我会解释什么是元类，然后探讨它对于 Objective-C 中对象和类的意义。</p>
<a id="more"></a>

<h2 id="在运行时创建一个类"><a href="#在运行时创建一个类" class="headerlink" title="在运行时创建一个类"></a>在运行时创建一个类</h2><p>下面的代码在运行时创建了一个 NSError 的子类，并且给它添加了一个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">&quot;RuntimeErrorSubclass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(newClass, <span class="keyword">@selector</span>(report), (IMP)ReportFunction, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">objc_registerClassPair(newClass);</span><br></pre></td></tr></table></figure>

<p>上面添加的方法，以<code>ReportFunction</code>函数作为它的实现，具体定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ReportFunction(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This object is %p.&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Class is %@, and super is %@.&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Following the isa pointer %d times gives %p&quot;</span>, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;NSObject&#x27;s class is %p&quot;</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;NSObject&#x27;s meta class is %p&quot;</span>, object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表面上看来，这相当简单。在运行时创建一个类只需要简单三步:</p>
<ol>
<li>为”class pair”分配内存 (使用<code>objc_allocateClassPair</code>);</li>
<li>添加所学的方法和变量到类中 (我已经通过 class_addMethod 添加了一个方法);</li>
<li>注册类以便它能使用 (使用<code>objc_registerClassPair</code>)</li>
</ol>
<p>然而，随之而来的问题是：“class pair”是个什么鬼啊？<code>objc_allocateClassPair</code>函数怎么就返回了一个值：the class。不是pair（成对的）吗，说好的另一半呢？</p>
<p>我相信你已经猜到了，另一半就是元类（也就是本文的主题）。为了解释它是什么和我们为什么需要它，还需要交代下 Objective-C 的对象和类的相关背景。</p>
<h2 id="对一个数据结构而言到底怎么才能称之为对象呢？"><a href="#对一个数据结构而言到底怎么才能称之为对象呢？" class="headerlink" title="对一个数据结构而言到底怎么才能称之为对象呢？"></a>对一个数据结构而言到底怎么才能称之为对象呢？</h2><p>每个对象都有类。这是面向对象的基本概念，在Objective-C中，它对数据结构也一样。任何含有一个指向其准确类地址的指针的数据结构，都可以被视作为对象。</p>
<p>在 Objective-C 中，对象的类是<code>isa</code>指针决定的.<code>isa</code>指针指向对象所属的类。</p>
<p>实际上，Objective-C 中对象最基本的定义是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure>

<p>也就是说：任何一个以指向<code>Class</code>结构的指针为开始的结构体都可以被视作<code>objc_object</code>。</p>
<p>Objective-C 中对象最重要的特点就是，你可以发送消息给它们：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="string">@&quot;stringValue&quot;</span> writeToFile:<span class="string">@&quot;/file.txt&quot;</span> atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<p>之所以能发送成功是因为 Objective-C 对象（例如上面的<code>NSCFString</code>）在发送消息时，是因为运行时可以沿着对象的<code>isa</code>指针找到其所属的类（这里是<code>NSCFString</code>类）。该类包含一个可以适用所有该类实例对象的方法列表，和一个指向<code>父类（superclass）</code>的指针。运行时通过检查这个方法类标以及通过指针检查其父类的方法列表，从而找到一个匹配这条消息的方法（在上面的代码里，是<code>NSString</code>类的<code>writeToFile:atomically:encoding:error</code>方法）。之后运行时会调用相应的实现（<code>IMP</code>）。</p>
<p>关键点就在于<code>Class</code>定义了你可以给一个对象发送哪些方法。</p>
<h2 id="什么是元类（meta-class）？"><a href="#什么是元类（meta-class）？" class="headerlink" title="什么是元类（meta-class）？"></a>什么是元类（meta-class）？</h2><p>现在，可能你已经知道了，Objective-C 的一个类也是一个对象。这意味着你可以发送消息给一个类。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSStringEncoding</span> defaultStringEncoding = [<span class="built_in">NSString</span> defaultStringEncoding];</span><br></pre></td></tr></table></figure>

<p>在这个示例里，<code>defaultStringEncoding</code>被发送给了<code>NSString</code>类。</p>
<p>之所以能成功是因为 Objective-C 中每个类本身也是一个对象。如上面所看到的，这意味着类结构也必须以一个isa指针开始，从而可以和<code>objc_object</code>在二进制层面兼容，之后这个结构的下一字段必须是一个指向父类的指针（对于基类则为nil）。</p>
<p>正如我上周展示的，定义一个<code>Class</code>有很多种方式，取决于你的运行时库版本，但有一点，它们都以<code>isa</code>字段开始，并且仅跟着一个<code>superclass</code>字段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="comment">/* followed by runtime specific details... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了调用<code>Class</code>里的方法，该<code>Class</code>的<code>isa</code>指针也必须指向一个包含了该<code>Class</code>方法列表的<code>Class</code>。</p>
<p>这就引出了元类的定义：元类是<code>Class</code>的类。</p>
<p>简单来说就是：</p>
<ul>
<li>当你给对象发送消息时，消息是在寻找这个对象的类的方法列表;</li>
<li>当你给类发消息时，消息是在寻找这个类的元类的方法列表。</li>
</ul>
<p>元类是必不可少的，因为它存储了类的类方法。每个类都必须有独一无二的元类，因为每个类都有独一无二的类方法。</p>
<h2 id="元类的类是什么？"><a href="#元类的类是什么？" class="headerlink" title="元类的类是什么？"></a>元类的类是什么？</h2><p>元类，就像之前的类一样，它也是一个对象。你也可以调用它的方法。自然的，这就意味着他必须也有一个类。</p>
<p>所有的元类都使用根元类（继承体系中处于顶端的类的元类）作为他们的类。这就意味着所有<code>NSObject</code>的子类（大多数类）的元类都会以<code>NSObject</code>的元类作为他们的类</p>
<p>根据这个规则，所有的元类使用根元类作为他们的类，根元类的元类则就是它自己。也就是说基类的元类的isa指针指向他自己。</p>
<h2 id="类和元类的继承"><a href="#类和元类的继承" class="headerlink" title="类和元类的继承"></a>类和元类的继承</h2><p>类用<code>super_class</code>指针指向了父类，同样的，元类用<code>super_class</code>指向类的<code>super_class</code>的元类。</p>
<p>说的更拗口一点就是，根元类把它自己的基类设置成了<code>super_class</code>。</p>
<p>在这样的继承体系下，所有实例、类以及元类都继承自一个基类。</p>
<p>这意味着对于继承于<code>NSObject</code>的所有实例、类和元类，他们可以使用<code>NSObject</code>的所有实例方法，类和元类可以使用NSObject的所有类方法</p>
<p>这些文字看起来莫名其妙难以理解。<a href="http://www.sealiesoftware.com/blog/">Greg Parker</a>给出了一份精彩的<a href="http://www.sealiesoftware.com/blog/class%20diagram.pdf">关系图</a>：</p>
<center>![class diagram](https://dracarys.github.io/images/class_diagram.jpeg)</center>

<h2 id="验证实验"><a href="#验证实验" class="headerlink" title="验证实验"></a>验证实验</h2><p>为了验证，让我们看看我在文章开始写的<code>ReportFunction</code>函数的输出。这个函数的目的是跟随<code>isa</code>指针并打印出它的路途。</p>
<p>为了运行<code>ReportFunction</code>，我们需要创建一个动态实例来创建类调用<code>report</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> instanceOfNewClass = [[newClass alloc] initWithDomain:<span class="string">@&quot;someDomain&quot;</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">[instanceOfNewClass performSelector:<span class="keyword">@selector</span>(report)];</span><br><span class="line">[instanceOfNewClass release];</span><br></pre></td></tr></table></figure>

<p>这里没有声明<code>report</code>方法，但我使用<code>performSelector:</code>调用它，所以编译器不会给出警告。<br>然后<code>ReportFunction</code>函数会沿着isa进行检索，来告诉我们class，meta-class以及meta-class的class是什么样的情况：</p>
<p>得到对象的类：ReportFunction 函数使用object_getClass跟踪isa指针，因为isa指针是类的保护成员（你不能直接接收其他对象的isa指针）。ReportFunction不使用类方法，因为在类对象里调用类方法不能返回元类，它会再次返回这个类（因此[NSString class]会返回NSString 类而不是NSString元类）</p>
<p>这是程序运行时的输出（省略了<code>NSlog</code>前缀）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">This object is 0x10010c810.</span><br><span class="line">Class is RuntimeErrorSubclass, and super is NSError.</span><br><span class="line">Following the isa pointer 1 times gives 0x10010c600</span><br><span class="line">Following the isa pointer 2 times gives 0x10010c630</span><br><span class="line">Following the isa pointer 3 times gives 0x7fff71038480</span><br><span class="line">Following the isa pointer 4 times gives 0x7fff71038480</span><br><span class="line">NSObject&#x27;s class is 0x7fff710384a8</span><br><span class="line">NSObject&#x27;s meta class is 0x7fff71038480</span><br></pre></td></tr></table></figure>

<p>观察<code>isa</code>到达过的地址的值：</p>
<ul>
<li>对象的地址是 <code>0x10010c810</code></li>
<li>类的地址是<code>0x10010c600</code></li>
<li>元类的地址是<code>0x10010c630</code></li>
<li>根元类（<code>NSObject</code>的元类）的地址是<code>0x7fff71038480</code></li>
<li><code>NSObject</code>元类的类是它本身</li>
</ul>
<p>这些地址的值并不重要，重要的是它们说明了文中讨论的从类到元类到<code>NSObject</code>的元类的整个流程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>元类是<code>Class</code>的类。每个<code>Class</code>都有自己独一无二的元类（每个类都有自己独一无二的方法列表）。这意味着所有的类对象都不同。</p>
<p>元类总是会确保类对象和基类的所有实例和类方法。对于从<code>NSObject</code>继承下来的类，这意味着所有的<code>NSObject</code>实例和<code>protocol</code>方法在所有的类（和meta-class）中都可以使用。</p>
<p>所有元类都用基类作为自己的类，对于顶层基类的元类也是如此，只是它指向自己而已。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文翻译自 <a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C</a>， 由 Matt Gallagher 发表于 <a href="https://www.cocoawithlove.com/">cocoawithlove</a>。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Class</tag>
        <tag>Meta-class</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——二叉搜索树</title>
    <url>/2019/01/26/Algorithm-club-binary-search-tree/</url>
    <content><![CDATA[<p>二叉搜索树是一种特殊的<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Binary%20Tree/">二叉树</a>（每个节点最多拥有 2 个子节点），无论插入还是删除，它总是有序的。</p>
<a id="more"></a>

<p>要了更多关于树的知识，<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Tree/">请先阅读这篇</a>。</p>
<h2 id="始终有序性"><a href="#始终有序性" class="headerlink" title="始终有序性"></a>始终有序性</h2><p>下面是一个二叉搜索树的示例:</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Tree1.png" alt="A binary search tree"></p>
<p>注意每个左子节点都比父节点小，每个右子节点都比父节点大。这是一个二叉搜索树的关键特性。</p>
<p>例如, <code>2</code> 小于 <code>7</code>, 所以它在左侧; <code>5</code> 大于 <code>2</code>, 所以它在右侧.</p>
<h2 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h2><p>当执行插入操作时，首先将要插入的值与根节点比较。如果该值较小，就取左分支；如果该值较大，就取右分支。如此沿着树向下比较，直至找到一个空位，将新增值插入。</p>
<p>假设我们要插入数值 <code>9</code>:</p>
<ul>
<li>从树的根开始 (该节点值为 <code>7</code>) 将其与 <code>9</code> 进行比较。</li>
<li><code>9 &gt; 7</code>，所以取右分支，并继续与右子节点 <code>10</code> 进行比较。</li>
<li>由于 <code>9 &lt; 10</code>, 取左分支.</li>
<li>现在已抵达无值可比的空位，所以将新节点 <code>9</code> 插入该位置。</li>
</ul>
<p>下面是插入 <code>9</code> 以后的树：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Tree2.png" alt="After adding 9"></p>
<p>树中有且仅有一个位置可以插入该值。查找这个位置同行很快。时间杂度是 <strong>O(h)**，其中 **h</strong> 代表树的高度。</p>
<blockquote>
<p><strong>注意：</strong> 节点的<strong>高度</strong>是指从该节点到其最底层叶子节点的跳数。整个树的高度是指从根节点到最底层叶子节点到跳数。二叉搜索树的很多操作都通过树的高度来表示。</p>
</blockquote>
<p>小值居左，大值居右，记住这个简单的规则，就可以让树始终保持有序，所以任何时候查询，都可以判断某个值是否包含在树中。</p>
<h2 id="树的搜索"><a href="#树的搜索" class="headerlink" title="树的搜索"></a>树的搜索</h2><p>在树中搜索某个值，与插入操作步骤相同：</p>
<ul>
<li>如果该值小于当前节点，取左分支。</li>
<li>如果该值大于当前节点，取右分支.</li>
<li>如果该值等于当前节点，找到了!</li>
</ul>
<p>与大多数树操作类似，这也递归操作，直至找到或者遍历完所有节点。</p>
<p>下面是一个搜索 <code>5</code> 的例子:</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Searching.png" alt="Searching the tree"></p>
<p>通过树结构进行搜索非常快捷。耗时仅 **O(h)**。那怕你有一百万个节点，只要平衡性够好，也只需要 20 步便可找到。（思路非常类似数组中的<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Binary%20Search">二分搜索算法（binary search）</a>）</p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>有时需要查看所有节点，而不是某一个。</p>
<p>遍历一个二叉树主要有三种方法:</p>
<ol>
<li><em>中序遍历（In-order）</em> (或者 <em>深度优先遍历（depth-first）</em>)：先查左子节点，在查父节点，最后查右子节点。</li>
<li><em>前序遍历（Pre-order）</em>：先查父节点，在查左、右子节点。</li>
<li><em>后序遍历（Post-order）</em>：先查左、右子节点，在查父节点。</li>
</ol>
<p>树的遍历也是递归进行的。</p>
<p>如果以中序遍历一个二叉搜索树，那么所有节点就像是从小到大排列一样。例如下图，将依次打印 <code>1, 2, 5, 7, 9, 10</code>：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Traversing.png" alt="Traversing the tree"></p>
<h2 id="节点的移除"><a href="#节点的移除" class="headerlink" title="节点的移除"></a>节点的移除</h2><p>移除节点非常简单。移除后，需要用其左分支上最大的子节点或右分支上最小的子节点填充其位置。如此就能在移除后依然保持有序性。例如下图，移除 10 后需要用 9（图2） 或者 11（图3） 填充其位置。</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/DeleteTwoChildren.png" alt="Deleting a node with two children"></p>
<p>注意，只有被移除的节点有子节点时才需要替换填充。否则直接断开其与父节点的连接即可：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/DeleteLeaf.png" alt="Deleting a leaf node"></p>
<h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案 1"></a>实现方案 1</h2><p>理论差不多了，接下来我们看看怎么通过 Swift 实现一个二叉搜索树。有两种方案可以实现。首先，展示一个类（class）实现的版本，之后在展示如何通过枚举（enum）来实现。</p>
<p>下面是一个 <code>BinarySearchTree</code> 的类实现:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">  <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> parent: <span class="type">BinarySearchTree?</span></span><br><span class="line">  <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">BinarySearchTree?</span></span><br><span class="line">  <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">BinarySearchTree?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isRoot: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parent == <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isLeaf: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span> == <span class="literal">nil</span> &amp;&amp; <span class="keyword">right</span> == <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isLeftChild: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parent?.<span class="keyword">left</span> === <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isRightChild: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parent?.<span class="keyword">right</span> === <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> hasLeftChild: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span> != <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> hasRightChild: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">right</span> != <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> hasAnyChild: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasLeftChild || hasRightChild</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> hasBothChildren: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hasLeftChild &amp;&amp; hasRightChild</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">left</span>?.<span class="built_in">count</span> ?? <span class="number">0</span>) + <span class="number">1</span> + (<span class="keyword">right</span>?.<span class="built_in">count</span> ?? <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类仅描述了一个节点而不是整个树。类型是泛型，所以节点可以存储任何类型的数据。此外它还有对其 <code>left</code> 、<code>right</code> 以及 <code>parent</code> 节点的引用。</p>
<p>用法如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt;(value: <span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p><code>count</code> 属性用来统计某个节点的子树中拥有多少个节点。它不仅仅统计它的子节点，还统计它子节点的子子孙孙。如果该节点恰好是根节点，那么它统计的就是整个树的节点数。初始，<code>count = 0</code>。</p>
<blockquote>
<p><strong>注意：</strong> 由于 <code>left</code>, <code>right</code>, 和 <code>parent</code> 均是可选类型，所有可以充分利用 Swift 的可选链（<code>?</code>）和空合运算符（<code>??</code>）。当然也可以用 <code>if let</code>，但这样不够简洁。</p>
</blockquote>
<h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>单个树节点自身是无意义的，可以通过下面的方法想树中插入新节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> value &lt; <span class="keyword">self</span>.value &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">left</span> &#123;</span><br><span class="line">      <span class="keyword">left</span>.insert(value: value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">left</span> = <span class="type">BinarySearchTree</span>(value: value)</span><br><span class="line">      <span class="keyword">left</span>?.parent = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">      <span class="keyword">right</span>.insert(value: value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">right</span> = <span class="type">BinarySearchTree</span>(value: value)</span><br><span class="line">      <span class="keyword">right</span>?.parent = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其它树操作类似，插入是最容易通过递归实现的。通过与已有节点的比较，来确定是将它添加到左分支还是右分支。</p>
<p>如果没有左或右子节点，那么就创建一个 <code>BinarySearchTree</code> 对象作为新节点，然后通过设置 <code>parent</code> 属性，将它连接到树中。</p>
<blockquote>
<p><strong>注意：</strong> 由于二叉搜索树的关键就在与左小，右大，所以始终要从根开始执行插入，以保证在操作完毕后仍是一个有效的二叉搜索树！</p>
</blockquote>
<p>构建一个完整的树:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt;(value: <span class="number">7</span>)</span><br><span class="line">tree.insert(<span class="number">2</span>)</span><br><span class="line">tree.insert(<span class="number">5</span>)</span><br><span class="line">tree.insert(<span class="number">10</span>)</span><br><span class="line">tree.insert(<span class="number">9</span>)</span><br><span class="line">tree.insert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 为了之后的深入了解，插入的数应尽量随机。如果有序的插入，那么最终树的形可能就不对了。（译者：尽量保持树的平衡性）</p>
</blockquote>
<p>为了方便操作，这里增加一个初始化方法，这样就可以通过 <code>insert()</code> 将数组中所有元素插入（到树中）了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(array: [<span class="type">T</span>]) &#123;</span><br><span class="line">  <span class="built_in">precondition</span>(array.<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">self</span>.<span class="keyword">init</span>(value: array.first!)</span><br><span class="line">  <span class="keyword">for</span> v <span class="keyword">in</span> array.<span class="built_in">dropFirst</span>() &#123;</span><br><span class="line">    insert(value: v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以这样创建一棵树了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt;(array: [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>数组中的首元素即为树的根。</p>
<h3 id="Debug信息输出"><a href="#Debug信息输出" class="headerlink" title="Debug信息输出"></a>Debug信息输出</h3><p>处理复杂数据结构时，输出可读性强的 debug 信息大有助益。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinarySearchTree</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">left</span> &#123;</span><br><span class="line">      s += <span class="string">&quot;(\(left.description)) &lt;- &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    s += <span class="string">&quot;\(value)&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">      s += <span class="string">&quot; -&gt; (\(right.description))&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>print(tree)</code> 时, 会看到如下信息:</p>
<pre><code>((1) &lt;- 2 -&gt; (5)) &lt;- 7 -&gt; ((9) &lt;- 10)</code></pre>
<p>根节点在中间。想象一下，是不是正好与下面的树相对应：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Tree2.png" alt="The tree"></p>
<p>你可能会想如果插入相同的元素会如何呢？我们这里总是会将它插入右分支。尝试一下。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>树中已经有值了，那么接下来我们做点什么呢？当然是查询！快速查询对象是二叉搜索树的一个主要应用。:-)</p>
<p>下面是 <code>search()</code> 的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(value: T)</span></span> -&gt; <span class="type">BinarySearchTree?</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> value &lt; <span class="keyword">self</span>.value &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>?.search(value: value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="keyword">self</span>.value &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">right</span>?.search(value: value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>  <span class="comment">// found it!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很简单：首先从当前节点开始（通常是根节点）进行比较。如果目标值小于当前节点的值，在左分支继续查询；如果大于，就在右分支继续。</p>
<p>如果已经没有节点可查了——即 <code>left</code> 或 <code>right</code> 为空——我们就返回 <code>nil</code>，表示查询的值在树中不存在。</p>
<blockquote>
<p><strong>注意：</strong> 在 Swift 中，使用可选链非常便捷；如果 <code>left</code> 为空， <code>left?.search(value)</code> 会自动返空。完全不需要通过 <code>if</code> 表示去判断。</p>
</blockquote>
<p>搜索是一个递归过程，但你也可以通过简单循环来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(<span class="keyword">_</span> value: T)</span></span> -&gt; <span class="type">BinarySearchTree?</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> node: <span class="type">BinarySearchTree?</span> = <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> n = node &#123;</span><br><span class="line">    <span class="keyword">if</span> value &lt; n.value &#123;</span><br><span class="line">      node = n.<span class="keyword">left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; n.value &#123;</span><br><span class="line">      node = n.<span class="keyword">right</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保你已经理解这两种实现是等价的，依自己喜欢选用。但就我个人而言，相对于递归更倾向于迭代。;-)</p>
<p>下面是对搜索的测试:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.search(<span class="number">5</span>)</span><br><span class="line">tree.search(<span class="number">2</span>)</span><br><span class="line">tree.search(<span class="number">7</span>)</span><br><span class="line">tree.search(<span class="number">6</span>)   <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>前三行都会返回了相应的 <code>BinaryTreeNode</code> 对象。最后一行返回了 <code>nil</code>，因为没有节点包涵 <code>6</code>。</p>
<blockquote>
<p><strong>注意：</strong> 如果树中存在多个相同的对象，那么 <code>search()</code> 会返回 “最高的” 那个节点。之所以如此，是因为我们总是从根开始向下查找。</p>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>还记得遍历树中所有节点的 3 种方法吗？如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traverseInOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">left</span>?.traverseInOrder(process: process)</span><br><span class="line">  process(value)</span><br><span class="line">  <span class="keyword">right</span>?.traverseInOrder(process: process)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traversePreOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  process(value)</span><br><span class="line">  <span class="keyword">left</span>?.traversePreOrder(process: process)</span><br><span class="line">  <span class="keyword">right</span>?.traversePreOrder(process: process)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">traversePostOrder</span><span class="params">(process: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">left</span>?.traversePostOrder(process: process)</span><br><span class="line">  <span class="keyword">right</span>?.traversePostOrder(process: process)</span><br><span class="line">  process(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都能遍历，只是顺序不同。注意全部都是递归的。当没有左右子节点时，Swift 的可选链使对 <code>traverseInOrder()</code> 等的调用非常简洁明了。</p>
<p>按从小到大的顺序打印树中所有值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.traverseInOrder &#123; value <span class="keyword">in</span> <span class="built_in">print</span>(value) &#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下:</p>
<pre><code>1
2
5
7
9
10</code></pre>
<p>你还可以给树添加 <code>map()</code> 和 <code>filter()</code> 方法。 例如，下面是一个 map 方法的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span><span class="params">(formula: <span class="params">(T)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> a = [<span class="type">T</span>]()</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">left</span> &#123; a += <span class="keyword">left</span>.<span class="built_in">map</span>(formula: formula) &#125;</span><br><span class="line">  a.append(formula(value))</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123; a += <span class="keyword">right</span>.<span class="built_in">map</span>(formula: formula) &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map()</code> 方法通过对树进行中序遍历，将 <code>formula</code> 闭包应用到树中的每个节点上，并将结果存放于一个数组中进行返回。</p>
<p>一个非常简单的 <code>map()</code> 应用例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">toArray</span><span class="params">()</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">map</span> &#123; $<span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将树中内容反转成一个有序的数组。在 playground 中尝试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.toArray()   <span class="comment">// [1, 2, 5, 7, 9, 10]</span></span><br></pre></td></tr></table></figure>

<p>作为练习，你自己可以尝试实现一个 filter 和 reduce。</p>
<h3 id="批量移除"><a href="#批量移除" class="headerlink" title="批量移除"></a>批量移除</h3><p>通过定义一些辅助方法，可以让代码（逻辑）更加清晰。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">reconnectParentTo</span><span class="params">(node: BinarySearchTree?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> parent = parent &#123;</span><br><span class="line">    <span class="keyword">if</span> isLeftChild &#123;</span><br><span class="line">      parent.<span class="keyword">left</span> = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.<span class="keyword">right</span> = node</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  node?.parent = parent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要修改一颗树需要修改大量的 <code>parent</code> 、 <code>left</code> 以及 <code>right</code> 引用。该方法正是为了解决这个问题。首先取得当前节点 <code>self</code> 的父节点，之后在把另一个节点连接为自己即 <code>self</code> 的子节点。</p>
<p>此外是需要一个方法用来返回最小和最大的节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">minimum</span><span class="params">()</span></span> -&gt; <span class="type">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> next = node.<span class="keyword">left</span> &#123;</span><br><span class="line">    node = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">maximum</span><span class="params">()</span></span> -&gt; <span class="type">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> next = node.<span class="keyword">right</span> &#123;</span><br><span class="line">    node = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>余下的代码可读性很强，不在过多说明:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">()</span></span> -&gt; <span class="type">BinarySearchTree?</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> replacement: <span class="type">BinarySearchTree?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replacement for current node can be either biggest one on the left or</span></span><br><span class="line">  <span class="comment">// smallest one on the right, whichever is not nil</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">    replacement = <span class="keyword">right</span>.minimum()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">left</span> &#123;</span><br><span class="line">    replacement = <span class="keyword">left</span>.maximum()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    replacement = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replacement?.remove()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Place the replacement on current node&#x27;s position</span></span><br><span class="line">  replacement?.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">  replacement?.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">  <span class="keyword">right</span>?.parent = replacement</span><br><span class="line">  <span class="keyword">left</span>?.parent = replacement</span><br><span class="line">  reconnectParentTo(node:replacement)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The current node is no longer part of the tree, so clean it up.</span></span><br><span class="line">  parent = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">left</span> = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">right</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> replacement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度和高度"><a href="#深度和高度" class="headerlink" title="深度和高度"></a>深度和高度</h3><p>回想下节点的高度，即到其最底端叶子节点到距离。可以通过下面的方法计算得到：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> isLeaf &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="keyword">left</span>?.height() ?? <span class="number">0</span>, <span class="keyword">right</span>?.height() ?? <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询左右分支的高度，返回最高的那个。同样是一个递归过程。由于需要遍历该节点的所有的子节点，所以时间杂度是 **O(n)**。</p>
<blockquote>
<p><strong>注意：</strong> 这里使用 Swift 的空合运算符来处理 <code>left</code> 或 <code>right</code> 为空的情况。虽然用 <code>if let</code> 也不错，但是这样相对更简洁。</p>
</blockquote>
<p>尝试一下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.height()  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>还可以计算节点的 <em>深度（depth）</em>，即与根节点的距离。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">var</span> edges = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> parent = node.parent &#123;</span><br><span class="line">    node = parent</span><br><span class="line">    edges += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> edges</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>parent</code> 应用向上（统计），直至根节点（它的 <code>parent</code> 为空）。这一操作的时间杂度是 **O(h)**。例如如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> node9 = tree.search(<span class="number">9</span>) &#123;</span><br><span class="line">  node9.depth()   <span class="comment">// returns 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前驱和后继（Predecessor-and-successor）"><a href="#前驱和后继（Predecessor-and-successor）" class="headerlink" title="前驱和后继（Predecessor and successor）"></a>前驱和后继（Predecessor and successor）</h3><p>虽然二叉搜索树总是“有序的”，但这并不意味着顺序相连的数值在树中的位置也是相邻。</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Binary%20Search%20Tree/Images/Tree2.png" alt="Example"></p>
<p>注意，在查看左子节点之前，是没办法得到刚好小于 <code>7</code> 的那个数值的。它的左子节点是 <code>2</code>, 而不是刚好小于它的 <code>5</code>。</p>
<p><code>predecessor()</code> 会返回那个在整个序列中正在位于当前值之前的那个节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">predecessor</span><span class="params">()</span></span> -&gt; <span class="type">BinarySearchTree</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">left</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.maximum()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> parent = node.parent &#123;</span><br><span class="line">      <span class="keyword">if</span> parent.value &lt; value &#123; <span class="keyword">return</span> parent &#125;</span><br><span class="line">      node = parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有左子树，那就简单。此时左子树的最大值就是（该节点的）前驱。通过前面的图例可以得知这一点， <code>5</code> 恰好是 <code>7</code> 的左分支上的做大值。</p>
<p>如果没有左子树，那就必须查找父节点，直到找到那个最小值。例如查找节点 <code>9</code>的前驱，持续向上查找，直至那个最先具有较小值的父节点，<code>7</code>。</p>
<p><code>successor()</code> 与之相似，只不过是镜像相反的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">successor</span><span class="params">()</span></span> -&gt; <span class="type">BinarySearchTree</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">right</span>.minimum()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">self</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> parent = node.parent &#123;</span><br><span class="line">      <span class="keyword">if</span> parent.value &gt; value &#123; <span class="keyword">return</span> parent &#125;</span><br><span class="line">      node = parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法的时间杂度都是 **O(h)**。</p>
<blockquote>
<p><strong>Note:</strong> There is a variation called a <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Threaded%20Binary%20Tree">“threaded” binary tree</a> where “unused” left and right pointers are repurposed to make direct links between predecessor and successor nodes. Very clever!（译者：待复习完线索二叉树之后在翻译此段内容）</p>
</blockquote>
<h3 id="二叉搜索树的有效性"><a href="#二叉搜索树的有效性" class="headerlink" title="二叉搜索树的有效性"></a>二叉搜索树的有效性</h3><p>要破坏二叉搜索树，可以通过对一个非根节点调用 <code>insert()</code> 以使其变为一个无效树。示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> node1 = tree.search(<span class="number">1</span>) &#123;</span><br><span class="line">  node1.insert(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根节点是 <code>7</code>，所以 <code>100</code> 必须被插入到树的右分支上。然而你却没有从根节点开始，反而是从树的左分支上的叶子开始插入。因此，<code>100</code> 被插入到了错误的位置！</p>
<p>进而导致 <code>tree.search(100)</code> 返回空值。</p>
<p>可以通过下的方法来检查一个树是不是一个有效的二叉搜索树：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">isBST</span><span class="params">(minValue minValue: T, maxValue: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> value &lt; minValue || value &gt; maxValue &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> leftBST = <span class="keyword">left</span>?.isBST(minValue: minValue, maxValue: value) ?? <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> rightBST = <span class="keyword">right</span>?.isBST(minValue: value, maxValue: maxValue) ?? <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> leftBST &amp;&amp; rightBST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查左分支的值是否小于当前节点的值，并且右分支的值大于当前值。</p>
<p>调用方法如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> node1 = tree.search(<span class="number">1</span>) &#123;</span><br><span class="line">  tree.isBST(minValue: <span class="type">Int</span>.<span class="built_in">min</span>, maxValue: <span class="type">Int</span>.<span class="built_in">max</span>)  <span class="comment">// true</span></span><br><span class="line">  node1.insert(<span class="number">100</span>)                                 <span class="comment">// EVIL!!!</span></span><br><span class="line">  tree.search(<span class="number">100</span>)                                  <span class="comment">// nil</span></span><br><span class="line">  tree.isBST(minValue: <span class="type">Int</span>.<span class="built_in">min</span>, maxValue: <span class="type">Int</span>.<span class="built_in">max</span>)  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案 2"></a>实现方案 2</h2><p>除了类可以实现二叉搜索树，枚举也是可以的。</p>
<p>区别就在于引用语义与值语义。基于类实现的树，一旦类被修改，那么内存中的相同实例都会被修改，而基于枚举的树是不可变的 —— 任何插入或删除都会给你一个基于原树的全新拷贝。至于那种方式更好，则完全取决于你的应用场景。</p>
<p>下面是一个枚举实现的二叉搜索树：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">T</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Leaf</span>(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">BinarySearchTree</span>, <span class="type">T</span>, <span class="type">BinarySearchTree</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该枚举有三个 cases：</p>
<ul>
<li><code>Empty</code> 表示分支末端 (基于类实现的版本中用 <code>nil</code> 引用表示).</li>
<li><code>Leaf</code> 表示没有子节点的叶子节点。</li>
<li><code>Node</code> 表示拥有一个或两个子节点的节点。此处用 <code>indirect</code> 修饰，以便其可以持有 <code>BinarySearchTree</code> 类型的值，否则不是递归枚举。</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 这样的二叉树是没有指向父节点的引用的。这不是什么大问题，只是某些操作实现起来更麻烦一些。</p>
</blockquote>
<p>这里通过递归实现，并且枚举的每种 case 都必须区别对待。例如，下面展示了如果统计节点数以及数的高度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Empty</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Leaf</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, <span class="keyword">_</span>, <span class="keyword">right</span>): <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">count</span> + <span class="number">1</span> + <span class="keyword">right</span>.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Empty</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Leaf</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, <span class="keyword">_</span>, <span class="keyword">right</span>): <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="keyword">left</span>.height, <span class="keyword">right</span>.height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入新节点:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(newValue: T)</span></span> -&gt; <span class="type">BinarySearchTree</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Empty</span>:</span><br><span class="line">    <span class="keyword">return</span> .<span class="type">Leaf</span>(newValue)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Leaf</span>(<span class="keyword">let</span> value):</span><br><span class="line">    <span class="keyword">if</span> newValue &lt; value &#123;</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">Node</span>(.<span class="type">Leaf</span>(newValue), value, .<span class="type">Empty</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">Node</span>(.<span class="type">Empty</span>, value, .<span class="type">Leaf</span>(newValue))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Node</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> value, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">if</span> newValue &lt; value &#123;</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">Node</span>(<span class="keyword">left</span>.insert(newValue), value, <span class="keyword">right</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> .<span class="type">Node</span>(<span class="keyword">left</span>, value, <span class="keyword">right</span>.insert(newValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 playground 中尝试一下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="type">BinarySearchTree</span>.<span class="type">Leaf</span>(<span class="number">7</span>)</span><br><span class="line">tree = tree.insert(<span class="number">2</span>)</span><br><span class="line">tree = tree.insert(<span class="number">5</span>)</span><br><span class="line">tree = tree.insert(<span class="number">10</span>)</span><br><span class="line">tree = tree.insert(<span class="number">9</span>)</span><br><span class="line">tree = tree.insert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>注意，每次的插入操作都会得到一个新的树对象，所以需要将结果重新赋给 <code>tree</code> 变量。</p>
<p>下面是搜索方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(x: T)</span></span> -&gt; <span class="type">BinarySearchTree?</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Empty</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> .<span class="type">Leaf</span>(<span class="keyword">let</span> y):</span><br><span class="line">    <span class="keyword">return</span> (x == y) ? <span class="keyword">self</span> : <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, y, <span class="keyword">right</span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">left</span>.search(x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> y &lt; x &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">right</span>.search(x)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数的方法都有相同的结构。</p>
<p>在 playground 中尝试一下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tree.search(<span class="number">10</span>)</span><br><span class="line">tree.search(<span class="number">1</span>)</span><br><span class="line">tree.search(<span class="number">11</span>)   <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>要 debug 打印整个树，可以使用下面的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinarySearchTree</span>: <span class="title">CustomDebugStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Empty</span>: <span class="keyword">return</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Leaf</span>(<span class="keyword">let</span> value): <span class="keyword">return</span> <span class="string">&quot;\(value)&quot;</span></span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Node</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> value, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;(\(left.debugDescription) &lt;- \(value) -&gt; \(right.debugDescription))&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>print(tree)</code> 的结果如下:</p>
<pre><code>((1 &lt;- 2 -&gt; 5) &lt;- 7 -&gt; (9 &lt;- 10 -&gt; .))</code></pre>
<p>中间是根节点，点表示已经没有子节点。</p>
<h2 id="当树变的不在平衡"><a href="#当树变的不在平衡" class="headerlink" title="当树变的不在平衡"></a>当树变的不在平衡</h2><p>当二叉树的左右子树拥有相同数量的节点时，那么它是 <em>平衡的（balanced）</em>。此时树的高度是 <em>log(n)<em>，</em>n</em> 表示节点数。这是理想状态。</p>
<p>一旦一个分支显著的比另一个更长，搜索就会变的非常慢。不必要的检索大大增加。最坏的情况是，树的高度变为 <em>n</em>。此时树相对于二叉搜索树来说更像是一个<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Linked%20List/">链表（linked list）</a>，时间杂度也将退化到 **O(n)**。</p>
<p>保持二叉搜索树平衡性的一个方法就是以完全随机的顺序插入新节点。总体上可以很好的保证树的平衡性，但这是没法保证的，也不实际。</p>
<p>另一个办法就是使用 <em>自平衡（self-balancing)</em> 二叉树。这种数据结构会在插入或删除节点后进行自适应，以保证树的平衡性。欲了解更多，请参见<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/AVL%20Tree">平衡树（AVL tree）</a>和<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Red-Black%20Tree">红黑树（red-black tree）</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定基础的同学进行回顾，如果你才接触，那么建议移步阅读详细<a href="https://www.raywenderlich.com/139821/swift-algorithm-club-swift-binary-search-tree-data-structure">教程</a></p>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree on Wikipedia</a></p>
<p><em>由 <a href="http://www.github.com/nameghino">Nicolas Ameghino</a> 和 Matthijs Hollemans 联合发表于 Swift 算法社区</em></p>
<p><em>由 William Han 翻译</em> </p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——堆</title>
    <url>/2019/03/02/Algorithm-club-heap/</url>
    <content><![CDATA[<p>堆实际上是一个内部元素以<a href="https://dracarys.github.io/2019/01/26/Algorithm-club-binary-tree/">二叉树（binary tree）</a>形式存储的数组（译者：必须是完全二叉树），且无需父/子（节点）指针。堆是基于堆属性（heap property）存储的，堆属性决定了其子节点在树中的排序。（译者：堆属性也称为堆特征主要是指堆内元素的排序方式）</p>
<a id="more"></a>

<p>堆的常用场景：</p>
<ul>
<li>构建 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Priority%20Queue/">优先级队列（priority queues）</a>。</li>
<li>提供 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Heap%20Sort/">堆排序（heap sorts）</a>。</li>
<li>快速查找集合中最小（或最大）元素。</li>
<li>装X。</li>
</ul>
<h2 id="堆属性（The-heap-property）"><a href="#堆属性（The-heap-property）" class="headerlink" title="堆属性（The heap property）"></a>堆属性（The heap property）</h2><p>有两种堆：<em>大序堆</em> 和 <em>小序堆</em>，他们之间最大的区别就在于子节点在树中的排序不同。（译者：也有译为大顶堆和小顶堆，最大堆和最小堆的。这里将 <em>max-heap</em> 和 <em>min-heap</em> 译为大序堆和小序堆，是为了突出他们最大的区别——排序）</p>
<p>在大序堆中，父节点的值要比其所有字节点的值都大。在小序堆中，每个父节点的值都要小于其子节点的值。这被称为“堆属性”，并且它适用于树中的每个节点。</p>
<p>例如：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Heap1.png" alt="A max-heap"></p>
<p>这是一个大序堆，每个父节点都比其所有的子节点大。<code>(10)</code> 大于 <code>(7)</code> 和 <code>(2)</code>. <code>(7)</code> 大于 <code>(5)</code> 和 <code>(1)</code>。</p>
<p>受限于堆属性，大序堆总是将最大的对象作为树的根。反之，小序堆总是将最小的对象作为其树的根。正是因为堆有这样的属性，所以通常用它来实现<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Priority%20Queue/">优先队列（priority queue）</a> ，以便更快捷的获取那个“最重要”的对象。</p>
<blockquote>
<p><strong>注意:</strong> 堆的根不是最大就是最小值，但是后续的其它元素顺序是无法保证的。例如，大序堆中索引为 0 的元素一定是最大的，但这并不意味着最后一个索引位元素就是最小的。只能保证最小值在其叶子节点中，但无法确定是哪一个。</p>
</blockquote>
<h2 id="堆与其它常见树有什么不同"><a href="#堆与其它常见树有什么不同" class="headerlink" title="堆与其它常见树有什么不同"></a>堆与其它常见树有什么不同</h2><p>堆不能取代二叉搜索树，他们之间既有相似也有不同。下面是它们之间的主要区别：</p>
<p><strong>节点顺序</strong> 在<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Binary%20Search%20Tree/">二叉搜索树（binary search tree——BST）</a>中，左侧的子节点必须小于父节点，而右侧的子节点则必须大于父节点。而堆无此要求。大序堆中两个子节点都必须小于父节点，而小序堆则必须都大于父节点。</p>
<p><strong>内存占用</strong> 传统树所耗内存比其实际存储数据要大一些。你需要开辟外的存储空间以存储节点对象和指向左右子节点的指针。堆则使用普通的数组作为存储结构，且不需要（额外的）指针。</p>
<p><strong>平衡性</strong> 二叉搜索树必须是“平衡”的，这样大多数操作才具有 <strong>O(log n)</strong> 的时间杂度。因此你必须以完全随机的方式插入或删除数据，否则就要用<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/AVL%20Tree/">平衡树（AVL tree）</a> 或 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Red-Black%20Tree/">红黑树（red-black tree）</a>（以保持其平衡性）。而堆不需要整棵树都是有序的，只要堆属性完备即可，因此不存在平衡性的问题。堆 <strong>O(log n)</strong> 的时间杂度是有堆自身树觉结构决定的。</p>
<p><strong>查询</strong> 二叉树的搜索很快，堆较慢。相对于在堆前端添加最大（或最小）值，以及允许快速插入和删除等特性，查询的优先级则不那么高。</p>
<h2 id="数组中的树"><a href="#数组中的树" class="headerlink" title="数组中的树"></a>数组中的树</h2><p>用数组去实现一个树形结构，虽然听上去是有点奇怪，但是在时间和空间上都非常高效。</p>
<p>前面的例子如果用树来存储，形式如下：</p>
<pre><code>[ 10, 7, 2, 5, 1 ]</code></pre>
<p>这就是全部了，完全不需要比数组更多的存储空间。</p>
<p>既然没有额外指针，怎么确定哪个是子节点，那个父节点呢？好问题！（实际上）树中各节点在数组中的索引顺序已经定义好了其间的父子关系。</p>
<p>假定 <code>i</code> 是某节点的索引，那么通过下面的公式就可以求得相应父节点和子节点的索引：</p>
<pre><code>parent(i) = floor((i - 1)/2)
left(i)   = 2i + 1
right(i)  = 2i + 2</code></pre>
<p>注意， <code>right(i)</code> 仅仅是 <code>left(i) + 1</code>。因为左右节点总是相邻存储在一起。</p>
<p>将数组的相应索引带入上面的公式，就可以得到父节点和子节点对应的位置：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>数组索引 (<code>i</code>)</th>
<th>父索引</th>
<th>左子节点</th>
<th>右子节点</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>1</td>
<td>7</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>1</td>
<td>9</td>
<td>10</td>
</tr>
</tbody></table>
<p>检查一下，确认数组索引与图中所示的树是不是一一对应的。</p>
<blockquote>
<p><strong>注意：</strong> 根节点 <code>(10)</code> 没有父节点，因为 <code>-1</code> 不是一个有效的数组索引。同理， 节点 <code>(2)</code>, <code>(5)</code> 和 <code>(1)</code> 也不存在子节点，因为它们的数组索引越界了，由此可见，在使用前，务必要先确认索引的有效性。</p>
</blockquote>
<p>回想一下大序堆，父节点的值必须使用大于（或等于）子节点的值。也就是说下面的（表达式）对数组中的所有索引 <code>i</code> 都必须为 true：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">array[parent(i)] &gt;= array[i]</span><br></pre></td></tr></table></figure>

<p>确认一下，例子中给出的堆是否保持了该堆属性。</p>
<p>可见，该方程可以使我们不通过指针也能找到相应的父节点或子节点的索引。相比指针（的方式）复杂一些，但权衡利弊：虽增加了计算量，但也节约了内存空间。幸运地是，该计算方式够快，且时间复杂度为 <strong>O(1)</strong> 。</p>
<p>理解数组中索引与树中节点位置的映射关系非常重要。（例如）下面是一棵分为 4 层含有 15 个节点的树：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/LargeHeap.png" alt="Large heap"></p>
<p>图中的数字并不是节点的值，而是（节点）对应在数组中的索引。下面给出了数组索引与树不同层级之间的对应（关系）：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Array.png" alt="The heap array"></p>
<p>要想公式有效，数组中的父节点必须位于子节点之前。可以上之前的图中印证（这一点）。</p>
<p>注意这种方式是有限制的。（例如）下图就必须用常规的二叉树，而不能用堆：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/RegularTree.png" alt="Impossible with a heap"></p>
<p>在当前最底层的节点被占满之前，是不可以生成新的一层的，所以堆的形状始终是下面这样：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/HeapShape.png" alt="The shape of a heap"></p>
<blockquote>
<p><strong>注意：</strong> 你<em>可以</em>用堆的形式去遍历一个普通二叉树，只是这样不仅浪费空间，而且还需要把数组中空值标记出来。（译者：因为普通的二叉树的一层未必是满的）</p>
</blockquote>
<p>突击测验！假设我们有下面这样一个数组：</p>
<pre><code>[ 10, 14, 25, 33, 81, 82, 99 ]</code></pre>
<p>它是一个有效的堆吗？是的！一个从小到大的有序数组就是一个有效的小序堆。可以向下面这样把它画出来：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/SortedArray.png" alt="A sorted array is a valid heap"></p>
<p>由于父节点总是小于它对子节点，因此堆属性得以维系。(自己确认下，一个从大到小的的有序数组是不是一个有序的大序堆)</p>
<blockquote>
<p><strong>注意：</strong> 不是所有的小序堆都是一个有序的数组！它是不可逆的。要想把堆变为有序数组，需要借助<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Heap%20Sort/">堆排（heap sort）</a></p>
</blockquote>
<h2 id="更多的数学"><a href="#更多的数学" class="headerlink" title="更多的数学"></a>更多的数学</h2><p>如果你很好奇，那么这里还有一些公式可以更好的表现堆的属性（特征）。你不需要理解的很透彻，但它有时却真的可以派上用场。该小节可以跳过。(译者：翻译不够好，有待更新，原文暂时保留)<br>In case you are curious, here are a few more formulas that describe certain properties of a heap. You do not need to know these by heart, but they come in handy sometimes. Feel free to skip this section!</p>
<p>树的<em>高度</em>定义了从根部到最底部的叶子节点所需的跳数，或者更公式化一点说：高度就是节点间的最大边数。<em>h</em> 高度 <em>h</em> 的堆拥有 <em>h+1</em> 层。</p>
<p>下面的堆高度是 3， 所以他有 4 层：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/LargeHeap.png" alt="Large heap"></p>
<p>一个包涵 <em>n</em> 个节点的堆，其高度是 *h = floor(log2(n))*。之所以如此，是因为在添加新层之前，总是先把上一层级的节点添满。例子中有15个节点，所以它的高度是 <code>floor(log2(15)) = floor(3.91) = 3</code>。</p>
<p>如果最底层已经填满，那么这一层包涵 <em>2^h</em> 个节点。余下的树上层包涵 <em>2^h - 1</em> 个节点。带入例子中相应的数据：最低一层有 8 个节点，恰好是 <code>2^3 = 8</code>。前面的三层共包含 7 个节点，正好等于 <code>2^3 - 1 = 8 - 1 = 7</code>。</p>
<p>整个堆中节点总数是 <em>2^(h+1) - 1</em>。代入例子，<code>2^4 - 1 = 16 - 1 = 15</code>。</p>
<p>一个高度为 <em>h</em> 含有 <em>n</em> 个元素堆，最多可以拥有  <em>ceil(n/2^(h+1))</em> 个节点。（译者：这里没懂，有待更新）<br>There are at most <em>ceil(n/2^(h+1))</em> nodes of height <em>h</em> in an <em>n</em>-element heap.</p>
<p>叶子节点在数组中的索引范围总是 <em>floor(n/2)</em> 到 <em>n-1</em>。由此我们可以快速地通过数组来构建一个堆。如有疑问，可以通过例子来验证这一结论。;-)</p>
<p>几个简单的数学知识照亮了你的一天。（译者：这句翻译的极差，原文暂时保留。）<br>Just a few math facts to brighten your day.</p>
<h2 id="能用堆做什么呢？"><a href="#能用堆做什么呢？" class="headerlink" title="能用堆做什么呢？"></a>能用堆做什么呢？</h2><p>在插入或移除元素后，有两个基本操作必须要做，以保证堆是一个有效的大序堆或小序堆：</p>
<ul>
<li><p><code>shiftUp()</code>: 如果某个元素大于 (大序堆) 或小于 (小序堆) 它的父（节点）, 那么它就需要与父节点进行交换. 使它在整个树中上移。</p>
</li>
<li><p><code>shiftDown()</code>. 如果某个元素小于 (大序堆) 或大于 (小序堆) 它的子节点, 它就需要在整个树中下移。 这一操作也被称为 “堆化（heapify）”.</p>
</li>
</ul>
<p>上移或下移是个递归程序，其时间复杂度都是 **O(log n)**。</p>
<p>下面是一些构建于基础操作之上的操作：</p>
<ul>
<li><p><code>insert(value)</code>: 在堆末端添加一个新元素，之后在通过 <code>shiftUp()</code> 对堆进行恢复（译者：恢复堆属性，回想下为什么要这么做）</p>
</li>
<li><p><code>remove()</code>: 移除并返回最大值（大序堆）或最小值（小序堆），会导致堆出现空缺（译者：根位置），要填上这个空位，首先将最后一个元素填补到根的位置，之后在通过 <code>shiftDown()</code> 操作来恢复堆属性。（有时该操作也被称为“取小（extract min）”或“取大（extract max）”）</p>
</li>
<li><p><code>removeAtIndex(index)</code>: 类似 <code>remove()</code>， 区别就在于，除了根元素，它还允许你移除任意堆内其它元素。该（方法）同样会在新晋元素与其子元素顺序错误时或者新晋元素与其父元素顺序错误时调用到 <code>shiftDown()</code> 和 <code>shiftUp()</code> （方法）。</p>
</li>
<li><p><code>replace(index, value)</code>: 给一个 (小序堆)的节点赋相对更小的值或给一个 (大序堆) 的节点赋相对更大的值时， 由于该操作会破坏堆属性, 所以之后会通过 <code>shiftUp()</code> 方法进行恢复（译者：恢复堆的排序属性）. (也称为 “decrease key” 和 “increase key”.)</p>
</li>
</ul>
<p>因为无论是升档 <code>shiftUp()</code> 还是降档 <code>shiftDown()</code> 都是昂贵的操作，所以以上操作的时间杂度都是 <strong>O(log n)</strong> 。此外还有一些操作更耗时：</p>
<ul>
<li><p><code>search(value)</code>. 堆（结构）本身就不是为了高效查询而建立的, 但是因为 <code>replace()</code> 和 <code>removeAtIndex()</code> 操作需要查询目标节点的索引, 所以不得不如此。 时间杂度: **O(n)**。</p>
</li>
<li><p><code>buildHeap(array)</code>: 通过反复调用 <code>insert()</code> 方法，将一个（无序）数组转化为堆。如果你做的够好，那么（该方法的）时间杂度应该是 **O(n)**。</p>
</li>
<li><p><a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Heap%20Sort/">堆排（Heap sort）</a>. 鉴于堆是一个数组, 我们可以借助一特点对其进行从低到高地排序。 时间杂度: **O(n lg n)**。</p>
</li>
</ul>
<p>堆还有一个  <code>peek()</code> 方法，可以返回最大（大序堆）或最小（小序堆）的元素，而无需从堆中移除。时间杂度：**O(1)**。</p>
<blockquote>
<p><strong>注意:</strong> 虽然说了这么多，但是最常用的还是插入新元素 <code>insert()</code> 和移除最大或最小值的<code>remove()</code> 两个操作。它们的时间杂度都是 **O(log n)**。其它操作都是为了一些进阶应用，例如在构建优先级队列时，可以对已添加的重要对象进行修改。</p>
</blockquote>
<h2 id="向堆中插入"><a href="#向堆中插入" class="headerlink" title="向堆中插入"></a>向堆中插入</h2><p>下面我们通过一个插入的例子来深入了解这一操作过程。以插入 <code>16</code> 为例：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Heap1.png" alt="The heap before insertion"></p>
<p>与之对应的数组是 <code>[ 10, 7, 2, 5, 1 ]</code>.</p>
<p>首先将要插入的元素添加至数组末尾，此时数组变为：</p>
<pre><code>[ 10, 7, 2, 5, 1, 16 ]</code></pre>
<p>对应的树如下：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Insert1.png" alt="The heap before insertion"></p>
<p><code>(16)</code> 被添加到了最后一行的第一个有效位。</p>
<p>如此堆属性被破坏了，因为 <code>(2)</code> 排在了 <code>(16)</code> 上面，而正确的应该是是大数在小数上面。（这是大序堆）</p>
<p>要恢复堆属性，我们需要将 <code>(16)</code> 和 <code>(2)</code> 互换。</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Insert2.png" alt="The heap before insertion"></p>
<p>还没完，因为 <code>(10)</code> 还是比 <code>(16)</code> 小。继续将其与父元素进行交换，直至父元素更大或者抵达数的顶端。该（操作）被称为 <strong>升档（shift-up）</strong> 或者 <strong>换挡（sifting）</strong>，每次插入都会被执行。使得哪些比较大或比较小的数沿着树“上浮”。</p>
<p>最终结果如下：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Insert3.png" alt="The heap before insertion"></p>
<p>现在每个父节点都比其子节点要大了。</p>
<p>由于升档所耗费的时间与树的高度是成正例的，所以它的时间杂度是 **O(log n)**。（向数组末尾添加元素的时间杂度仅仅是 **O(1)**，所以它对总体的时间杂度无影响。）</p>
<h2 id="移除根"><a href="#移除根" class="headerlink" title="移除根"></a>移除根</h2><p>从树中移除 <code>(10)</code>：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Heap1.png" alt="The heap before removal"></p>
<p>空出来的顶点会怎么样呢？</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Remove1.png" alt="The root is gone"></p>
<p>插入时，我们是将新值添加到数组末尾。这次反过来：取到最后一个元素，在将它放到树的顶端，然后在（逐步）恢复堆属性。</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Remove2.png" alt="The last node goes to the root"></p>
<p>我们来看看怎么对 <code>(1)</code> 进行 <strong>降档（shift-down）</strong>。要恢复大序堆的堆属性，需要最大的值在顶端。此时有两个候选交换对象： <code>(7)</code> 和 <code>(2)</code>需要交换。选择三个节点中最大的。也就是 <code>(7)</code>（进行交换），交换<code>(1)</code> 和 <code>(7)</code> 后如下图</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Remove3.png" alt="The last node goes to the root"></p>
<p>继续将挡，直到该节点没有子节点，或者它比其所有子节点都大。对我们这个堆来说，再进行一次交换即可恢复堆属性：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Remove4.png" alt="The last node goes to the root"></p>
<p>升降操作的次数与树的高度是正比的，其时间杂度是 **O(log n)**。</p>
<blockquote>
<p><strong>注意：</strong> 无论 <code>shiftUp()</code> 还是 <code>shiftDown()</code> 一次都只能恢复那些只有一个元素位置错误的（堆）。 如果有多个元素位置错误，那么就需要每个错误元素都调用一次该方法。</p>
</blockquote>
<h2 id="移除任意节点"><a href="#移除任意节点" class="headerlink" title="移除任意节点"></a>移除任意节点</h2><p>鉴于堆的设计初衷，大多数时间我们都只是需要移除根元素。</p>
<p>然而，随机移除某个元素也非常有帮助。这个一个通用版的 <code>remove()</code>，并且需要调用 <code>shiftDown()</code> 或 <code>shiftUp()</code> 方法。</p>
<p>还是用之前的例子，来移除 <code>(7)</code>：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Heap1.png" alt="The heap before removal"></p>
<p>初始，数组是这样的：</p>
<pre><code>[ 10, 7, 2, 5, 1 ]</code></pre>
<p>如你所知，移除一个元素会潜在的破坏大序堆或小序堆属性。要修复这点，我们需要将最后一个元素与我们即将移除的元素做交换。</p>
<pre><code>[ 10, 1, 2, 5, 7 ]</code></pre>
<p>最后一个元素是我们需要返回的元素；接下来通过 <code>removeLast()</code> 方法将其从堆中移除。此时 <code>(1)</code> 因为比它的子节点 <code>(5)</code> 小，所以是错序的。通过 <code>shiftDown()</code> 来修正。</p>
<p>然而，光降档可不够应对所有情况，还有可能需要升档。试想一下如果从下面的堆中移除 <code>(5)</code>：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Remove5.png" alt="We need to shift up"></p>
<p><code>(5)</code> 跟 <code>(8)</code> 交换。此时由于 <code>(8)</code> 比其父节点要大，所以需要进行 <code>shiftUp()</code>。</p>
<h2 id="通过数组创建堆"><a href="#通过数组创建堆" class="headerlink" title="通过数组创建堆"></a>通过数组创建堆</h2><p>数组转堆很方便，只要将数组中的元素按堆属性进行排序即可。</p>
<p>代码是如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(fromArray array: [T])</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">    insert(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是简单地对数组中的每个元素调用了 <code>insert()</code> 方法。简单是简单，但不够效率。由于要对 <strong>n</strong> 个元素逐个执行 <strong>log n</strong> 插入操作，所以它的时间杂度是 **O(n log n)**。</p>
<p>如果前一节的数学“buff”还在，你就会发现，任何位于数组 <em>n/2</em> 到 <em>n-1</em> 索引位的堆元素都是树的叶子节点。这部分完全可以跳过，只处理其余节点即可，那怕他们可能是一个或多个子节点的父节点，甚至顺序错误。</p>
<p>代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">buildHeap</span><span class="params">(fromArray array: [T])</span></span> &#123;</span><br><span class="line">  elements = array</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: (nodes.<span class="built_in">count</span>/<span class="number">2</span>-<span class="number">1</span>), through: <span class="number">0</span>, by: -<span class="number">1</span>) &#123;</span><br><span class="line">    shiftDown(index: i, heapSize: elements.<span class="built_in">count</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, <code>elements</code> is the heap’s own array. We walk backwards through this array, starting at the first non-leaf node, and call <code>shiftDown()</code>. This simple loop puts these nodes, as well as the leaves that we skipped, in the correct order. This is known as Floyd’s algorithm and only takes <strong>O(n)</strong> time. Win!（译者注：这里还要补充一下弗洛伊德算法的知识，在更新。）</p>
<h2 id="堆搜索"><a href="#堆搜索" class="headerlink" title="堆搜索"></a>堆搜索</h2><p>堆就不是为了搜索而建立的，但是如果你想通过 <code>removeAtIndex()</code> 随机移除一个元素或者通过 <code>replace()</code> 随机的修改一个元素，那么就需要先获取该元素的索引。查询也便成了必然，即使很慢。</p>
<p>在<a href="https://dracarys.github.io/2019/01/26/Algorithm-club-binary-search-tree/">二叉搜索树（binary search tree）</a>中，由于节点间固有的顺序特征，所以检索的速度非常快。然而堆节点的排序与之是不同的，所以二叉搜索算法（此时）行不通，我们必须遍历树中的每个节点。</p>
<p>再次以之前的堆为例：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Heap/Images/Heap1.png" alt="The heap"></p>
<p>假设我们要查找节点 <code>(1)</code> 的索引，此时必须线性搜索遍历整个数组 <code>[ 10, 7, 2, 5, 1 ]</code></p>
<p>即使堆属性在建立时没有考虑到搜索，但我们还是可以利用到一些它的特点。鉴于大序堆中的父节点总是比其子节点大，因此如果父节点比查找的目标值还小，那么我们就可以忽略其子节点（和子节点的子节点，以及其子子孙孙）</p>
<p>假设我们要查看堆是否包含数值 <code>8</code> (不存在）。首先从根节点 <code>(10)</code>开始。根不是，之后递归他的左右子节点。左节点是 <code>(7)</code>，不是我们要找的，但鉴于是一个大序堆，所以 <code>(7)</code> 的子节点也不用找了。因为他们都比 <code>7</code> 小，永远也不可能等于 <code>8</code>。同理，右节点的 <code>(2)</code>也是如此。</p>
<p>尽管有些小的优化，但是搜索的时间杂度依然是 **O(n)**。</p>
<blockquote>
<p><strong>注意：</strong> 可以用一个额外的字典来保存节点值与其索引的映射关系，如此搜索的时间杂度可以降为 **O(1)**，如果经常需要修改<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Priority%20Queue">优先队列（priority queue）</a>中元素的“优先级”，且该优先队列是构建在堆之上的，那么这这么做还是非常值得的。（译者：牺牲空间换取时间）</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>请参见<a href="https://github.com/Dracarys/swift-algorithm-club/blob/master/Heap/Heap.swift">Heap.swift</a>，以了解该概念是如何通过 Swift 实现的。绝大部分代码都非常直观。稍微有点技巧的点在 <code>shiftUp()</code> 和 <code>shiftDown()</code> 方法中。</p>
<p>有两种类型的堆：大序堆和小序堆。他们唯一的区别就是排序方式：大值在先还是小值在先。</p>
<p>相比于创建两个不同版本的堆，<code>MaxHeap</code> 和 <code>MinHeap</code>，这里只有一个 <code>Heap</code> 对象，只是它还可以接受一个 <code>isOrderedBefore</code> 闭包。该闭包包含判断两个值大小的逻辑。可能你很早就接触，因为它也被用在 Swift 的 <code>sort()</code> 方法中。</p>
<p>创建在一个整形的大序堆：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxHeap = <span class="type">Heap</span>&lt;<span class="type">Int</span>&gt;(<span class="built_in">sort</span>: &gt;)</span><br></pre></td></tr></table></figure>

<p>创建相应的小序堆:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minHeap = <span class="type">Heap</span>&lt;<span class="type">Int</span>&gt;(<span class="built_in">sort</span>: &lt;)</span><br></pre></td></tr></table></figure>

<p>I just wanted to point this out, because where most heap implementations use the <code>&lt;</code> and <code>&gt;</code> operators to compare values, this one uses the <code>isOrderedBefore()</code> closure.</p>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29">堆_维基百科</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定算法基础的同学进行回顾，如果你才接触算法，那么建议移步阅读详细<a href="https://www.raywenderlich.com/160631/swift-algorithm-club-heap-and-priority-queue-data-structure">教程</a></p>
<p><em>由 <a href="http://www.github.com/kevinrandrup">Kevin Randrup</a> 和 Matthijs Hollemans 联合发表于 Swift 算法社区</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——链表</title>
    <url>/2018/12/18/Algorithm-club-linked-list/</url>
    <content><![CDATA[<p>链表是一连串的数据对象，像数组一样。但与数组不同的是，数组需要在内存中开辟一大块内存用来存储对象，而链表中的对象则是分散存储在内存中，它们通过一条链链接在一起：</p>
<a id="more"></a>

<pre><code>+--------+    +--------+    +--------+    +--------+
|        |    |        |    |        |    |        |
| node 0 |---&gt;| node 1 |---&gt;| node 2 |---&gt;| node 3 |
|        |    |        |    |        |    |        |
+--------+    +--------+    +--------+    +--------+</code></pre>
<p>链表中的元素被引用为 <em>nodes（节点）</em>。上图展示了一个 <em>singly linked list（单向链表）</em>，这里每个节点都有一个指向下一个节点的引用或者说是“指针”。但是在如下图所示的 <em>doubly linked list（双向链表）</em>中，每个节点还有一个指向前一节点的指针：</p>
<pre><code>+--------+    +--------+    +--------+    +--------+
|        |---&gt;|        |---&gt;|        |---&gt;|        |
| node 0 |    | node 1 |    | node 2 |    | node 3 |
|        |&lt;---|        |&lt;---|        |&lt;---|        |
+--------+    +--------+    +--------+    +--------+</code></pre>
<p>通常一个链表的首节点包含一个成为 <em>head（头）</em> 的指针：</p>
<pre><code>         +--------+    +--------+    +--------+    +--------+
head ---&gt;|        |---&gt;|        |---&gt;|        |---&gt;|        |---&gt; nil
         | node 0 |    | node 1 |    | node 2 |    | node 3 |
 nil &lt;---|        |&lt;---|        |&lt;---|        |&lt;---|        |&lt;--- tail
         +--------+    +--------+    +--------+    +--------+</code></pre>
<p>对尾部的引用也非常重要，被称为 <em>tail（尾）</em>。注意，最后一个节点的“next”指针和首节点的“pevious”指针一样，均为“nil”</p>
<h2 id="链表的执行效率"><a href="#链表的执行效率" class="headerlink" title="链表的执行效率"></a>链表的执行效率</h2><p>对于大多数链表来说，它的时间复杂度都是 <strong>O(n)</strong> 。所以链表通常要比数组慢。但是相对于数组动则就要拷贝整块内存来说，链表的操作更具灵活性，大多仅需要改变几个指针即可。</p>
<p>之所以（链表的）时间杂度是 **O(n)**，是因为你不能简单地通过 <code>list[2]</code> 去访问 2 号节点。如果你现在没有 2 号节点的引用，那么就必须从 <code>head</code> 开始，通过 <code>next</code> 指针（或者从 <code>tail</code>开始，通过 <code>previous</code> 指针），一路查找下去。</p>
<p>一旦你拥有了某个节点的引用，那么无论是执行插入还是删除操作均非常便捷。只是查找节点较慢。</p>
<p>也就是说，操作链表时，始终应该在前面插入新节点，这一操作的时间杂度是 **O(1)**。相反如果你持有的是链表的 <code>tail</code> 指针，那么你应该始终在后面插入新节点。</p>
<h2 id="单向-VS-双向链表"><a href="#单向-VS-双向链表" class="headerlink" title="单向 VS 双向链表"></a>单向 VS 双向链表</h2><p>相对于双向链表，由于单向链表无需保存 <code>previous</code>指针，所以它消耗的内存更少。</p>
<p>但是，如果你需要查找一个已有节点的前一个节点，那就麻烦了。你必须从头开始遍历，直到找到正确的节点。</p>
<p>针对大多数应用场景，双向链表更容易一些。</p>
<h2 id="为什么采用链表？"><a href="#为什么采用链表？" class="headerlink" title="为什么采用链表？"></a>为什么采用链表？</h2><p>链表的一个典型应用场景就是<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Queue">队列(queue)</a>。用数组实现的队列，移除前端的一个元素相对缓慢，这是因为你必须先将其他元素出栈。队列就不同了，你只要将 <code>head</code> 指向第二个元素即可，操作非常之快。</p>
<p>但是说实话，工作中你几乎没多少机会去实现自己的链表。但是理解链表的原理还是非常有帮助的；其中涉及到的对象链接原理同样适用于<a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Tree">树(trees)</a> 和 <a href="https://github.com/Dracarys/swift-algorithm-club/tree/master/Graph">图(graphs)</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们首先定义一个节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">  <span class="keyword">var</span> next: <span class="type">LinkedListNode?</span></span><br><span class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> previous: <span class="type">LinkedListNode?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里运用了泛型，所以 <code>T</code> 可以表示任何你即将存储于节点中的数据类型。后续都将以字符串为例。</p>
<p>我们采用双向链表，每个节点都拥有一个 <code>next</code> 和一个 <code>previous</code> 指针（译者注：原文为pointer，但 swift 中实际是一个引用）。因为它可能没有下一个或者前一个节点，所以采用可选类型。（后续会逐个指出，那些在单向链表中需要改动的函数）</p>
<blockquote>
<p><strong>Note:</strong> 为了避免循环持有，这里我们将 <code>previous</code> 声明为弱引用。假设有一个节点 <code>A</code> 其后跟着一个节点 <code>B</code>, 此时 <code>A</code> 指向 <code>B</code> 但 <code>B</code> 也同样指向 <code>A</code>。这就出现了循环持有的情况，即使你删除了这个两个节点，由于他们互相持有也将持续存活（于内存中）。这不是我们期望的，所以我们将其中的一个引用设为 <code>weak</code> 以打破这种循环。</p>
</blockquote>
<p>让我们开始构建链表。下面是第一步：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> = <span class="type">LinkedListNode</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> head: <span class="type">Node?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> head == <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Node?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望一个类的命名越具描述性越好，但是我们又不想每次使用该类时都打很多的字，因此在 <code>LinkedList</code> 内部，我们使用类型别名 <code>Node</code> 来取代 <code>LinkedListNode&lt;T&gt;</code> 。</p>
<p>该链表中仅有一个 <code>head</code> 引用，没有尾部。这里就把添加尾部指针作为练习留给读者。（教程中会指出，如果存在尾指针，函数会有哪些不同）</p>
<p>当 <code>head</code> 为 nil 时，该链表为空。由于 <code>head</code> 是一个私有变量，此处还添加了一个 <code>first</code> 属性，以便返回链表的第一个节点。</p>
<p>你可以在Playground中尝试一下，类似这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">list.isEmpty   <span class="comment">// true</span></span><br><span class="line">list.first     <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>我们在添加一个属性，用于返回链表的尾节点。开始变得有趣了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Node?</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</span><br><span class="line">    node = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你刚接触 Swift，你可能对 <code>if let</code> 有印象，但是对 <code>if var</code> 较陌生。他们的作用是相同的，对可选类型 <code>head</code> 进行解封，并将解封的结果赋值给一个名为 <code>node</code> 的局部变量。唯一不同就是这里的 <code>node</code> 是一个变量而非常量，因此可以在循环的内部对其进行修改。</p>
<p>这个循环也施了一些 Swift 魔法。 <code>while let next = node.next</code> 持续循环直到 <code>node.next</code> 为 nil。你可以写成下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node: <span class="type">Node?</span> = head</span><br><span class="line"><span class="keyword">while</span> node != <span class="literal">nil</span> &amp;&amp; node!.next != <span class="literal">nil</span> &#123;</span><br><span class="line">  node = node!.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样给我感觉不够 Swift。我们尽可能使用 Swift 内建支持的解封方式。之后的代码中你还会看到很多类似对循环。</p>
<blockquote>
<p><strong>Note:</strong> 如果我们持有一个尾部指针，那么 <code>last</code> 直接返回 <code>return tail</code> 即可。但如果没有，那么就必须从头部开始遍历整条链直到尾部。这种操作是非常昂贵的，尤其是当链很长时。（译者注：持有尾部，获取尾部的时间复杂度为 O(1)，否则将变为O(n)）</p>
</blockquote>
<p>当然，<code>last</code> 只会返回 nil，因为链表中还没有任何节点。我们来添加一个可以向链表尾部添加新节点的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="type">Node</span>(value: value)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> lastNode = last &#123;</span><br><span class="line">    newNode.previous = lastNode</span><br><span class="line">    lastNode.next = newNode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    head = newNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>append()</code> 方法首先创建一个节点，之后访问 <code>last</code> 属性。如果不存节点，链表为空，那么就将 <code>head</code> 指向刚刚创建的新 <code>Node</code>。但是如果找到了一个有效的节点，就更新 <code>next</code> 和 <code>previous</code>指针，将新创建的节点添加到链中。链表中的大量代码都是针对 <code>next</code> 和 <code>previous</code> 的指针操作。</p>
<p>我们在 palyground 中测试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.append(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">list.isEmpty         <span class="comment">// false</span></span><br><span class="line">list.first!.value    <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list.last!.value     <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时链表如下图所示：</p>
<pre><code>         +---------+
head ---&gt;|         |---&gt; nil
         | &quot;Hello&quot; |
 nil &lt;---|         |
         +---------+</code></pre>
<p>现在添加第二个节点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.append(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">list.first!.value    <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list.last!.value     <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时链表是这样的：</p>
<pre><code>         +---------+    +---------+
head ---&gt;|         |---&gt;|         |---&gt; nil
         | &quot;Hello&quot; |    | &quot;World&quot; |
 nil &lt;---|         |&lt;---|         |
         +---------+    +---------+</code></pre>
<p>你可以通过查看 <code>next</code> 和 <code>previous</code> 来进行校验：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.first!.previous          <span class="comment">// nil</span></span><br><span class="line">list.first!.next!.value       <span class="comment">// &quot;World&quot;</span></span><br><span class="line">list.last!.previous!.value    <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list.last!.next               <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<p>我们在来添加一个统计链表中节点数的方法。跟前面做法非常类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</span><br><span class="line">    node = next</span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以同样的方式遍历整个链，不同是同时进行了计数。</p>
<blockquote>
<p><strong>Note:</strong> 一个将 <code>count</code> 的效率从 <strong>O(n)</strong> 提升 <strong>O(1)</strong> 的方式是，维护一个变量，无论你添加还是删除一个节点，都对该变量进行更新。</p>
</blockquote>
<p>如果我们想查找某个索引节点怎么办？在数组中我们可以通过下标 <code>array[index]</code> 去访问，该访问耗时 **O(1)**。链表虽相对复杂一些，但又一次应用了相同的模式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(atIndex index: Int)</span></span> -&gt; <span class="type">Node</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> head!</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> node = head!.next</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;index &#123;</span><br><span class="line">      node = node?.next</span><br><span class="line">      <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="comment">//(*1)</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们检查索引是否为 0。如果是 0，直接返回 head(头) 即可。但如果索引大于 0，那么还是从头开始，沿着 next 指针对链表进行遍历。与之前计数方法不同的是，这一次拥有两个终止条件。一个是 for 循环表达式已抵达指定的索引，并且我们可以去的相应索引的节点。另一个是 for 循环表达式中的 <code>node.next</code> 返回空值退出循环。也就是说给定的索引越界并崩溃。</p>
<p>试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.nodeAt(<span class="number">0</span>)!.value    <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list.nodeAt(<span class="number">1</span>)!.value    <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="comment">// list.nodeAt(2)           // crash</span></span><br></pre></td></tr></table></figure>

<p>出于好玩，我们还可以实现其 <code>subscript</code> 方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = node(atIndex: index)</span><br><span class="line">  <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你可以这样访问了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list[<span class="number">0</span>]   <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list[<span class="number">1</span>]   <span class="comment">// &quot;World&quot;</span></span><br><span class="line">list[<span class="number">2</span>]   <span class="comment">// crash!</span></span><br></pre></td></tr></table></figure>
<p>因为没有（2号）节点，所以 <code>list[2]</code> 崩溃了。</p>
<p>截止目前我们已经实现了想链表尾部添加节点的方法，但是很低效，因为你需要在添加前先找到尾部（如果持有尾部指针的话将非常高效）。所以，如果链表内元素顺序无关紧要的话，你就应该在链表的头部插入节点。这也是一个 <strong>O(1)</strong> 的操作。</p>
<p>我们来实现一个可以在任意位置插入新节点的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="keyword">_</span> node: Node, atIndex index: Int)</span></span> &#123;</span><br><span class="line">   <span class="keyword">let</span> newNode = node</span><br><span class="line">   <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">     newNode.next = head                      </span><br><span class="line">     head?.previous = newNode</span><br><span class="line">     head = newNode</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> prev = <span class="keyword">self</span>.node(atIndex: index-<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">let</span> next = prev.next</span><br><span class="line"></span><br><span class="line">     newNode.previous = prev</span><br><span class="line">     newNode.next = prev.next</span><br><span class="line">     prev.next = newNode</span><br><span class="line">     next?.previous = newNode</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像 <code>node(atIndex :)</code> 方法一样，<code>insert(_: at:)</code> 方法同样需要判断给定索引是否为 0.</p>
<p>首先我们回顾一下之前的例子。假定我们拥有如下的一个链表和一个新节点(C)。</p>
<pre><code>         +---------+     +---------+
head ---&gt;|         |----&gt;|         |-----//-----&gt;
         |    A    |     |    B    |
 nil &lt;---|         |&lt;----|         |&lt;----//------
         +---------+     +---------+ 
             [0]             [1]


         +---------+ 
 new ---&gt;|         |----&gt; nil
         |    C    |
         |         |
         +---------+</code></pre>
<p>现在将新节点添加首节点之前，像这样：</p>
<pre><code>new.next = head
head.previous = new

         +---------+            +---------+     +---------+
 new ---&gt;|         |--&gt; head --&gt;|         |----&gt;|         |-----//-----&gt;
         |    C    |            |    A    |     |    B    |
         |         |&lt;-----------|         |&lt;----|         |&lt;----//------
         +---------+            +---------+     +---------+ </code></pre>
<p>最后，让 head 指向新节点。</p>
<pre><code>head = new

         +---------+    +---------+     +---------+
head ---&gt;|         |---&gt;|         |----&gt;|         |-----//-----&gt;
         |    C    |    |    A    |     |    B    |
 nil &lt;---|         |&lt;---|         |&lt;----|         |&lt;----//------
         +---------+    +---------+     +---------+ 
             [0]            [1]             [2]</code></pre>
<p>然而，当制定的索引大于 0 时，就必须获同时获取 privious 和 next 的索引，并在其间插入新节点。（译者：为什么必须获取两个呢？）</p>
<p>通过 <code>node(atIndex:)</code> 同样可以获取 privious 和 next 索引，如下：</p>
<pre><code>         +---------+         +---------+     +---------+    
head ---&gt;|         |---//---&gt;|         |----&gt;|         |----
         |         |         |    A    |     |    B    |    
 nil &lt;---|         |---//&lt;---|         |&lt;----|         |&lt;---
         +---------+         +---------+     +---------+    
             [0]              [index-1]        [index]      
                                  ^               ^ 
                                  |               | 
                                 prev            next

prev = node(at: index-1)
next = prev.next</code></pre>
<p>现在在 privious 和 next 之间插入新节点。</p>
<pre><code>new.prev = prev; prev.next = new  // connect prev and new.
new.next = next; next.prev = new  // connect new and next.

         +---------+         +---------+     +---------+     +---------+
head ---&gt;|         |---//---&gt;|         |----&gt;|         |----&gt;|         |
         |         |         |    A    |     |    C    |     |    B    |
 nil &lt;---|         |---//&lt;---|         |&lt;----|         |&lt;----|         |
         +---------+         +---------+     +---------+     +---------+
             [0]              [index-1]        [index]        [index+1]
                                  ^               ^               ^
                                  |               |               |
                                 prev            new             next</code></pre>
<p>验证一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.insert(<span class="string">&quot;Swift&quot;</span>, atIndex: <span class="number">1</span>)</span><br><span class="line">list[<span class="number">0</span>]     <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list[<span class="number">1</span>]     <span class="comment">// &quot;Swift&quot;</span></span><br><span class="line">list[<span class="number">2</span>]     <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<p>同样地，验证下分别在首尾添加新节点，已确定一切工作正常。</p>
<blockquote>
<p><strong>Note:</strong> <code>node(atIndex:)</code> 和 <code>insert(_: atIndex:)</code> 方法同样适用于单向链表，因为它并不赖节点的 <code>previous</code> 指针来查找前一个元素。</p>
</blockquote>
<p>我们还需要些什么呢？当然是移除节点！首先，我们实现 <code>removeAll()</code>方法，很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">  head = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你设置了 tail 指针，此时你必须也将其置为 nil。</p>
<p>接下来，我们来添加一些方法，用于益处制定节点。如果你已经持有某个节点的引用，无疑直接 <code>remove()</code> 是最效率的，因为省去了遍历查找的过程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(node: Node)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> prev = node.previous</span><br><span class="line">  <span class="keyword">let</span> next = node.next</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> prev = prev &#123;</span><br><span class="line">    prev.next = next</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    head = next</span><br><span class="line">  &#125;</span><br><span class="line">  next?.previous = prev</span><br><span class="line"></span><br><span class="line">  node.previous = <span class="literal">nil</span></span><br><span class="line">  node.next = <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当从链中移除一个节点时，我们也破坏了对前后节点的引用。要恢复成完整的链，我们必须将上下节点重新链接起来。</p>
<p>别忘了 <code>head</code> 指针！如果（移除的）刚好时首节点，那么此时必须更新 <code>head</code> ，让它指向下一个节点。（反之亦然，如果你持有的是 <code>tail</code> 指针，同样需要让它指向尾节点。）。当然，如果没有节点了，那么 <code>head</code> 就应该置为 nil 。</p>
<p>验证一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.remove(list.first!)   <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">list.<span class="built_in">count</span>                     <span class="comment">// 2</span></span><br><span class="line">list[<span class="number">0</span>]                        <span class="comment">// &quot;Swift&quot;</span></span><br><span class="line">list[<span class="number">1</span>]                        <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果未持有一个节点，那么你可以使用 <code>removeLast()</code> 或者 <code>removeAt()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(!isEmpty)</span><br><span class="line">  <span class="keyword">return</span> remove(node: last!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">_</span> index: Int)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> node = nodeAt(index)</span><br><span class="line">  <span class="built_in">assert</span>(node != <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">return</span> remove(node: node!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的移除方法都会返回被移除的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">list.removeLast()              <span class="comment">// &quot;World&quot;</span></span><br><span class="line">list.<span class="built_in">count</span>                     <span class="comment">// 1</span></span><br><span class="line">list[<span class="number">0</span>]                        <span class="comment">// &quot;Swift&quot;</span></span><br><span class="line"></span><br><span class="line">list.removeAt(<span class="number">0</span>)          <span class="comment">// &quot;Swift&quot;</span></span><br><span class="line">list.<span class="built_in">count</span>                     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note:</strong> 对单向链表来说，移除尾部元素稍显复杂。不能简单的通过 <code>last</code> 来查找链的尾端，因为你还需要倒数第二个节点的引用，需要用 <code>nodesBeforeAndAfter()</code> 替代。如果链表有一个 tail 指针，那么 <code>removeLast()</code> 就非常便捷了，但是务必记得，移除后要让 <code>tail</code> 指向前一个节点。</p>
</blockquote>
<p>还可以为 <code>LinkedList</code> 类添加一些有趣的方法。比如让 debug 输出更具可能性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LinkedList</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">&quot;[&quot;</span></span><br><span class="line">    <span class="keyword">var</span> node = head</span><br><span class="line">    <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">      s += <span class="string">&quot;\(node!.value)&quot;</span></span><br><span class="line">      node = node!.next</span><br><span class="line">      <span class="keyword">if</span> node != <span class="literal">nil</span> &#123; s += <span class="string">&quot;, &quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s + <span class="string">&quot;]&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会让输出变成一下格式：</p>
<pre><code>[Hello, Swift, World]</code></pre>
<p>翻转链表，让它首位互换如何？下面是一种非常高效的反转算法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> node = head</span><br><span class="line">  tail = node <span class="comment">// If you had a tail pointer</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">let</span> currentNode = node &#123;</span><br><span class="line">    node = currentNode.next</span><br><span class="line">    <span class="built_in">swap</span>(&amp;currentNode.next, &amp;currentNode.previous)</span><br><span class="line">    head = currentNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环遍历真个链并交换每个节点的 <code>next</code> 和 <code>previous</code> 指针。同时将 <code>head</code> 指向最后一个元素。（如果你设置了 tail 指针，此时需要同步更新）反转后的链表是这样的：</p>
<pre><code>         +--------+    +--------+    +--------+    +--------+
tail ---&gt;|        |&lt;---|        |&lt;---|        |&lt;---|        |---&gt; nil
         | node 0 |    | node 1 |    | node 2 |    | node 3 |
 nil &lt;---|        |---&gt;|        |---&gt;|        |---&gt;|        |&lt;--- head
         +--------+    +--------+    +--------+    +--------+</code></pre>
<p>数组拥有 <code>map()</code> 和 <code>filter()</code> 方法，没理由链表没有啊。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: T -&gt; U)</span></span> -&gt; <span class="type">LinkedList</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="type">LinkedList</span>&lt;<span class="type">U</span>&gt;()</span><br><span class="line">  <span class="keyword">var</span> node = head</span><br><span class="line">  <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">    result.append(transform(node!.value))</span><br><span class="line">    node = node!.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">list.append(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">list.append(<span class="string">&quot;Swifty&quot;</span>)</span><br><span class="line">list.append(<span class="string">&quot;Universe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = list.<span class="built_in">map</span> &#123; s <span class="keyword">in</span> s.characters.<span class="built_in">count</span> &#125;</span><br><span class="line">m  <span class="comment">// [5, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>这是 filter（的实现）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(predicate: T -&gt; Bool)</span></span> -&gt; <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">  <span class="keyword">var</span> node = head</span><br><span class="line">  <span class="keyword">while</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate(node!.value) &#123;</span><br><span class="line">      result.append(node!.value)</span><br><span class="line">    &#125;</span><br><span class="line">    node = node!.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个比较笨的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = list.<span class="built_in">filter</span> &#123; s <span class="keyword">in</span> s.<span class="built_in">count</span> &gt; <span class="number">5</span> &#125;</span><br><span class="line">f    <span class="comment">// [Universe, Swifty]</span></span><br></pre></td></tr></table></figure>

<p>读者练习：这里实现的 <code>map()</code> and <code>filter()</code> 不够高效，因为他们都是通过 <code>append()</code> 方法向尾端添加新节点。而调用一次添加的时间复杂度是 **O(n)**，每次都要扫描整条链来查找最后一个节点。你能让它更高效一些吗？（提示：试着持有你刚刚添加的那个节点）。</p>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>目前为止， <code>LinkedList</code> 是通过类引用来实现的，这没什么错，但是相对 Swift 中的其它集合诸如<code>Array</code> 和 <code>Dictionary</code> 而言，显得有些偏重。</p>
<p>其实它是可以以值的方式通过枚举来实现，大概这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> node(<span class="type">T</span>, next: <span class="type">ListNode</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举实现（相对类引用实现）最大的不同点在于，针对链作出的任何改动都会产生一个 *new copy(新的拷贝)*，这是由 <a href="https://developer.apple.com/swift/blog/?id=10">Swift 值语义</a>（自身特点）决定的，与你的意愿或者应用无关。</p>
<p>[作者：如果有必要，我会针对这个部分补充更多细节]<br>[译者：会随着作者的补充进行更新]<br>[I might fill out this section in more detail if there’s a demand for it.]</p>
<h2 id="遵循-Collection-协议"><a href="#遵循-Collection-协议" class="headerlink" title="遵循 Collection 协议"></a>遵循 Collection 协议</h2><p>遵循 Sequence 协议的类型，它所包涵的元素可以被无损地多次遍历，可以通过下标访问，并实现了 Swift 标准库中的 Collection 协议。</p>
<p>处理数据集合时，通常需要进行数量庞大的属性访问和操作。不仅如此，对 Swift 开发者来说，它通常还允许自定义类型匹配</p>
<p>为了实现该协议，类需要实现以下内容：<br>  1 <code>startIndex</code> 和 <code>endIndex</code> 属性.<br>  2 Subscript access to elements as O(1). Diversions of this time complexity need to be documented.<br>In order to conform to this protocol, classes need to provide:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// The position of the first element in a nonempty collection.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">LinkedListIndex</span>&lt;<span class="type">T</span>&gt;(node: head, tag: <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// The collection&#x27;s &quot;past the end&quot; position---that is, the position one</span></span><br><span class="line"><span class="comment">/// greater than the last valid subscript argument.</span></span><br><span class="line"><span class="comment">/// - Complexity: O(n), where n is the number of elements in the list.</span></span><br><span class="line"><span class="comment">///   This diverts from the protocol&#x27;s expectation.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> h = <span class="keyword">self</span>.head &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">LinkedListIndex</span>&lt;<span class="type">T</span>&gt;(node: h, tag: <span class="built_in">count</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">LinkedListIndex</span>&lt;<span class="type">T</span>&gt;(node: <span class="literal">nil</span>, tag: startIndex.tag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Index</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> position.node!.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于集合需要自己管理索引，所以下面的实现保留了一个节点引用。同时一个tag属性用来指示节点在链中的所处位置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Custom index type that contains a reference to the node at index &#x27;tag&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedListIndex</span>&lt;<span class="title">T</span>&gt; : <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> node: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;.<span class="type">LinkedListNode</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">let</span> tag: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span>==&lt;T&gt;<span class="params">(lhs: LinkedListIndex&lt;T&gt;, rhs: LinkedListIndex&lt;T&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (lhs.tag == rhs.tag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span>&lt; &lt;T&gt;<span class="params">(lhs: LinkedListIndex&lt;T&gt;, rhs: LinkedListIndex&lt;T&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (lhs.tag &lt; rhs.tag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，随着下面的实现，链表已经可以通过给定索引计算索引了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(after idx: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">LinkedListIndex</span>&lt;<span class="type">T</span>&gt;(node: idx.node?.next, tag: idx.tag+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时刻留意"><a href="#时刻留意" class="headerlink" title="时刻留意"></a>时刻留意</h2><p>链表灵活性高，但是操作时间杂度是 <strong>O(n)</strong> 。</p>
<p>当对链表执行操作时，务必妥善处理相关的 <code>next</code> 和 <code>previous</code> 指针，以及 <code>head</code> and <code>tail</code> 指针。一旦遗漏，链表就会出错，而工程也可能因此而崩溃，所以务必小心！</p>
<p>处理链表时，尽量使用递归：找到首元素，然后递归调用方法。直到没有下一个元素为止。这也是为什么链表能成为 LISP 这种函数式编程言的基础。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 Raywenderlich 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>，意在帮助有一定算法基础的同学进行回顾，如果你才接触算法，那么建议移步阅读详细<a href="https://www.raywenderlich.com/144083/swift-algorithm-club-swift-linked-list-data-structure">教程</a></p>
<p><em>原文由 Matthijs Hollemans 撰写，发表于Ray Wenderlich的 Swift 算法社区</em></p>
<p><em>译文由 Dracarys 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】数据结构与算法——快速排序</title>
    <url>/2019/08/20/Algorithm-club-quicksort/</url>
    <content><![CDATA[<p>快速排序（Quicksort）是历史上最著名的算法之一。由 Tony Hoare 于 1959年发明，那是一个对递归概念尚且比较模糊的时代。</p>
<a id="more"></a>

<p>下面是一个 Swift 实现的简单版，较容易理解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">guard</span> a.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">let</span> pivot = a[a.<span class="built_in">count</span>/<span class="number">2</span>]</span><br><span class="line">  <span class="keyword">let</span> less = a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">equal</span> = a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == pivot &#125;</span><br><span class="line">  <span class="keyword">let</span> greater = a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> quicksort(less) + <span class="built_in">equal</span> + quicksort(greater)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将如下测试代码放到 playground 中运行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [ <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">26</span> ]</span><br><span class="line">quicksort(list)</span><br></pre></td></tr></table></figure>

<p>当给定一个数组，函数 <code>quicksort()</code> 首先通过变量 “pivots” 将它切分成三部分。这里，我们取数组的中间元素来作为“主元”（稍后会介绍其它取得主元的方法）。</p>
<blockquote>
<p>关于“pivot”的翻译：打扑克斗地主时，如果一把连牌正好少中间那张牌，导致上下连不能一起出牌，被称为“缺轴”，这与本文中的 “pivot” 意思相同。在理解快速排序之后，也可以发现 “pivot” 越是接近数组的“中位数”越好，可见“pivot”被译为轴元才更贴切，也更容易被理解。但是《算法导论》这本最权威的著作没有采用，为了保持一致性，本文也采用了“主元”这个翻译。</p>
</blockquote>
<p>所有小于主元的元素放到 “less” 数组中。所有等主元的放到 <code>equal</code> 数组中。如你所料，所有大于主元的都放入 <code>greater</code> 数组中。这就是为什么范型 <code>T</code> 必须遵循 <code>Comparabel</code> 协议，只有这样，才能对元素进行 <code>&lt;</code>, <code>==</code>, 以及 <code>&gt;</code> 等比较操作。</p>
<p>一旦得到这三个数组，函数 <code>quicksort()</code> 就会对 <code>less</code> 数组以及 <code>greater</code> 数组进行递归排序，最终将排好序的子数组与 <code>equal</code> 数组合并，从而得到最终结果。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面通过例子来进行逐步讲解。初始数组如下：</p>
<pre><code>[ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]</code></pre>
<p>首先，我们选出主元 <code>8</code>。这是因为它正好位于数组的中间位置。接下来，我们将数组分成 less, equal, 和 greater 三个部分：</p>
<pre><code>less:    [ 0, 3, 2, 1, 5, -1 ]
equal:   [ 8, 8 ]
greater: [ 10, 9, 14, 27, 26 ]</code></pre>
<p>看来我们选择了一个不错的 主元，刚好将原数组一切为二，使得 <code>less</code> 、 <code>greater</code> 包涵的元素数量相同。</p>
<p>注意此时 <code>less</code> 和 <code>greater</code> 都还是无序的。所以我们需要再次调用  <code>quicksort()</code>，以便对其进行排序。与之前操作相同，选出 主元，将子数组继续切分成三个更小的数组。</p>
<p>这里我们仅以 <code>less</code> 数组为例进行说明：</p>
<pre><code>[ 0, 3, 2, 1, 5, -1 ]</code></pre>
<p>此次我们选择的 主元 元素是位于中间的 <code>1</code>（当然选择 <code>2</code>也可以，无关紧要）。再次通过 主元 创建三个子数组：</p>
<pre><code>less:    [ 0, -1 ]
equal:   [ 1 ]
greater: [ 3, 2, 5 ]</code></pre>
<p>还没完，继续对 <code>less</code> and <code>greater</code> 数组递归调用 <code>quicksort()</code>。继续对 <code>less</code> 进行说明：</p>
<pre><code>[ 0, -1 ]</code></pre>
<p>选择 <code>-1</code>作为 主元。此时拆分后对子数组如下：</p>
<pre><code>less:    [ ]
equal:   [ -1 ]
greater: [ 0 ]</code></pre>
<p>因为已经没有比 <code>-1</code> 更小的数，所以<code>less</code> 数组为空；其它两个数组各包含一个数值。这意味着递归至此结束，我们可以继续对先前的 <code>greater</code> 进行排序了。</p>
<p><code>greater</code> 数组如下：</p>
<pre><code>[ 3, 2, 5 ]</code></pre>
<p>与先前相同：挑选位于中间的元素 <code>2</code> 作为 主元，并以此拆分为子数组：</p>
<pre><code>less:    [ ]
equal:   [ 2 ]
greater: [ 3, 5 ]</code></pre>
<p>注意，如果选择 <code>3</code> 作为 主元，那么直接就可以结束了。但是现在不得不继续对 <code>greater</code> 进行递归操作，以保证它是排好序的。这也是为什么选择一个好的 主元 至关重要。一旦你选择很多“糟糕”的 主元，那么快速排序将会变得很慢。 More on that below.</p>
<p>继续对 <code>greater</code> 拆分后发现：</p>
<pre><code>less:    [ 3 ]
equal:   [ 5 ]
greater: [ ]</code></pre>
<p>已经无法继续再分，递归至此已经结束。</p>
<p>这一处理过程会不断重复，直至所有的子数组都排好序。如下图：</p>
<p><img src="https://raw.githubusercontent.com/Dracarys/swift-algorithm-club/master/Quicksort/Images/Example.png" alt="Example"></p>
<p>注意到图中高亮的元素了吗，正是排好序的数组：</p>
<pre><code>[ -1, 0, 1, 2, 3, 5, 8, 8, 9, 10, 14, 26, 27 ]</code></pre>
<p>此图也表明了，<code>8</code> 是一个非常好的初始 主元，因为它也正好位于排好序后数组的中间位置。</p>
<p>希望这能让你对快速排序的原理有一个大致的了解。但不幸的是，因为我们对同一个数组调用了三次 <code>filter()</code>，所以这个快速排序并不怎么快。还有更好的方式对数组进行拆分。</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>围绕着主元对数组进行分割的操作被称为 <em>分治（Partitioning）</em>，有几种不同方案：</p>
<p>例如有如下数组：</p>
<pre><code>[ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]</code></pre>
<p>我们选择位于正中的元素 <code>8</code> 作为主元，对数组进行分治：</p>
<pre><code>[ 0, 3, 2, 1, 5, -1, 8, 8, 10, 9, 14, 27, 26 ]
  -----------------        -----------------
     所有元素 &lt; 8               所有元素 &gt; 8</code></pre>
<p>分治的关键在于，分治处理后主元恰好位于最终排好序后的位置上，其余元素则尚未排好序，只是简单地分置与主元两侧。快速排序正式（利用这一点）对数组不断进行分治操作，直至所有元素都位于正确的最终位置上。</p>
<p>在分治过程中，各个数值之间的相对顺序是无法保证的。所以在以 <code>8</code> 作为主元进行分治处理后，得到的数组也可能是这样的：</p>
<pre><code>[ 3, 0, 5, 2, -1, 1, 8, 8, 14, 26, 10, 27, 9 ]</code></pre>
<p>唯一可以保证的是，所有小于主元的数值全部位于左侧，而位于右侧的所有数值都大于它。但是由于分治处理会改变两个相等元素之间的原有顺序，所以快速排序不是一个稳定的排序算法（这一点与<a href="../Merge%20Sort/">归并排序（merge sort）</a>不同）。就大多数场景而言，这一点并不重要。</p>
<blockquote>
<p>稳定排序的意义：以淘宝商品列表为例，列表可以按价格、好评、卖家区域等条件排序，可单选，也可多选。如果排序算法不稳定，先按价格排序，之后在追加好评和买家等排序条件时，原来符合追加条件的价格相同的商品的先后顺序就可能发生变化，这显然不是我们想要的。而稳定的排序算法就没有该问题。</p>
</blockquote>
<h2 id="Lomuto-分治策略"><a href="#Lomuto-分治策略" class="headerlink" title="Lomuto 分治策略"></a>Lomuto 分治策略</h2><p>在第一个展示的例子中，由于是通过对 Swift  <code>filter()</code> 函数的三次调用来实现的分治处理，这导致（算法）不够高效。所以我们得找一个能<em>原位</em>操作，即直接修改原始数组的分治算法。</p>
<p>下面是一个 Lomuto 分治策略的 Swift 实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这也是《算法导论》中提到的第一个快排方案</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionLomuto</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = a[high]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = low</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> low..&lt;high &#123;</span><br><span class="line">    <span class="keyword">if</span> a[j] &lt;= pivot &#123;</span><br><span class="line">      (a[i], a[j]) = (a[j], a[i])</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  (a[i], a[high]) = (a[high], a[i])</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 playground 中的测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [ <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">8</span> ]</span><br><span class="line"><span class="keyword">let</span> p = partitionLomuto(&amp;list, low: <span class="number">0</span>, high: list.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">list  <span class="comment">// 显示结果</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>list</code> 必须是可变的 <code>var</code>，因为 <code>partitionLomuto()</code> 需要对数组（以 <code>inout</code> 参数传入）的内容进行直接修改。这样就比每次都创建一个新数组要高效多了。</p>
<p>为了避免每次都从头开始对整个数组进行分治处理，<code>low</code> 和 <code>high</code> 两个参数是必不可少的，只有限定了范围才能逐步缩小它。</p>
<p>先前我们使用位于数组正中位置的元素作为主元，而 Lomuto 算法则总是使用<em>末位</em>元素 <code>a[high]</code> 作为主元，认清这点差异非常关键。鉴于之前我们一直使用 <code>8</code> 作为主元，所以这次我们将 <code>8</code> 和 <code>26</code> 的位置进行交换，让 <code>8</code> 位于数组末尾，依然被选为主元。<br>Previously we used the middle array element as the pivot but it’s important to realize that the Lomuto algorithm always uses the <em>last</em> element, <code>a[high]</code>, for the pivot. Because we’ve been pivoting around <code>8</code> all this time, I swapped the positions of <code>8</code> and <code>26</code> in the example so that <code>8</code> is at the end of the array and is used as the pivot value here too.</p>
<blockquote>
<p>译者注：对这段有点糊涂，没理解到作者的初衷。</p>
</blockquote>
<p>分治处理后的数组：</p>
<pre><code>[ 0, 3, 2, 1, 5, 8, -1, 8, 9, 10, 14, 26, 27 ]
                        *</code></pre>
<p>变量 <code>p</code> 包含的是调用 <code>partitionLomuto()</code> 函数后的返回值 <code>7</code>。它是主元在新数组中的索引（以星号标记）。 </p>
<p>0 到 <code>p-1</code> 的 <code>[ 0, 3, 2, 1, 5, 8, -1 ]</code> 构成了左半边。<code>p+1</code> 到末尾的 <code>[ 9, 10, 14, 26, 27 ]</code> 构成了右半边 （此时右侧恰好已经排好序了）。</p>
<p>你可能已经注意到了一个比较有趣的情况…那就是 <code>8</code> 在数组中出现了不止一次。其中一个 <code>8</code> 并没有紧邻中间位于左半边的末位，所以这对 Lomuto 算法来说，是一个小小的不利，重复的元素越多，对于快速排序越不利。</p>
<p>那么 Lomuto 算法是如何运行的呢？关键就位于 <code>for</code> 循环。它将数组分成四个区域：</p>
<ol>
<li><code>a[low...i]</code> 所有 &lt;= 主元的元素</li>
<li><code>a[i+1...j-1]</code> 所有 &gt; 主元的元素</li>
<li><code>a[j...high-1]</code> 那些尚未查验的元素</li>
<li><code>a[high]</code> 主元</li>
</ol>
<blockquote>
<p>⚠️ <strong>译者注：</strong> 这里原作者表述有误，不是 for 循环将数组分成四部分，而是 <code>for + swap(i, high)</code> 将数组分成这四部分，否则你会发现起止索引对不上。</p>
</blockquote>
<p>分治拆分后的四个区域如下：</p>
<pre><code>[ values &lt;= pivot | values &gt; pivot | not looked at yet | pivot ]
  low           i   i+1        j-1   j          high-1   high</code></pre>
<p>循环会从 <code>low</code> 到 <code>high-1</code> 遍历查验每个元素，如果该元素的值小于等于主元，就通过交换将它移到第一个区域。</p>
<blockquote>
<p><strong>注意：</strong> 在 Swift 中，<code>(x, y) = (y, x)</code> 是对 <code>x</code> 和 <code>y</code> 进行交换的一个便利操作，与使用 <code>swap(&amp;x, &amp;y)</code> 是完全等价的。</p>
<p>译者注：与 <code>Array.swapAt(i, j)</code> 相比较，没感觉有任何优势。见仁见智吧！</p>
</blockquote>
<p>循环结束后，主元仍然位于数组的末位，所以我们需要将它与大于部分的首元素进行交换。此时主元正好位于小于等于与大于它的两部分的中间，数组的分治处理结束。</p>
<p>继续看例子。此时数组是这样的：</p>
<pre><code>[| 10, 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ]
   low                                       high
   i
   j</code></pre>
<p>初始时，从索引 0 到 11 为“未查验”区域，主元位于索引 12。由于查验尚未开始，所以 “values &lt;= pivot” 和 “values &gt; pivot” 的区域均为空。</p>
<p>看第一个元素，<code>10</code>。是否小于主元？否，跳至下一个元素。  </p>
<pre><code>[| 10 | 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ]
   low                                        high
   i
       j</code></pre>
<p>现在“未查看”区域变成了 1 到 11，”values &gt; pivot” 的区域也包含了一个数字 <code>10</code>，而 “values &lt;= pivot” 到区域依然为空。</p>
<p>在查看第二个数值，<code>0</code>。是否比主元小呢？是，那么将 <code>10</code> 和 <code>0</code> 进行交换，并且将 <code>i</code> 向前移动一位。</p>
<pre><code>[ 0 | 10 | 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ]
  low                                         high
      i
           j</code></pre>
<p>此时“未查验”区域变成了 2 到 11，”values &gt; pivot”的区域还是只包含 <code>10</code>，而”values &lt;= pivot”的区域则多了个 <code>0</code>。</p>
<p>继续查看第三个数值，<code>3</code>。比主元小，所以与 <code>10</code> 交换后得到：</p>
<pre><code>[ 0, 3 | 10 | 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ]
  low                                         high
         i
             j</code></pre>
<p>“values &lt;= pivot”的区域变成了 <code>[ 0, 3 ]</code>。继续查看…。<code>9</code> 比主元大，所以跳过：</p>
<pre><code>[ 0, 3 | 10, 9 | 2, 14, 26, 27, 1, 5, 8, -1 | 8 ]
  low                                         high
         i
                 j</code></pre>
<p>这是”values &gt; pivot”的区域变成了 <code>[ 10, 9 ]</code>。如果按此操作继续，那么最终结果会是：</p>
<pre><code>[ 0, 3, 2, 1, 5, 8, -1 | 27, 9, 10, 14, 26 | 8 ]
  low                                        high
                         i                   j</code></pre>
<p>还有最后一件事要做，那就是通过交换 <code>a[i]</code> 和 <code>a[high]</code>，将主元放回原位<br>The final thing to do is to put the pivot into place by swapping <code>a[i]</code> with <code>a[high]</code>:</p>
<pre><code>[ 0, 3, 2, 1, 5, 8, -1 | 8 | 9, 10, 14, 26, 27 ]
  low                                       high
                         i                  j</code></pre>
<p>此外还返回了 <code>i</code>，主元的索引。</p>
<blockquote>
<p><strong>注意：</strong> 如果你对该算法的工作原理还是不完全明白，那么我建议你到 playground 中亲自尝试一番，在循环过程中，仔细观察一下这四个区域是如何创建的。</p>
</blockquote>
<p>我们以此分治策略来构建一个快速排序。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksortLomuto</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">    <span class="keyword">let</span> p = partitionLomuto(&amp;a, low: low, high: high)</span><br><span class="line">    quicksortLomuto(&amp;a, low: low, high: p - <span class="number">1</span>)</span><br><span class="line">    quicksortLomuto(&amp;a, low: p + <span class="number">1</span>, high: high)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在是不是一下简单很多。我们首先调用 <code>partitionLomuto()</code> 函数，以数组的最后一个元素为主元，对数组进行重排。然后在对左右两部分递归调用<code>quicksortLomuto()</code>，进行排序。</p>
<p>测试一下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [ <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">8</span> ]</span><br><span class="line">quicksortLomuto(&amp;list, low: <span class="number">0</span>, high: list.<span class="built_in">count</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Lomuto 策略并不是唯一的分治策略，虽然与交换操作更少的 Hoare 分治策略相比，效率上略逊一筹，但它却是最容易理解的。</p>
<h2 id="Hoare-分治策略"><a href="#Hoare-分治策略" class="headerlink" title="Hoare 分治策略"></a>Hoare 分治策略</h2><p>该分治方案由快速算法的发明者 Hoare 创建。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionHoare</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = a[low]</span><br><span class="line">  <span class="keyword">var</span> i = low - <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> j = high + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">repeat</span> &#123; j -= <span class="number">1</span> &#125; <span class="keyword">while</span> a[j] &gt; pivot</span><br><span class="line">    <span class="keyword">repeat</span> &#123; i += <span class="number">1</span> &#125; <span class="keyword">while</span> a[i] &lt; pivot</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i &lt; j &#123;</span><br><span class="line">      a.swapAt(i, j)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>playground 测试代码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [ <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">26</span> ]</span><br><span class="line"><span class="keyword">let</span> p = partitionHoare(&amp;list, low: <span class="number">0</span>, high: list.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">list  <span class="comment">// show the results</span></span><br></pre></td></tr></table></figure>

<p>注意在 Hoare 方案中，总是以数组的<em>第一个</em>元素，<code>a[low]</code> 作为主元。同样，我们还是以 <code>8</code> 作为主元。</p>
<p>结果如下:</p>
<pre><code>[ -1, 0, 3, 8, 2, 5, 1, 27, 10, 14, 9, 8, 26 ]</code></pre>
<p>注意此次主元并没有位于正中。与 Lomuto 方案不同，返回值，即主元在新数组中的索引，并不是必须的。</p>
<p>数组将被分成  <code>[low...p]</code> 以及 <code>[p+1...high]</code> 两部分。例如，返回值 <code>p</code> 是 6，那么这两部分将分别是<code> [ -1, 0, 3, 8, 2, 5, 1 ]</code> 和 <code>[ 27, 10, 14, 9, 8, 26 ]</code>。</p>
<p>主元会位于其中的一个部分，但算法并没有指明是哪一个。如果数组内主元的值出现不止一次。那么在具体例子中，它既可能位于左半边，也可能位于右半边。</p>
<p>基于这点不同，Hoare 快速排序算法的实现也有些许差异：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksortHoare</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">    <span class="keyword">let</span> p = partitionHoare(&amp;a, low: low, high: high)</span><br><span class="line">    quicksortHoare(&amp;a, low: low, high: p)</span><br><span class="line">    quicksortHoare(&amp;a, low: p + <span class="number">1</span>, high: high)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 Hoare 分治策略的详细步骤，我就把它当作练习，留给各位读者了。 :-)</p>
<blockquote>
<p>译者注：练习时可以考虑下——在分治算法中，是否可以用 while 循环代替 repeat while 呢？</p>
</blockquote>
<h2 id="主元的选择"><a href="#主元的选择" class="headerlink" title="主元的选择"></a>主元的选择</h2><p>虽然 Lomuto 分治策略总是以末位元素作为主元，而 Hoare 策略则总是以首元素作为主元，但没有任何证据表明这么做有什么优势。</p>
<p>下面展示一下，如果选了一个糟糕的主元会如何。以如下数组为例：</p>
<pre><code>[ 7, 6, 5, 4, 3, 2, 1 ]</code></pre>
<p>采用 Lomuto 分治策略。主元为末位元素，<code>1</code>。经拆分，得到如下数组：</p>
<pre><code>   less than pivot: [ ]
    equal to pivot: [ 1 ]
greater than pivot: [ 7, 6, 5, 4, 3, 2 ]</code></pre>
<p>对“大于”部分递归，继续进行拆分：</p>
<pre><code>   less than pivot: [ ]
    equal to pivot: [ 2 ]
greater than pivot: [ 7, 6, 5, 4, 3 ]</code></pre>
<p>继续:</p>
<pre><code>   less than pivot: [ ]
    equal to pivot: [ 3 ]
greater than pivot: [ 7, 6, 5, 4 ]</code></pre>
<p>以此重复下去…</p>
<p>糟糕了，直接将快速排序降级成插入排序了。为了让快速排序更效率，（在分治过程中）需要尽可能的将数组进行平分。</p>
<p>在这个例子中，最优的主元应该是 <code>4</code>，这样可以得到：</p>
<pre><code>   less than pivot: [ 3, 2, 1 ]
    equal to pivot: [ 4 ]
greater than pivot: [ 7, 6, 5 ]</code></pre>
<p>那么是不是选择中间元素就一定比首末元素更好呢？试着看下这个例子：</p>
<pre><code>[ 7, 6, 5, 1, 4, 3, 2 ]</code></pre>
<p>此时中间元素是 <code>1</code>，如果以它为主元，那么得到结果会跟之前的例子一样糟糕。</p>
<p>理想的主元应该是待分数组的<em>中位数</em>，也就是位于有序数组正中的那个元素。然而，排序之前，你又不可能知道。所以这有点像先有鸡还是先有蛋的问题。尽管如此，我们还有一些技巧可以选择一个相对较好的主元。</p>
<p>其中一个技巧是，取“三元素的中位数”，即子数组首、中、末三个元素的中位数。理论上而言，它通常是最接近真实中位数的。</p>
<p>另一个常见的解决方案是随机选择主元。虽然有时选中的主元不怎么理想，但平均而言，这是一个非常不错的选择。</p>
<p>下面是一个通过随机方式挑选主元的快速排序算法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksortRandom</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = random(<span class="built_in">min</span>: low, <span class="built_in">max</span>: high)         <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    (a[pivotIndex], a[high]) = (a[high], a[pivotIndex])  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p = partitionLomuto(&amp;a, low: low, high: high)</span><br><span class="line">    quicksortRandom(&amp;a, low: low, high: p - <span class="number">1</span>)</span><br><span class="line">    quicksortRandom(&amp;a, low: p + <span class="number">1</span>, high: high)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前相比有两点重要区别：</p>
<ol>
<li><code>random(min:max:)</code> 函数会返回一个位于 <code>min...max</code> 区间内的整数，作为主元的索引。</li>
<li>由于 Lomuto 分治策略总是以 <code>a[high]</code> 作为主元，所以在调用 <code>partitionLomuto()</code> 之前，我们先对<code>a[pivotIndex]</code> 和 <code>a[high]</code> 进行交换，以便将主元放置末位。</li>
</ol>
<p>虽然在排序算法中使用随机数有点怪，但为让快速排序在所有情况下都相对高效，这一操作就是必不可少的。一个糟糕的主元可以让快速排序的时间复杂度飙至 **O(n^2)**，而如果你借助来随机数生成器，通常都能选择一个较好的主元，那么它的时间复杂度就会变为 **O(n log n)**，这样的排序算法就相当不错了。</p>
<h2 id="荷兰旗分治法（Dutch-national-flag-partitioning）"><a href="#荷兰旗分治法（Dutch-national-flag-partitioning）" class="headerlink" title="荷兰旗分治法（Dutch national flag partitioning）"></a>荷兰旗分治法（Dutch national flag partitioning）</h2><p>算法仍有改进的余地！在第一个展示的例子中，数组最终被分治成如下样式：</p>
<pre><code>[ values &lt; pivot | values equal to pivot | values &gt; pivot ]</code></pre>
<p>But as you’ve seen with the Lomuto partitioning scheme, if the pivot occurs more than once the duplicates end up in the left half. And with Hoare’s scheme the pivot can be all over the place. 面对此种情况的解决方案就是“荷兰旗分治策略”，这个名字源自<a href="https://en.wikipedia.org/wiki/Flag_of_the_Netherlands">荷兰国旗</a>由三部分构成，就像我们也要将数组分成三部分一样。</p>
<p>该分治策略的代码实现如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionDutchFlag</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int, pivotIndex: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = a[pivotIndex]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> smaller = low</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">equal</span> = low</span><br><span class="line">  <span class="keyword">var</span> larger = high</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">equal</span> &lt;= larger &#123;</span><br><span class="line">    <span class="keyword">if</span> a[<span class="built_in">equal</span>] &lt; pivot &#123;</span><br><span class="line">      <span class="built_in">swap</span>(&amp;a, smaller, <span class="built_in">equal</span>)</span><br><span class="line">      smaller += <span class="number">1</span></span><br><span class="line">      <span class="built_in">equal</span> += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a[<span class="built_in">equal</span>] == pivot &#123;</span><br><span class="line">      <span class="built_in">equal</span> += <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">swap</span>(&amp;a, <span class="built_in">equal</span>, larger)</span><br><span class="line">      larger -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (smaller, larger)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在工作原理上，它除了与 Lomuto 分治策略中将数组分成的四个区域不同外，其它非常类似：</p>
<ul>
<li><code>[low ... smaller-1]</code> 包含所有 values &lt; pivot</li>
<li><code>[smaller ... equal-1]</code> 包含所有 values == pivot</li>
<li><code>[equal ... larger]</code> 包含所有 values &gt; pivot</li>
<li><code>[larger ... high]</code> 尚未查验的数值</li>
</ul>
<p>注意，它并不假定 <code>a[high]</code> 为主元，相反，你必须传入一个欲将其作为主元的元素的索引。</p>
<p>一个应用的例子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [ <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">26</span> ]</span><br><span class="line">partitionDutchFlag(&amp;list, low: <span class="number">0</span>, high: list.<span class="built_in">count</span> - <span class="number">1</span>, pivotIndex: <span class="number">10</span>)</span><br><span class="line">list  <span class="comment">// show the results</span></span><br></pre></td></tr></table></figure>

<p>为了好玩，这里我们给出另一个 <code>8</code> 的索引。如下：</p>
<pre><code>[ -1, 0, 3, 2, 5, 1, 8, 8, 27, 14, 9, 26, 10 ]</code></pre>
<p>注意两个 <code>8</code> 此时在数组中的位置。<code>partitionDutchFlag()</code> 的返回值是一个元组，<code>(6, 7)</code>。正好是主元在数组中的索引范围。</p>
<p>怎么在快速排序中应用呢：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksortDutchFlag</span>&lt;T: Comparable&gt;<span class="params">(<span class="keyword">_</span> a: <span class="keyword">inout</span> [T], low: Int, high: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = random(<span class="built_in">min</span>: low, <span class="built_in">max</span>: high)</span><br><span class="line">    <span class="keyword">let</span> (p, q) = partitionDutchFlag(&amp;a, low: low, high: high, pivotIndex: pivotIndex)</span><br><span class="line">    quicksortDutchFlag(&amp;a, low: low, high: p - <span class="number">1</span>)</span><br><span class="line">    quicksortDutchFlag(&amp;a, low: q + <span class="number">1</span>, high: high)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组中包含多个重复元素，使用荷兰国旗分治策略可以让快速排序更高效。（绝对不是因为我是荷兰人，才这么说哦）</p>
<blockquote>
<p><strong>注意：</strong> 上面给出的 <code>partitionDutchFlag()</code> 实现中，使用了自定义的 <code>swap()</code> 例程，来交换两种数组中的元素。与 Swift 自带的 <code>swap()</code> 不同，当两个索引指向同一个数组的元素时，它不会报错。 详情参见 <a href="Quicksort.swift">Quicksort.swift</a> 代码</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>该系列文章翻译自 <a href="https://www.raywenderlich.com/">Raywenderlich</a> 的开源项目：<a href="https://github.com/raywenderlich/swift-algorithm-club">swift-algorithm-club</a>。受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort on Wikipedia</a></p>
<p><em>由 Matthijs Hollemans 为 Swift 算法社区撰写</em></p>
<p><em>由 William Han 翻译</em></p>
]]></content>
      <categories>
        <category>Algorithm club</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】高仿Uber启动页</title>
    <url>/2016/08/02/How-to-create-an-Uber-splash-screen/</url>
    <content><![CDATA[<p>一个好的溅落式启动页（别被毫无动画效果的静态启动页迷惑），使开发人员有机会在展示动画期间，从后端获取必要的数据。同时它在应用启动期间让用户始终保持高昂兴趣方面也发挥了重要作用。</p>
<p>虽然溅落式启动页已广泛存在，但是你很难找到一个如Uber这般出色的。在2016年的首季，Uber释出一个由CEO领导的品牌重塑战略，品牌重塑的成果之一，便是一个非常炫酷的溅落式启动页。</p>
<a id="more"></a>

<p>本文以仿制Uber启动动画为目标。其中运用了大量的<strong>CAlayer</strong>和<strong>CAAnimation</strong>类，及其相应子类。相对于概念介绍，本文更着重于如何运用这些类去实现一个产品级的动画效果。如需了解动画背后的相关知识，请访问 <em>Marin Todorov</em> 的系列视频教程：<br><a href="https://www.raywenderlich.com/u/icanzilb"><strong>Intermediate iOS Animation</strong></a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>鉴于本文涉及的动画众多，这里提供一个已为后续动画创建好所有CALayer的<a href="https://koenig-media.raywenderlich.com/uploads/2016/06/Fuber-starter.zip">起始工程</a>。</p>
<p>起始工程是一个叫做Fuber的应用，Fuber提供（Segway）驾乘共享服务，乘客通过向Segway驾驶员发出请求，来邀请其搭载自己抵达城市的任何地方。Fuber发展迅速，已在60多个国家为用户提供服务，但也面临众多国家的反对和工会要求其必须与司机签订合同的问题。:](原作者卖萌了)</p>
<center>![Splash screen](https://koenig-media.raywenderlich.com/uploads/2016/05/fuber_logo.png)</center>

<p>最终，我们会创建一个如下的非常炫酷的溅落式启动页:</p>
<center>![Fuber Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/Fuber-Animation.gif)</center>

<p>打开并运行起始工程，简单浏览一下工程结构。</p>
<p>首先从视图控制器开始，应用通过负责子视图（切入）切出任务的<strong>RootContainerViewController</strong>加载<strong>SplashViewController</strong>。父视图控制器从启动页开始运行，直至应用的所有准备工作全部完成。这期间应用会连接到后端，获取后续所需数据。需要指出的是，在这个简单的项目中启动页被设计成了一个独立的模块。</p>
<p>在<strong>RootContainerViewController</strong>中已经实现好了两个方法：<code>showSplashViewController()</code>和 <code>showSplashViewControllerNoPing()</code>。<br>由于教程中大部分时间，都在调用<code>showSplashViewControllerNoPing()</code>方法（调试启动动画），所以我们先将精力放在<strong>SplashViewController</strong>的子视图动画创建上，然后在通过<code>showSplashViewController()</code>模拟一个访问API的延迟效果，并随即跳转到主视图控制器。</p>
<h2 id="溅落式启动页视图及其图层结构"><a href="#溅落式启动页视图及其图层结构" class="headerlink" title="溅落式启动页视图及其图层结构"></a>溅落式启动页视图及其图层结构</h2><p><strong>SplashViewController</strong>的视图（view）包含两个子视图（subview）。 第一个子视图是用于构成波纹网格背景的<strong>TileGridview</strong>，它包含了一系列按网格排列的<strong>TileView</strong>实例。另一个子视图名为<strong>AnimatedULogoView</strong>，它构成了 U 字型的动画图标。</p>
<center>![Splash Screen](https://koenig-media.raywenderlich.com/uploads/2016/05/Fuber-View-Hierarchy-1.png)</center>

<p><strong>AnimatedULogoView</strong>包含4个<strong>CAShapeLayer</strong>:</p>
<ul>
<li><strong>circleLayer</strong> 用于实现字母 U 的白色背景</li>
<li><strong>lineLayer</strong> 用于实现从<strong>circleLayer</strong>的中心到边缘的一条线段</li>
<li><strong>squareLayer</strong> 用于实现位于<strong>circleLayer</strong>中心位置的方块</li>
<li><strong>maskLayer</strong> 用作视图遮罩，通过改变其<strong>bounds</strong>的动画效果，来将其它所有图层的动画效果整齐划一地混合起来。</li>
</ul>
<p>通过组合这几个<strong>CAShaperLayer</strong>动画，共同实现了<strong>Fuber</strong>中字母 <strong>U</strong> 的动画效果。</p>
<center>![RiderIconView](https://koenig-media.raywenderlich.com/uploads/2016/05/RiderIconView.gif)</center>

<p>了解了图层的构成之后，接下来我们就来添加一些动画让<strong>AnimatedULogoView</strong>动起来吧。</p>
<h2 id="让圆形动起来"><a href="#让圆形动起来" class="headerlink" title="让圆形动起来"></a>让圆形动起来</h2><p>创建复杂动画的关键，在于排除视觉干扰专注于我们正在实现的部分。 打开<strong>AnimatedULogoView.swift</strong>文件。找到<code>init(frame:)</code>方法，注释掉除<strong>circleLayer</strong>外其它向视图中添加子图层（sublayer）的方法，完成动画后会再将其全部添加回来。注释完成后的代码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">circleLayer = generateCircleLayer()</span><br><span class="line">lineLayer = generateLineLayer()</span><br><span class="line">squareLayer = generateSquareLayer()</span><br><span class="line">maskLayer = generateMaskLayer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  layer.mask = maskLayer</span></span><br><span class="line">layer.addSublayer(circleLayer)</span><br><span class="line"><span class="comment">//  layer.addSublayer(lineLayer)</span></span><br><span class="line"><span class="comment">//  layer.addSublayer(squareLayer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到<code>generateCircleLayer()</code>方法，了解下圆形是如何被创建的。其实只是简单地通过 <em>UIBezierPath</em> 创建了一个 <em>CAShapeLayer</em> (图层)。 注意看这行代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.path = <span class="type">UIBezierPath</span>(arcCenter: <span class="type">CGPointZero</span>, </span><br><span class="line">radius: radius/<span class="number">2</span>, </span><br><span class="line">startAngle: -<span class="type">CGFloat</span>(<span class="type">M_PI_2</span>), </span><br><span class="line">endAngle: <span class="type">CGFloat</span>(<span class="number">3</span>*<span class="type">M_PI_2</span>),</span><br><span class="line">clockwise: <span class="literal">true</span>).<span class="type">CGPath</span></span><br></pre></td></tr></table></figure>

<p>向 <em>startAngle</em> 传入 0 或使用默认值, 弧线会从右侧（3点钟位置）开始。传入 <strong>-M_PI_2</strong> 即 -90度, 则会从顶部开始，如果 <em>endAngle</em> 恰好是270度即 *<em>3 * M_PI_2*</em>，弧线则再次回到顶点（形成一个圆形）。注意为了绘制的动画效果，我们使用圆形的半径作为<strong>lineWidth</strong>。</p>
<p><strong>circleLayer</strong>的动画需要三个<strong>CAAnimation</strong>子类来实现：一个作用于<strong>stokeEnd</strong>的<strong>CAKeyframeAnimation</strong>动画，一个作用于<strong>transform</strong>的<strong>CABasicAnimation</strong>动画，和一个负责将两部分动画组合起来的<strong>CAAnimationGroup</strong>。这将一次性同时创建所有动画。</p>
<p>在事先写好的<code>animateCircleLayer()</code>方法中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strokeEnd</span></span><br><span class="line"><span class="keyword">let</span> strokeEndAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;strokeEnd&quot;</span>)</span><br><span class="line">strokeEndAnimation.timingFunction = strokeEndTimingFunction</span><br><span class="line">strokeEndAnimation.duration = kAnimationDuration - kAnimationDurationDelay</span><br><span class="line">strokeEndAnimation.values = [<span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">strokeEndAnimation.keyTimes = [<span class="number">0.0</span>, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure>

<p>通过向动画的<strong>Values</strong>属性提供的 0.0 和 1.0，我们便透过Core Animation框架生成了一个从 <em>startAngle</em> 到 <em>endAngle</em> 沿顺时针旋转的动画。随着 <em>strokeEnd</em> 属性值的增加，弧线沿着圆周慢慢伸展，圆形也渐渐被”填满”。在这个例子中，如果我们将<strong>values</strong>属性的值设为[0.0, 0.5]，则仅会画半个圆，这是因为 <em>StrokeEnd</em> 在动画结束时刚达好到圆周的一半。</p>
<blockquote>
<p>译者注：“圆形也渐渐被‘填满’”一句的填满是引起来的，并不是真的被填满，而是描边的 <em>lineWidth</em> 与圆形半径相同，从而产生了填满的视觉效果。可参考<code>generateCircleLayer()</code>方法中<code>layer.fillColor = UIColor.clear.cgColor</code>这段代码，事实上填充色被设置为透明，</p>
</blockquote>
<p>现在添加形变（transform）动画:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transform</span></span><br><span class="line"><span class="keyword">let</span> transformAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;transform&quot;</span>)</span><br><span class="line">transformAnimation.timingFunction = strokeEndTimingFunction</span><br><span class="line">transformAnimation.duration = kAnimationDuration - kAnimationDurationDelay</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> startingTransform = <span class="type">CATransform3DMakeRotation</span>(-<span class="type">CGFloat</span>(<span class="type">M_PI_4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">startingTransform = <span class="type">CATransform3DScale</span>(startingTransform, <span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">1</span>)</span><br><span class="line">transformAnimation.fromValue = <span class="type">NSValue</span>(<span class="type">CATransform3D</span>: startingTransform)</span><br><span class="line">transformAnimation.toValue = <span class="type">NSValue</span>(<span class="type">CATransform3D</span>: <span class="type">CATransform3DIdentity</span>)</span><br></pre></td></tr></table></figure>

<p>该动画同时实现了放大和沿 Z 轴旋转的两个形变。这使得圆形在沿顺时针旋转45度的同时逐渐变大。这里的旋转很重要，因为圆形的旋转要与<strong>lineLayer</strong>和其它图层一块动起来时的位置和速度保持一致。</p>
<p>最后在<code>animateCircleLayer()</code>方法的最下面添加一个<strong>CAAnimationGroup</strong>。这个动画组将包含之前的两个动画，这样我们仅向<strong>circleLayer</strong>图层添加一次动画即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group</span></span><br><span class="line"><span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">groupAnimation.animations = [strokeEndAnimation, transformAnimation]</span><br><span class="line">groupAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">groupAnimation.duration = kAnimationDuration</span><br><span class="line">groupAnimation.beginTime = beginTime</span><br><span class="line">groupAnimation.timeOffset = startTimeOffset</span><br><span class="line"></span><br><span class="line">circleLayer.addAnimation(groupAnimation, forKey: <span class="string">&quot;looping&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们修改了CAAnimationGroup的两个重要属性：<strong>beginTime</strong> 和 <strong>timeOffset</strong>。如果你对其中任何一个不熟悉，那么你都可以在<a href="http://ronnqvi.st/controlling-animation-timing/">这里</a>找到关于该属性的介绍和使用说明。<br>将 <strong>groupAnimation</strong> 的 <strong>beginTime</strong> 设置为与父视图相同。</p>
<p>对<strong>timeOffeset</strong>的设置是必要的，因为动画首次运行时实际上是从一半开始的。当完成更多动画效果后，你可以试着改变<strong>startTimeOffset</strong>的值，并观察动画在视觉效果上的不同。 </p>
<p>将动画组添加到<strong>circleLayer</strong>之后，编译并运行应用，检查下动画效果.</p>
<center>![Splash Screen CircleIn Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/CircleIn-Animation.gif)</center>

<blockquote>
<p>注意: 试着删除<strong>groupAnimation.animations</strong>数组中的<strong>strokeEndAnimation</strong>或<strong>transformAnimation</strong>，以确认每个动画具体实现了哪些视觉效果. 可以按该方法再去验证一下文中的其它动画，你会惊讶于，仅仅改变动画的组合方式就可以产生如此令人难以预料的独特视觉效果.</p>
</blockquote>
<h2 id="让线段动起来"><a href="#让线段动起来" class="headerlink" title="让线段动起来"></a>让线段动起来</h2><p>完成了<strong>circleLayer</strong>的动画, 接下来我们再来完成<strong>lineLayer</strong>动画。还是在 <strong>AnimatedULogoView.swift</strong>文件中, 找到<code>startAnimating()</code>方法并注释掉除<code>animateLineLayer()</code>外的所有动画调用。注释后的代码如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">startAnimating</span><span class="params">()</span></span> &#123;</span><br><span class="line">beginTime = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">layer.anchorPoint = <span class="type">CGPointZero</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  animateMaskLayer()</span></span><br><span class="line"><span class="comment">//  animateCircleLayer()</span></span><br><span class="line">animateLineLayer()</span><br><span class="line"><span class="comment">//  animateSquareLayer()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外, 修改<code>init(frame:)</code>方法中的代码，只显示<strong>circleLayer</strong>和<strong>lineLayer</strong>两个图层:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">circleLayer = generateCircleLayer()</span><br><span class="line">lineLayer = generateLineLayer()</span><br><span class="line">squareLayer = generateSquareLayer()</span><br><span class="line">maskLayer = generateMaskLayer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  layer.mask = maskLayer</span></span><br><span class="line">layer.addSublayer(circleLayer)</span><br><span class="line">layer.addSublayer(lineLayer)</span><br><span class="line"><span class="comment">//  layer.addSublayer(squareLayer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉图层和动画后, 转到<code>animateLineLayer()</code>方法并实现下面这组动画:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lineWidth</span></span><br><span class="line"><span class="keyword">let</span> lineWidthAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;lineWidth&quot;</span>)</span><br><span class="line">lineWidthAnimation.values = [<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>]</span><br><span class="line">lineWidthAnimation.timingFunctions = [strokeEndTimingFunction, circleLayerTimingFunction]</span><br><span class="line">lineWidthAnimation.duration = kAnimationDuration</span><br><span class="line"><span class="comment">// Swift 3.0 keyTimes是一个NSNumber数组</span></span><br><span class="line">lineWidthAnimation.keyTimes = [<span class="number">0.0</span>, <span class="number">1.0</span>-kAnimationDurationDelay/kAnimationDuration, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure>

<p>该动画会使<strong>lineLayer</strong>的宽度（width）呈现出先增后减的效果。</p>
<p>再为接下来的动画添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transform</span></span><br><span class="line"><span class="keyword">let</span> transformAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;transform&quot;</span>)</span><br><span class="line">transformAnimation.timingFunctions = [strokeEndTimingFunction, circleLayerTimingFunction]</span><br><span class="line">transformAnimation.duration = kAnimationDuration</span><br><span class="line">transformAnimation.keyTimes = [<span class="number">0.0</span>, <span class="number">1.0</span>-kAnimationDurationDelay/kAnimationDuration, <span class="number">1.0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transform = <span class="type">CATransform3DMakeRotation</span>(-<span class="type">CGFloat</span>(<span class="type">M_PI_4</span>), <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">transform = <span class="type">CATransform3DScale</span>(transform, <span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">1.0</span>)</span><br><span class="line">transformAnimation.values = [<span class="type">NSValue</span>(<span class="type">CATransform3D</span>: transform),</span><br><span class="line"><span class="type">NSValue</span>(<span class="type">CATransform3D</span>: <span class="type">CATransform3DIdentity</span>),</span><br><span class="line"><span class="type">NSValue</span>(<span class="type">CATransform3D</span>: <span class="type">CATransform3DMakeScale</span>(<span class="number">0.15</span>, <span class="number">0.15</span>, <span class="number">1.0</span>))]</span><br></pre></td></tr></table></figure>

<p>与<strong>circleLayer</strong>的形变动画非常相似, 这里我们定义了个一个沿 Z 轴顺时针旋转的动画。 此外我们还为线段添加了一个先缩小到25%，再恢复到原有尺寸，最后再缩小到15%的形变动画.</p>
<p>通过<strong>CAAnimationGroup</strong>将动画组合起来，并添加到<strong>lineLayer</strong>上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group</span></span><br><span class="line"><span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">groupAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">groupAnimation.removedOnCompletion = <span class="literal">false</span></span><br><span class="line">groupAnimation.duration = kAnimationDuration</span><br><span class="line">groupAnimation.beginTime = beginTime</span><br><span class="line">groupAnimation.animations = [lineWidthAnimation, transformAnimation]</span><br><span class="line">groupAnimation.timeOffset = startTimeOffset</span><br><span class="line"></span><br><span class="line">lineLayer.addAnimation(groupAnimation, forKey: <span class="string">&quot;looping&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>编译并运行，注意观察变化.</p>
<center>![Splash Screen Knockoutline Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/Knockoutline-Animation.gif)</center>

<p>注意我们设置了相同的初始形变值**-M_PI_4<strong>，以便线段（line）和圆形（circle）在绘制时能对齐。为此我们还将</strong>keyTimes** 设置为<code>[0.0, 1.0-kAnimationDurationDelay/kAnimationDuration, 1.0]</code>。 数组中首尾两个元素是确定的: 0 代表动画开始那一刻，1.0 代表动画结束那一刻，然后通过计算来获取圆形绘制刚刚结束、第二部分的动画即将开始时的那一刻。由于它是一个延迟的动画效果，所以我们还需要从 1.0 中减去通过<strong>kAnimationDurationDelay</strong>除以<strong>kAnimationDuration</strong>而得到的确切百分比，这是因为我们想让动画在结束后的延迟过程中再返回到起点。（译者：形成一个循环动画，否则会出现跳跃，致使动画不连贯）</p>
<p><strong>circleLayer</strong>和<strong>lineLayer</strong>动画都已完成，接下来我们该完成中间的方块动画了。</p>
<h2 id="让方块动起来"><a href="#让方块动起来" class="headerlink" title="让方块动起来"></a>让方块动起来</h2><p>与之前类似。 在<code>startAnimating()</code>函数中注释掉除<code>animateSquareLayer</code>外的其它动画方法调用。然后在像下面这样修改<code>init(frame:)</code>方法的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">circleLayer = generateCircleLayer()</span><br><span class="line">lineLayer = generateLineLayer()</span><br><span class="line">squareLayer = generateSquareLayer()</span><br><span class="line">maskLayer = generateMaskLayer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  layer.mask = maskLayer</span></span><br><span class="line">layer.addSublayer(circleLayer)</span><br><span class="line"><span class="comment">//  layer.addSublayer(lineLayer)</span></span><br><span class="line">layer.addSublayer(squareLayer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成后转到<code>animateSquareLayer()</code>方法实现如下动画代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bounds</span></span><br><span class="line"><span class="keyword">let</span> b1 = <span class="type">NSValue</span>(<span class="type">CGRect</span>: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: <span class="number">2.0</span>/<span class="number">3.0</span> * squareLayerLength, height: <span class="number">2.0</span>/<span class="number">3.0</span>  * squareLayerLength))</span><br><span class="line"><span class="keyword">let</span> b2 = <span class="type">NSValue</span>(<span class="type">CGRect</span>: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: squareLayerLength, height: squareLayerLength))</span><br><span class="line"><span class="keyword">let</span> b3 = <span class="type">NSValue</span>(<span class="type">CGRect</span>: <span class="type">CGRectZero</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boundsAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;bounds&quot;</span>)</span><br><span class="line">boundsAnimation.values = [b1, b2, b3]</span><br><span class="line">boundsAnimation.timingFunctions = [fadeInSquareTimingFunction, squareLayerTimingFunction]</span><br><span class="line">boundsAnimation.duration = kAnimationDuration</span><br><span class="line">boundsAnimation.keyTimes = [<span class="number">0</span>, <span class="number">1.0</span>-kAnimationDurationDelay/kAnimationDuration, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure>

<p>这一部分动画用于改变<strong>CALayer</strong>的大小（bounds）。创建一个先将其边长缩小到2/3，再恢复，最终在缩小到零的关键帧动画。</p>
<p>接下来，为背景色添加动画效果:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// backgroundColor</span></span><br><span class="line"><span class="keyword">let</span> backgroundColorAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;backgroundColor&quot;</span>)</span><br><span class="line">backgroundColorAnimation.fromValue = <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span></span><br><span class="line">backgroundColorAnimation.toValue = <span class="type">UIColor</span>.fuberBlue().<span class="type">CGColor</span></span><br><span class="line">backgroundColorAnimation.timingFunction = squareLayerTimingFunction</span><br><span class="line">backgroundColorAnimation.fillMode = kCAFillModeBoth</span><br><span class="line">backgroundColorAnimation.beginTime = kAnimationDurationDelay * <span class="number">2.0</span> / kAnimationDuration</span><br><span class="line">backgroundColorAnimation.duration = kAnimationDuration / (kAnimationDuration - kAnimationDurationDelay)</span><br></pre></td></tr></table></figure>

<p>注意上面的<strong>fillMode</strong>属性。一旦<strong>beginTime</strong>不为零时, 动画就会在起始点和结束点保持住当前颜色（CGColor）。这避免了动画在被添加到父CAAnimationGroup时出现闪烁。（译者：这里译的不好:(。请试着改变该属性的设置，看看视觉效果上有什么不同，以加深理解。）</p>
<p>了解了这些，我们就动手来实现一下吧:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group</span></span><br><span class="line"><span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">groupAnimation.animations = [boundsAnimation, backgroundColorAnimation]</span><br><span class="line">groupAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">groupAnimation.duration = kAnimationDuration</span><br><span class="line">groupAnimation.removedOnCompletion = <span class="literal">false</span></span><br><span class="line">groupAnimation.beginTime = beginTime</span><br><span class="line">groupAnimation.timeOffset = startTimeOffset</span><br><span class="line">squareLayer.addAnimation(groupAnimation, forKey: <span class="string">&quot;looping&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>编译并运行检查动画效果。注意观察方块的变化。</p>
<center>![Splash Screen Tutorial](https://koenig-media.raywenderlich.com/uploads/2016/05/KnockoutSquare-Animation.gif)</center>

<p>现在将所有的动画组合起来看看效果如何！</p>
<blockquote>
<p>注意: 在电脑的GPU完成对iOS设备的模拟任务前，模拟器上的动画可能会有那么一点小抽。如果你的电脑带不动动画，可以试着将模拟器窗口调小或者转到真机开发。</p>
</blockquote>
<h2 id="遮罩"><a href="#遮罩" class="headerlink" title="遮罩"></a>遮罩</h2><p>首先，取消<code>init(frame:)</code>方法中对所有添加图层方法的注释，以及<code>startAnimating()</code>方法中对所有动画调用的注释.</p>
<p>组合好所有动画后，再次编译并运行。</p>
<center>![PreMask Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/PreMask-Animation.gif)</center>

<p>看上去还是有点怪怪的，是不是？圆形在缩小时，它的边缘会有一个小跳跃。幸运地是, 遮罩动画可以解决该问题，让所有子图动画平滑整齐划一.</p>
<p>转到｀animateMaskLayer()｀方法并添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bounds</span></span><br><span class="line"><span class="keyword">let</span> boundsAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;bounds&quot;</span>)</span><br><span class="line">boundsAnimation.fromValue = <span class="type">NSValue</span>(<span class="type">CGRect</span>: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, </span><br><span class="line">y: <span class="number">0.0</span>, </span><br><span class="line">width: radius * <span class="number">2.0</span>, </span><br><span class="line">height: radius * <span class="number">2</span>))</span><br><span class="line">boundsAnimation.toValue = <span class="type">NSValue</span>(<span class="type">CGRect</span>: <span class="type">CGRect</span>(x: <span class="number">0.0</span>, </span><br><span class="line">y: <span class="number">0.0</span>, </span><br><span class="line">width: <span class="number">2.0</span>/<span class="number">3.0</span> * squareLayerLength,</span><br><span class="line">height: <span class="number">2.0</span>/<span class="number">3.0</span> * squareLayerLength))</span><br><span class="line">boundsAnimation.duration = kAnimationDurationDelay</span><br><span class="line">boundsAnimation.beginTime = kAnimationDuration - kAnimationDurationDelay</span><br><span class="line">boundsAnimation.timingFunction = circleLayerTimingFunction</span><br></pre></td></tr></table></figure>

<p>这是一个边界(bounds)动画。记住，由于这是一个应用于所有子图层的遮罩，当边界发生变化时, 整个<strong>AnimatedULogoView</strong>都将消失，直至遮罩被应用到所有子图层。</p>
<p>现在在添加一个让方块变圆的圆角动画:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cornerRadius</span></span><br><span class="line"><span class="keyword">let</span> cornerRadiusAnimation = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">&quot;cornerRadius&quot;</span>)</span><br><span class="line">cornerRadiusAnimation.beginTime = kAnimationDuration - kAnimationDurationDelay</span><br><span class="line">cornerRadiusAnimation.duration = kAnimationDurationDelay</span><br><span class="line">cornerRadiusAnimation.fromValue = radius</span><br><span class="line">cornerRadiusAnimation.toValue = <span class="number">2</span></span><br><span class="line">cornerRadiusAnimation.timingFunction = circleLayerTimingFunction</span><br></pre></td></tr></table></figure>

<p>将这两个动画添加到一个<strong>CAAnimationGroup</strong>中，以完成这个图层（的所有动画）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group</span></span><br><span class="line"><span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">groupAnimation.removedOnCompletion = <span class="literal">false</span></span><br><span class="line">groupAnimation.fillMode = kCAFillModeBoth</span><br><span class="line">groupAnimation.beginTime = beginTime</span><br><span class="line">groupAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">groupAnimation.duration = kAnimationDuration</span><br><span class="line">groupAnimation.animations = [boundsAnimation, cornerRadiusAnimation]</span><br><span class="line">groupAnimation.timeOffset = startTimeOffset</span><br><span class="line">maskLayer.addAnimation(groupAnimation, forKey: <span class="string">&quot;looping&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>编译并运行。</p>
<center>![RiderIconView Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/RiderIconView-Animation.gif)</center>

<p>看起来好多了！</p>
<h2 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h2><p>试想一下有一系列以<strong>TileGridView</strong>实例的方式来移动的 _UIView_。 它们看起来会是什么样呢？呃。。。这里就不引用<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%EF%BC%9A%E5%85%89%E9%80%9F%E6%88%B0%E8%A8%98">创</a>并展开说明了！（译者：《创》是一部科幻电影。这里翻译的不好，见谅！）</p>
<p>网格背景由一些列附加到<strong>TileGridView</strong>类的<strong>TileView</strong>组成。为了便于从视觉上理解这个概念, 我们打开<strong>TileView.swift</strong>文件，找到<code>init(frame:)</code>方法，在方法的最后添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">layer.borderWidth = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>编译并运行应用。</p>
<center>![Fuber-Grid-View](https://koenig-media.raywenderlich.com/uploads/2016/05/Fuber-Grid-View-180x320.png)</center>

<p>如果你所见，<strong>TileView</strong>被整齐地排成一张网格。整个创建逻辑都集中在<strong>TileGridView.swift</strong>文件的<code>renderTileViews()</code>方法内。幸运的是，我们所需的布局逻辑（起始工程）已经实现好。接下来要做的就是让它动起来!</p>
<h2 id="让瓦片视图（TileView）动起来"><a href="#让瓦片视图（TileView）动起来" class="headerlink" title="让瓦片视图（TileView）动起来"></a>让瓦片视图（TileView）动起来</h2><p><strong>TileGridView</strong>仅有一个直接的子视图（subview）<strong>containerView</strong>。它负责添加所有的<strong>TileView</strong>。 此外，还有一个名为<strong>tileViewRows</strong>的属性, 它是一个二维数组，包含所有添加到containerView中的<strong>TileView</strong>。</p>
<p>回到<strong>TileView</strong>中的<code>init(frame:)</code>方法. 删除我们刚才添加的用于显示边界的代码，并取消向图层中添加<strong>chimeSplashImage</strong>方法的注释。完成后的方法如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line"><span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">layer.contents = <span class="type">TileView</span>.chimesSplashImage.<span class="type">CGImage</span></span><br><span class="line">layer.shouldRasterize = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行。</p>
<center>![Grid Starting](https://koenig-media.raywenderlich.com/uploads/2016/05/Grid-Starting.gif)</center>

<p>酷。。。。我们就要大功告成了。</p>
<p>然而，<strong>TileGridView</strong>（以及它的<strong>TileView</strong>们）还需要添加一些动画效果。打开<strong>TileView.swift</strong>文件，找到<code>startAnimatingWithDuration(_:beginTime:rippleDelay:rippleOffset:)</code> 方法并添加如下动画代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timingFunction = <span class="type">CAMediaTimingFunction</span>(controlPoints: <span class="number">0.25</span>, <span class="number">0</span>, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> linearFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionLinear)</span><br><span class="line"><span class="keyword">let</span> easeOutFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionEaseOut)</span><br><span class="line"><span class="keyword">let</span> easeInOutTimingFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionEaseInEaseOut)</span><br><span class="line"><span class="keyword">let</span> zeroPointValue = <span class="type">NSValue</span>(<span class="type">CGPoint</span>: <span class="type">CGPointZero</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animations = [<span class="type">CAAnimation</span>]()</span><br></pre></td></tr></table></figure>

<p>这段代码设置了一系列我们即将用到的时间函数。继续添加下面的代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> shouldEnableRipple &#123;</span><br><span class="line"><span class="comment">// Transform.scale</span></span><br><span class="line"><span class="keyword">let</span> scaleAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;transform.scale&quot;</span>)</span><br><span class="line">scaleAnimation.values = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1.05</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">scaleAnimation.keyTimes = <span class="type">TileView</span>.rippleAnimationKeyTimes</span><br><span class="line">scaleAnimation.timingFunctions = [linearFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">linearFunction]</span><br><span class="line">scaleAnimation.beginTime = <span class="number">0.0</span></span><br><span class="line">scaleAnimation.duration = duration</span><br><span class="line">animations.append(scaleAnimation)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Position</span></span><br><span class="line"><span class="keyword">let</span> positionAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;position&quot;</span>)</span><br><span class="line">positionAnimation.duration = duration</span><br><span class="line">positionAnimation.timingFunctions = [linearFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">linearFunction]</span><br><span class="line">positionAnimation.keyTimes = <span class="type">TileView</span>.rippleAnimationKeyTimes</span><br><span class="line">positionAnimation.values = [zeroPointValue, </span><br><span class="line">zeroPointValue, </span><br><span class="line"><span class="type">NSValue</span>(<span class="type">CGPoint</span>:rippleOffset), </span><br><span class="line">zeroPointValue, </span><br><span class="line">zeroPointValue]</span><br><span class="line">positionAnimation.additive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">animations.append(positionAnimation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shouldEnableRipple</strong>是个布尔值，用于控制何时将形变动画和位置动画添加到我们刚刚创建的数组中。在通过<code>renderTileViews()</code>方法创建时，所有未处在<strong>TileGridView</strong>外围边缘的<strong>TileView</strong>，就已将<strong>shouldEnableRipple</strong>设为<strong>true</strong>。</p>
<p>添加一个不透明动画:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Opacity</span></span><br><span class="line"><span class="keyword">let</span> opacityAnimation = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;opacity&quot;</span>)</span><br><span class="line">opacityAnimation.duration = duration</span><br><span class="line">opacityAnimation.timingFunctions = [easeInOutTimingFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">timingFunction, </span><br><span class="line">easeOutFunction, </span><br><span class="line">linearFunction]</span><br><span class="line">opacityAnimation.keyTimes = [<span class="number">0.0</span>, <span class="number">0.61</span>, <span class="number">0.7</span>, <span class="number">0.767</span>, <span class="number">0.95</span>, <span class="number">1.0</span>]</span><br><span class="line">opacityAnimation.values = [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.45</span>, <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">animations.append(opacityAnimation)</span><br></pre></td></tr></table></figure>

<p>该动画简单明了，只是设置了一些非常特殊的的<strong>keyTimes</strong>。</p>
<p>现在将这些动画添加到一个动画组中:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Group</span></span><br><span class="line"><span class="keyword">let</span> groupAnimation = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">groupAnimation.repeatCount = <span class="type">Float</span>.infinity</span><br><span class="line">groupAnimation.fillMode = kCAFillModeBackwards</span><br><span class="line">groupAnimation.duration = duration</span><br><span class="line">groupAnimation.beginTime = beginTime + rippleDelay</span><br><span class="line">groupAnimation.removedOnCompletion = <span class="literal">false</span></span><br><span class="line">groupAnimation.animations = animations</span><br><span class="line">groupAnimation.timeOffset = kAnimationTimeOffset</span><br><span class="line"></span><br><span class="line">layer.addAnimation(groupAnimation, forKey: <span class="string">&quot;ripple&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这会将<strong>groupAnimation</strong>添加到<strong>TileView</strong>实例上。注意，动画组会因<strong>shouldEnableRipple</strong>值的不同而可能包含一个或三个动画。</p>
<p>现在我们已经为每一个<strong>TileView</strong>实现了动画, 接下来需要在<strong>TileGridView</strong>中去调用它们。打开<strong>TileGridView.swift</strong>文件将以下代码添加到<code>startAnimatingWithBeginTime(_:)</code>方法中:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">startAnimatingWithBeginTime</span><span class="params">(beginTime: NSTimeInterval)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> tileRows <span class="keyword">in</span> tileViewRows &#123;</span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> tileRows &#123;</span><br><span class="line">view.startAnimatingWithDuration(kAnimationDuration, beginTime: beginTime, </span><br><span class="line">rippleDelay: <span class="number">0</span>, </span><br><span class="line">rippleOffset: <span class="type">CGPointZero</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并运行。</p>
<center>![Grid-1](https://koenig-media.raywenderlich.com/uploads/2016/05/Grid-1.gif)</center>

<p>嗯。。。看上去已经好多了，但<strong>AnimatedULogoView</strong>的跳动应该通过<strong>TileView</strong>向外产生一个类似水波的涟漪效果。这就意味还需要创建一个，基于从中央视图（view）到外围视图之间距离的，用于与一个常数相乘的延迟系数。</p>
<p>紧挨着<code>startAnimatingWithBeginTime(_:)</code>函数下面, 添加如下的一个新函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">distanceFromCenterViewWithView</span><span class="params">(view: UIView)</span></span>-&gt;<span class="type">CGFloat</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> centerTileView = centerTileView <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0.0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> normalizedX = (view.center.x - centerTileView.center.x)</span><br><span class="line"><span class="keyword">let</span> normalizedY = (view.center.y - centerTileView.center.y)</span><br><span class="line"><span class="keyword">return</span> sqrt(normalizedX * normalizedX + normalizedY * normalizedY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以便捷地获取到，指定视图与位于中心的视图，两个视图（_TileView_）中心点之间的距离。</p>
<p>回到<code>startAnimatingWithBeginTime(_:)</code>函数，将其内容替换为如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tileRows <span class="keyword">in</span> tileViewRows &#123;</span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> tileRows &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">distance</span> = <span class="keyword">self</span>.distanceFromCenterViewWithView(view)</span><br><span class="line"></span><br><span class="line">view.startAnimatingWithDuration(kAnimationDuration, beginTime: beginTime, rippleDelay: kRippleDelayMultiplier * <span class="type">NSTimeInterval</span>(<span class="built_in">distance</span>), rippleOffset: <span class="type">CGPointZero</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过刚刚添加的<code>distanceFromCenterViewWithView(_:)</code>函数，来计算（每个子视图）动画的延迟启动时间。</p>
<p>编译运行.</p>
<center>![Grid-2](https://koenig-media.raywenderlich.com/uploads/2016/05/Grid-2.gif)</center>

<p>好多了! 动画现在看上去已经有模有样了, 但还是少点什么。<strong>TileView</strong>应该像水波一样，向四周逐渐扩散开来。</p>
<p>解决该问的最好方法就是拿出自己的高中数学知识，然后根据<strong>Tileview</strong>与中心点间距离来得到一个量化的顶点。</p>
<p>在<code>distanceFromCenterViewWithView(_:)</code>函数下面再添加一个函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">normalizedVectorFromCenterViewToView</span><span class="params">(view: UIView)</span></span>-&gt;<span class="type">CGPoint</span> &#123;</span><br><span class="line"><span class="keyword">let</span> length = <span class="keyword">self</span>.distanceFromCenterViewWithView(view)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> centerTileView = centerTileView <span class="keyword">where</span> length != <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">CGPointZero</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> deltaX = view.center.x - centerTileView.center.x</span><br><span class="line"><span class="keyword">let</span> deltaY = view.center.y - centerTileView.center.y</span><br><span class="line"><span class="keyword">return</span> <span class="type">CGPoint</span>(x: deltaX / length, y: deltaY / length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>startAnimatingWithBeginTime(_:)</code>方法，将代码修改如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">startAnimatingWithBeginTime</span><span class="params">(beginTime: NSTimeInterval)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> tileRows <span class="keyword">in</span> tileViewRows &#123;</span><br><span class="line"><span class="keyword">for</span> view <span class="keyword">in</span> tileRows &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">distance</span> = <span class="keyword">self</span>.distanceFromCenterViewWithView(view)</span><br><span class="line"><span class="keyword">var</span> vector = <span class="keyword">self</span>.normalizedVectorFromCenterViewToView(view)</span><br><span class="line"></span><br><span class="line">vector = <span class="type">CGPoint</span>(x: vector.x * kRippleMagnitudeMultiplier * <span class="built_in">distance</span>, </span><br><span class="line">y: vector.y * kRippleMagnitudeMultiplier * <span class="built_in">distance</span>)</span><br><span class="line"></span><br><span class="line">view.startAnimatingWithDuration(kAnimationDuration, </span><br><span class="line">beginTime: beginTime, </span><br><span class="line">rippleDelay: kRippleDelayMultiplier * <span class="type">NSTimeInterval</span>(<span class="built_in">distance</span>), </span><br><span class="line">rippleOffset: vector)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会通过 <em>rippleOffset</em> 计算位于每个顶点（vector）的 <em>TileView</em> 的偏移量。</p>
<p>编译运行一下.</p>
<center>![Grid-3](https://koenig-media.raywenderlich.com/uploads/2016/05/Grid-3.gif)</center>

<p>太棒了! 接下来是点睛之笔：添加一个放大的效果，这个放大的动画效果要刚好在遮罩边界（bounds）发生改变之前。</p>
<p>在<code>startAnimatingWithBeginTime(_:)</code>函数的开始位置，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> linearTimingFunction = <span class="type">CAMediaTimingFunction</span>(name: kCAMediaTimingFunctionLinear)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyframe = <span class="type">CAKeyframeAnimation</span>(keyPath: <span class="string">&quot;transform.scale&quot;</span>)</span><br><span class="line">keyframe.timingFunctions = [linearTimingFunction, </span><br><span class="line"><span class="type">CAMediaTimingFunction</span>(controlPoints: <span class="number">0.6</span>, <span class="number">0.0</span>, <span class="number">0.15</span>, <span class="number">1.0</span>), </span><br><span class="line">linearTimingFunction]</span><br><span class="line">keyframe.repeatCount = <span class="type">Float</span>.infinity;</span><br><span class="line">keyframe.duration = kAnimationDuration</span><br><span class="line">keyframe.removedOnCompletion = <span class="literal">false</span></span><br><span class="line">keyframe.keyTimes = [<span class="number">0.0</span>, <span class="number">0.45</span>, <span class="number">0.887</span>, <span class="number">1.0</span>]</span><br><span class="line">keyframe.values = [<span class="number">0.75</span>, <span class="number">0.75</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">keyframe.beginTime = beginTime</span><br><span class="line">keyframe.timeOffset = kAnimationTimeOffset</span><br><span class="line"></span><br><span class="line">containerView.layer.addAnimation(keyframe, forKey: <span class="string">&quot;scale&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>再次编译并运行。</p>
<center>![FuberFinal](https://koenig-media.raywenderlich.com/uploads/2016/05/FuberFinal.gif)</center>

<p>漂亮，我们已经创建了一个产品级的动画效果，会有大一批的Fuber用户在微博（Twitter）上为此点赞的！：］（作者又卖了个萌！）</p>
<blockquote>
<p>注意：试着改变<strong>kRippleMagnitudeMultiplier</strong>和<strong>kRippleDelayMultiplier</strong>的值，看看会有什么有趣的事发生。</p>
</blockquote>
<p>接下收尾，在<strong>RootContainerViewController.swift</strong>文件中，将<code>viewDidLoad()</code>最后一行代码<code>showSplashViewControllerNoPing()</code>改为<code>showSplashViewController()</code>。</p>
<p>最后在编译运行一次，欣赏下自己的工作成果吧</p>
<center>![Fuber Animation](https://koenig-media.raywenderlich.com/uploads/2016/05/Fuber-Animation.gif)</center>

<p>给自己点个赞吧，这是一个非常炫酷的溅落式启动页。</p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>可以在这下载到<a href="https://cdn1.raywenderlich.com/wp-content/uploads/2016/06/Fuber-final.zip">最终的Fuber工程</a>.</p>
<p>您还可以在这里找到由译者更新至Swift 3.0的<a href="https://github.com/Dracarys/Fuber-final">最终的Fuber工程</a>，请使用Xcode 8.0 beta4 或更新版本打开。</p>
<p>如果想了解更多关于动画的知识，请访问这里的<a href="https://www.raywenderlich.com/store/ios-animations-by-tutorials">iOS动画教程</a>.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文翻译自 <a href="https://www.raywenderlich.com/133224/how-to-create-an-uber-splash-screen">How To Create an Uber Splash Screen</a>*， *由 <a href="https://www.raywenderlich.com/u/lolgrep">Derek Selander</a> 发表于Raywenderlich。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
]]></content>
      <categories>
        <category>iOS动画</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Swift 与 C API的交互（Swift 3）</title>
    <url>/2016/07/28/Interactive-with-C-APIs-Swift-3-beta/</url>
    <content><![CDATA[<p>作为与 Objective-C 交互的一部分，Swift 对 C 语言的类型和特性也提供了良好的兼容。Swift还提供了相应的交互方式，以便在需要时可以在代码中使用常见的 C 结构模式。</p>
<a id="more"></a>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>虽然Swift提供了与 C 语言中 char，int，float 和 double 等基本类型等价的类型。但这些类型，诸如Int，不能与 Swift 核心类型进行隐式转换。因此除非代码中有明确要求（使用等价的 C 类型），否则都应使用Int（等Swift核心类型）。</p>
<table>
<thead>
<tr>
<th align="left">C</th>
<th align="left">Swift</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">CBool</td>
</tr>
<tr>
<td align="left">char, signed char</td>
<td align="left">CChar</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">CUnsignedChar</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">CShort</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">CUnsignedShort</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">CInt</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">CUnsignedInt</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">CLong</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">CUnsignedLong</td>
</tr>
<tr>
<td align="left">long long</td>
<td align="left">CLongLong</td>
</tr>
<tr>
<td align="left">unsigned long long</td>
<td align="left">UnsignedLongLong</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">CWideChar</td>
</tr>
<tr>
<td align="left">char16_t</td>
<td align="left">CChart16</td>
</tr>
<tr>
<td align="left">char32_t</td>
<td align="left">CChart32</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">CFloat</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">CDouble</td>
</tr>
</tbody></table>
<h2 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h2><p>定义在 C 和Objective-C源文件中的全局常量，会自动被Swift编译器引入为全局常量。</p>
<h3 id="常量的引入"><a href="#常量的引入" class="headerlink" title="常量的引入"></a>常量的引入</h3><p>在 Objective-C 中，常量通常用来为属性和函数参数提供一组可选值。使用NS_STRING_ENUM和NS_EXTENSIBLE_STRING_ENUM宏标注的Ojbective-C的typedef声明，可被Swift以普通类型的成员的方式引入。</p>
<p>表示一组可用值的常量，可以通过添加NS_STRING_ENUM宏，来将其引入为枚举。例如，下面这段关于TraficLightColor的Objective-C字符串常量的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString * TrafficLightColor NS_STRING_ENUM;</span><br><span class="line">TrafficLightColor const TraficLightColorRed;</span><br><span class="line">TrafficLightColor const TraficLightColorYellow;</span><br><span class="line">TrafficLightColor const TraficLightColorGreen;</span><br></pre></td></tr></table></figure>

<p>下面展示了Swift如何引入它们:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TrafficLightColor</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> red</span><br><span class="line"><span class="keyword">case</span> yellow</span><br><span class="line"><span class="keyword">case</span> green</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于呈现一组可扩展的可用常量值来说，可通过添加NS_EXTENSIBLE_STRING_ENUM宏，来使其以结构体的形式被引入。例如，下面这段关于StateOfMatter的Objective-C字符串常量声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString * StateOfMatter NS_EXTENSIBLE_STRING_ENUM;</span><br><span class="line">StateOfMatter const StateOfMatterSolid;</span><br><span class="line">StateOfMatter const StateOfMatterLiquid;</span><br><span class="line">StateOfMatter const StateOfMatterGas;</span><br></pre></td></tr></table></figure>

<p>下面展示了Swift如何引入它们:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateOfMatter</span>: <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">RawValue</span> = <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(rawValue: <span class="type">RawValue</span>)</span><br><span class="line"><span class="keyword">var</span> rawValue: <span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> solid: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> liquid: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> gas: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过NS_EXTENSIBLE_STRING_ENUM宏被引入的常量，在Swift代码中是可以扩展添加新值的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StateOfMatter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> plasma: <span class="type">StateOfMatter</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">StateOfMatter</span>(rawValue: <span class="string">&quot;plasma&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Swift可以把任何声明在 C 头文件中的函数作为全局函数引入。例如，下面的 C 函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> multiper, <span class="keyword">int</span> multiplicand)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> devisor, <span class="keyword">int</span> *remainder)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Point2D <span class="title">createPoint2D</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distance</span><span class="params">(struct Point2D from, struct Point2D to)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面展示了Swift如何引入它们:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(<span class="keyword">_</span> multiplier: Int32, <span class="keyword">_</span> multiplicand: Int32)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quotient</span><span class="params">(<span class="keyword">_</span> dividen: Int32, <span class="keyword">_</span> devison: Int32, UnsafeMutablePointer&lt;Int32&gt;!)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPoint2D</span><span class="params">(<span class="keyword">_</span> x: Float, <span class="keyword">_</span> y: Float)</span></span> -&gt; <span class="type">Point2D</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(<span class="keyword">_</span> from: Point2D, <span class="keyword">_</span> to: Point2D)</span></span> -&gt; <span class="type">Float</span></span><br></pre></td></tr></table></figure>

<h3 id="可变参数函数-Variadic-Functions"><a href="#可变参数函数-Variadic-Functions" class="headerlink" title="可变参数函数(Variadic Functions)"></a>可变参数函数(Variadic Functions)</h3><p>在Swift中，可以通过getValist(_:)或者withValist(_:_:)来调用 C 中诸如vaspritf的可变参数函数. getValist(_:)函数接收一个包含CVarArg值的数组，并返回一个CVaListPointer，与直接返回不同withValist(_:_:)则通过接受一个闭包来实现。返回值CVaListPointer之后会被传递给 C 可变参数函数的va_lsit参数。</p>
<p>例如，下面的代码展示了如何在Swift中调用vasprintf函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swiftprintf</span><span class="params">(format: String, argument: CVarArg...)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line"><span class="keyword">return</span> withValist(arguments) &#123; va_list <span class="keyword">in</span></span><br><span class="line"><span class="keyword">var</span> buffer: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> format.withCstring &#123; <span class="type">CString</span> <span class="keyword">in</span> </span><br><span class="line"><span class="keyword">guard</span> vasprintf(&amp;buffer, <span class="type">CString</span>, va_list) != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="type">String</span>(validatingUTF8: buffer!)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Swiftprintf</span>(format: <span class="string">&quot;√2 ≅ %g&quot;</span>, arguments: sqrt(<span class="number">2.0</span>))!)</span><br><span class="line"><span class="comment">// Prints &quot;√2 ≅ 1.41421&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意<br>可选类型指针不能传入withVaList(_:invoke:)函数，<br>可以通过Int.init(bitPattern:)构造函数，来将可选类型指针转为Int，<br>Which has the same C variadic calling conventions as pointer on all supported platforms(？？？ 尚待完善)。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Swift可以把任何头文件中声明的 C 结构体引入为Swift结构体，引入后的结构体会为每一个原 C 结构体成员生成一个存储型属性和一个该结构体的逐一成员构造器。如果被引入的成员均有默认值，那么Swift同时会生成一个无参数的默认构造器。例如下面这个 C 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> &#123;</span></span><br><span class="line"><span class="keyword">float</span> r, g, b;</span><br><span class="line">&#125;:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> <span class="title">Color</span>;</span></span><br></pre></td></tr></table></figure>

<p>下面是与之相应的Swift结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> r: <span class="type">Float</span></span><br><span class="line"><span class="keyword">var</span> g: <span class="type">Float</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Float</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">init</span>(r: <span class="type">Float</span>, g: <span class="type">Float</span>, b: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将函数引入为类型成员"><a href="#将函数引入为类型成员" class="headerlink" title="将函数引入为类型成员"></a>将函数引入为类型成员</h3><p>CoreFoundation框架中的 C API，大都提供了用于创建、存取、或者修改 C 结构体的函数。可以通过在代码添加CF_Swift_NAME宏，来让Swift将这些 C 函数引入为结构体的成员函数。例如，下面这段C函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">ColorCreateWithCMYK</span><span class="params">(<span class="keyword">float</span> c, <span class="keyword">float</span> m, <span class="keyword">float</span> y, <span class="keyword">float</span> k)</span> <span class="title">CF_SWFIT_NAME</span><span class="params">(Color.init(c:m:y:k:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ColorGetHue</span><span class="params">(Color color)</span> <span class="title">CF_Swift_NAME</span><span class="params">(getter:Color.hue(self:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ColorSetHue</span><span class="params">(Color color, <span class="keyword">float</span> hue)</span> <span class="title">CF_Swift_NAME</span><span class="params">(setter:Color.hue(self:newvalue))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorDarkenColor</span><span class="params">(Color color, flaot amout)</span> <span class="title">CF_Swift_NAME</span><span class="params">(Color.Darken(self:amount:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">const</span> Color ColorBondiBlue <span class="title">CF_Swift_NAME</span><span class="params">(Color.boundiBlue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorGetCalibrationColor</span><span class="params">(<span class="keyword">void</span>)</span> <span class="title">CF_Swift_NAME</span><span class="params">(getter:Color.calibration())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorSetCalibrationColor</span><span class="params">(Color color)</span> <span class="title">CF_Swift_NAME</span><span class="params">(setter:Color.calibration(newValue:))</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面展示了Swift如何将它们以类型成员的方式引入：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">color</span> </span>&#123;</span><br><span class="line"><span class="keyword">init</span>(<span class="built_in">c</span>: <span class="type">Float</span>, m: <span class="type">Float</span>, y: <span class="type">Float</span>, k: <span class="type">Float</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hue: <span class="type">Float</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">darken</span><span class="params">(amount: Float)</span></span> -&gt; <span class="type">Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> bondiBlue: <span class="type">Color</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> calibration: <span class="type">Color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入CF_Swift_NAME宏的参数语法与#selector表达式相同。CF_Swift_NAME宏中的self，表示接收该方法的实例对象。</p>
<p>注意<br>使用CF_Swift_NAME宏时不能改变被引入成员函数的参数顺序和数量。<br>如果想更Swift点，可以重写一个Swift函数，然后在其内部再调用所需的 C 函数<br>（译者：用Swift再做一层封装）</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Swift可以把任何NS_ENUM标记的 C 枚举引入为Int类型的Swift枚举。无论是系统框架还是其它代码，引入后的枚举都会自动移除原命名前缀，<br>例如，下面这个通过NS_ENUM宏声明的 C 枚举:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger, UITableViewCellStyle)</span></span>&#123;</span><br><span class="line">UITableViewCellStyleDefault, </span><br><span class="line">UITableViewCellStyleValue1, </span><br><span class="line">UITableViewCellStyleValue2, </span><br><span class="line">UITableViewCellStyleSubtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Swift中会被引入为如下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellStyle</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> &#x27;<span class="keyword">default</span>&#x27;</span><br><span class="line"><span class="keyword">case</span> value1</span><br><span class="line"><span class="keyword">case</span> value2</span><br><span class="line"><span class="keyword">case</span> subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要时，可通过._name_的方式来引用一个枚举值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cellStyle: <span class="type">UITableViewCellStyle</span> = .<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>注意<br>Swift引入的 C 枚举，在构造时即使入参与声明不一致，也不会导致构造失败。<br>这么处理是为了与 C 兼容，因为 C 枚举允许任意类型的值，即使这个值没有暴露在头文件中，<br>而仅仅是供内部使用。</p>
<p>那些未通过NS_ENUM和NS_OPTIONS宏声明的 C 枚举会被引入为Swift结构体。C 枚举中的每个成员都会被引入为一个与结构体类型相同的全局只读计算型属性，而非结构体成员属性。</p>
<p>例如，下面这个未通过NS_ENUM宏而声明的 C 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">MessageDispositionUnread = <span class="number">0</span>,</span><br><span class="line">MessageDispositionRead = <span class="number">1</span>,</span><br><span class="line">MessageDispositionDeleted = <span class="number">-1</span></span><br><span class="line">&#125; MessageDisposition;</span><br></pre></td></tr></table></figure>

<p>在Swift中，它会被引入为以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MessageDisposition: RawRePresentable, Equatable&#123;&#125;</span><br><span class="line"></span><br><span class="line">var MessageDispositionUnread: MessageDisposition &#123; get &#125;</span><br><span class="line">var MessageDispositionRead: MessageDisposition &#123; get &#125;</span><br><span class="line">var MessageDispositionDeleted: MessageDisposition &#123; get &#125;</span><br></pre></td></tr></table></figure>
<p>Swift会自动为引入的C枚举类型适配Equaltable协议。</p>
<h4 id="选项型枚举（Option-sets）"><a href="#选项型枚举（Option-sets）" class="headerlink" title="选项型枚举（Option sets）"></a>选项型枚举（Option sets）</h4><p>Swift同样可以把NS_OPTIONS宏标注的 C 选项型枚举引入为Swift的选项（Option set）。与先前枚举的引入类似，选项值的命名前缀也会被移除。<br>例如，下面这个Objective-C声明的选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing)&#123;</span><br><span class="line">UIViewAutoresizingNone &#x3D; 0,</span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin &#x3D; 1 &lt;&lt; 0,</span><br><span class="line">UIViewAutoresizingFlexibleWidth &#x3D; 1 &lt;&lt; 1, </span><br><span class="line">UIViewAutoresizingFlexibleRightMargin &#x3D; 1 &lt;&lt; 2,</span><br><span class="line">UIViewAutoresizingFlexibleTopMargin &#x3D; 1 &lt;&lt; 3,</span><br><span class="line">UIViewAutoresizingFlexibleHeight &#x3D; 1 &lt;&lt; 4,</span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin &#x3D; 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Swift中会被引入为以下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIViewAutoresizing</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleLeftMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleWidth: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleRightMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleTopMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleHeight: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleBottomMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中，选项型枚举实际上是整型位掩码。既可以通过位或运算符（｜）来组合选项值，又可以通过位与运算符（&amp;)检查选项值。我们还可以通过常量或表达式来创建选项，空选项型用常量零（0）表示。</p>
<p>在Swift中，选项是以一个遵从OptionSet协议的结构体来实现，每个选项都是该结构体的一个静态变量。与枚举类似，我们可以通过字面量数组来创建一个选项，还可以通过（.）语法获取选项的一个值。一个空的选项既可以通过字面量空数组（［］）创建，也可以通过调用其默认构造函数创建。</p>
<p>注意<br>当引入NS_OPTIONS宏标记的 C 枚举时，任何值为0的选项成员都会被Swift标记为无效，<br>因为Swift中使用空选项来表示没有选择</p>
<p>选项与Swift中的Set集合类型相似，可以通过insert(_:)或formUnion(_:)函数添加选项值，也可以通过remove(_:)或substract(_:)函数删除一个选项值，还可以通过contains(_:)来查验选项值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options: <span class="type">Data</span>.<span class="type">Base64EncodingOptions</span> = [</span><br><span class="line">.lineLength64Characters,</span><br><span class="line">.endLineWithLineFeed</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = data.base64EncodedString(options:options)</span><br></pre></td></tr></table></figure>

<h3 id="联合体（Unions）"><a href="#联合体（Unions）" class="headerlink" title="联合体（Unions）"></a>联合体（Unions）</h3><p>Swift仅部分支持 C 联合体类型，对于引入的 C 联合体，Swift无法存取不支持的域（fields）。但那些使用联合体作为参数或返回值的 C 和Objective-C API，可以被Swift正确调用。</p>
<h3 id="位域（Bit-Fields）"><a href="#位域（Bit-Fields）" class="headerlink" title="位域（Bit Fields）"></a>位域（Bit Fields）</h3><p>Swift可以把结构体中的位域，诸如Foundation中的NSDecimal类型，引入为计算型存储属性。在对其进行读取时，Swift会自动将其值转换为Swift兼容类型。</p>
<h3 id="匿名的结构体和联合体域（Union-Fields）"><a href="#匿名的结构体和联合体域（Union-Fields）" class="headerlink" title="匿名的结构体和联合体域（Union Fields）"></a>匿名的结构体和联合体域（Union Fields）</h3><p>C 中的Struct和union类型在定义时可以作为域而不命名，Swift是不支持匿名结构体的，所以这些域会被引入为以__Unnamed_fieldName格式命名的嵌套类型。</p>
<p>例如，这个名为Pie的 C 结构体，它包含一个匿名结构体curst域和匿名联合体filling域：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pie</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">bool</span> flakey; &#125; crust;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span> <span class="keyword">int</span> fruit; <span class="keyword">int</span> meat; &#125; filling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们会分别被Swift引入为，一个Pie.__Unamed_crust类型的curst属性和一个Pie.__Unamed_filling类型的filling属性。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Swift一直在尽力避免直接访问指针。但仍提供了丰富的指针类型以备不时之需。下表使用Type来指代不同语言的相应类型。</p>
<p>变量、参数、返回值的指针对照关系如下：</p>
<table>
<thead>
<tr>
<th align="left">C Syntax</th>
<th align="left">Swift Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const Type *</td>
<td align="left">UnsafePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type *</td>
<td align="left">UnsafeMutablePointer&lt;Type&gt;</td>
</tr>
</tbody></table>
<p>类类型指针对照关系如下：</p>
<table>
<thead>
<tr>
<th align="left">C Syntax</th>
<th align="left">Swift Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Type * const *</td>
<td align="left">UnsafePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type * __strong *</td>
<td align="left">UnsafeMutablePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type **</td>
<td align="left">AutoreleasingUnsafeMutablePointer&lt;Type&gt;</td>
</tr>
</tbody></table>
<p>如果Swift中没有与 C 指针所指内容相应的类型，例如，一个不完全的结构体类型，那么这个指针会被引入为OpaquePointer。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>一个接受UnsafePointer&lt;Type&gt;类型参数的函数，同样可以接受下列类型参数：</p>
<ul>
<li>一个UnsafePointer&lt;Type&gt;，UnsafeMutalbePointer&lt;Type&gt;，或AutoreleasingUnsafeMutablePointer&lt;Type&gt;类型的值，如有必要它会被转换为UnsafePointer&lt;Type&gt;类型。</li>
<li>如果Type是Int8或UInt8，则可接受一个String类型的值。该字符串会自动被转换为一个UTF8字符缓存，随之指向该缓存的指针被传入函数。</li>
<li>一个包含一个或多个变量、属性、Type类型下标引用的in-out表达式。表达式会以指向左起首位参数内存地址的指针形式被传入。</li>
<li>［Type］（一个含有Type类型元素的数组）,会以指向数组首地址的指针形式传入。</li>
</ul>
<p>传入函数的指针，仅保证在函数调用期间有效。不要尝试持有或在函数返回后访问该指针。</p>
<p>例如，这样一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafePointer&lt;Float&gt;!)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样调用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span></span><br><span class="line">takesAPointer(&amp;x)</span><br><span class="line">takesAPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br></pre></td></tr></table></figure>

<p>一个接受UnsafePointer&lt;Void&gt;类型参数的函数，可以把任意Type类型操作数以UnsafePointer&lt;Type&gt;形式接受。</p>
<p>例如下面这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAVoidPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafePointer&lt;Void&gt;!)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">takesAVoidPointer(&amp;x)</span><br><span class="line">takesAVoidPointer(&amp;y)</span><br><span class="line">takesAVoidPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] <span class="keyword">as</span> [<span class="type">Float</span>])</span><br><span class="line"><span class="keyword">let</span> intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">takesAVoidPointer(intArray)</span><br></pre></td></tr></table></figure>

<h3 id="可变指针（Mutable-Pointers）"><a href="#可变指针（Mutable-Pointers）" class="headerlink" title="可变指针（Mutable Pointers）"></a>可变指针（Mutable Pointers）</h3><p>一个接受UnsafeMutablePointer&lt;Type&gt;类型参数的函数，同样可以接受下列类型参数：</p>
<ul>
<li>一个UnsafeMutablePointer&lt;Type&gt;类型的值</li>
<li>一个含有一个或多个变量、属性、Type类型下标引用的in-out表达式。表达式会以指向左起首位参数内存地址的指针形式被传入。</li>
<li>inout［Type］的值，会以指向数组首地址的指针形式传入，与此同时其生命周期会被延长，持续于整个函数调用期间。</li>
</ul>
<p>例如下面这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(<span class="keyword">_</span> p: UnsafeMutablePointer&lt;Float&gt;!)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">var</span> a: [<span class="type">Float</span>] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">takesAMutablePointer(&amp;x)</span><br><span class="line">takesAMutablePointer(&amp;a)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">一个接受<span class="type">UnsafeMutablePointer</span>\&lt;<span class="type">Void</span>\&gt;类型参数的函数，可以把任意<span class="type">Type</span>类型操作数以<span class="type">UnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt;形式接受</span><br><span class="line"></span><br><span class="line">例如下面这个函数：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafeMutablePointer&lt;Void&gt;!)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> a: [<span class="type">Float</span>] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], b: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">takesAMutableVoidPointer(&amp;x)</span><br><span class="line">takesAMutableVoidPointer(&amp;y)</span><br><span class="line">takesAMutableVoidPointer(&amp;a)</span><br><span class="line">takesAMutableVoidPointer(&amp;b)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">### 自释放指针（autoreleasing <span class="type">Pointers</span>）</span><br><span class="line">一个接受<span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt;类型参数的函数，同样可以接受下列类型参数：</span><br><span class="line"></span><br><span class="line">- 一个<span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt;类型的值</span><br><span class="line">- 一个含有一个或多个变量、属性、<span class="type">Type</span>类型下标引用的<span class="keyword">in</span>-out表达式，它会被按位拷贝到一个不持有的临时缓存，随之指向该缓存的指针会被传入，并且在返回时，缓存中的值会被加载，保持，并赋值到操作数中。</span><br><span class="line"></span><br><span class="line">注意：上表与之前不同，<span class="keyword">_</span>不包含数组<span class="keyword">_</span>。</span><br><span class="line"></span><br><span class="line">例如下面这个函数：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(<span class="keyword">_</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;!)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">NSDate?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="type">AutoreleasingUnsafeMutablePointer</span>(&amp;x)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">引入时，指针所指的类型不会被等价转换（bridged）。例如，<span class="type">NSString</span> \*\* 会被<span class="type">Swift</span>引入为<span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">NSString?</span>\&gt;，而不是<span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">String?</span>\&gt;。</span><br><span class="line"></span><br><span class="line">### 函数指针</span><br><span class="line">通过<span class="meta">@convention</span>(<span class="built_in">c</span>)标注，<span class="type">Swift</span>会根据 <span class="type">C</span> 函数指针调用规则将其引入为结构体。例如，一个int (x) (void)类型的 <span class="type">C</span> 函数指针，会以 @convertion(<span class="built_in">c</span>) () -&gt; <span class="type">Int32</span> 的形式引入<span class="type">Swift</span>。当调用一个接受函数指针类型参数的函数时，可以直接传入一个顶级的<span class="type">Swift</span>函数，一个字面量闭包，或者<span class="literal">nil</span>。还可以传入一个泛型闭包属性，或者一个闭包参数列表和者闭包体中都没有引用泛型参数的泛型函数。例如，<span class="type">Core</span> <span class="type">Foundation</span>中的<span class="type">CFArrayCreateMutable</span>(\<span class="keyword">_</span>:\<span class="keyword">_</span>:\<span class="keyword">_</span>:)函数。<span class="type">CFArrayCreateMutable</span>(\<span class="keyword">_</span>:\<span class="keyword">_</span>:\<span class="keyword">_</span>:)函数，接受一个初始化为函数指针的<span class="type">CFArrayCallBacks</span>结构体：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(<span class="keyword">_</span> p: UnsafePointer&lt;Void&gt;!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;! &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callBacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">version: <span class="number">0</span>,</span><br><span class="line">retain: <span class="literal">nil</span>,</span><br><span class="line">release: <span class="literal">nil</span>,</span><br><span class="line">copyDescription: customCopyDescription,</span><br><span class="line"><span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">DarwinBoolean</span> <span class="keyword">in</span> </span><br><span class="line"><span class="comment">// return Bool value</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, &amp;callbacks)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">上面的例子中，<span class="type">CFArrayCallBacks</span>在初始化时，分别把<span class="literal">nil</span>赋值给retain和release，把customCopyDescription(<span class="keyword">_</span>:)函数作为参数赋给copyDescription，并把一个闭包体作为参数赋值<span class="built_in">equal</span>。</span><br><span class="line"></span><br><span class="line">### 空指针</span><br><span class="line">在<span class="type">Objective</span>-<span class="type">C</span>中，指针类型的声明可以通过标注\_Nullable和\_Nonnull来表明是否可以接受空值<span class="literal">nil</span>或<span class="type">NULL</span>。在<span class="type">Swift</span>中，空指针是通过一个值为<span class="literal">nil</span>的可选类型指针来实现。透过一个整数内存地址来构造指针，是可失败的。一个非可选的指针类型不能被赋值为<span class="literal">nil</span>。</span><br><span class="line"></span><br><span class="line">对应关系如下：</span><br><span class="line"></span><br><span class="line">|  <span class="type">Objective</span>-<span class="built_in">c</span> <span class="type">Syntax</span>   |   <span class="type">Swift</span> <span class="type">Syntax</span>       |</span><br><span class="line">|:----------------------|:---------------------|</span><br><span class="line">|const <span class="type">Type</span> \* \_Nonnull|<span class="type">UnsafePointer</span>\&lt;type\&gt; |</span><br><span class="line">|const <span class="type">Type</span> * \_Nullable|<span class="type">UnsafePointer</span>\&lt;type\&gt;?|</span><br><span class="line">|const <span class="type">Type</span> \* _Null\_unspecified|<span class="type">UnsafePointer</span>\&lt;type\&gt;!|</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">在<span class="type">Swift</span> <span class="number">3</span>之前，nullable和non-nullable指针均通过一个非可选（non-<span class="keyword">optional</span>）指针类型实现。</span><br><span class="line">将现有代码迁移至<span class="type">Swift</span>最新版本时，可能需要手动修改所有通过<span class="literal">nil</span>初始化的指针为可选类型。</span><br><span class="line"></span><br><span class="line">### 指针运算</span><br><span class="line">当处理未知数据类型时，可能会用到不安全的指针操作。在<span class="type">Swift</span>中，可通过运算符对一个指针的值进行位运算，以此来创建一个指定偏移量的新指针。</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="keyword">let</span> pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line"><span class="keyword">let</span> offsetPointer = pointer + <span class="number">24</span></span><br><span class="line"><span class="comment">// offsetPointer 是一个相对向前偏移了24位的新指针</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型空间计算"><a href="#数据类型空间计算" class="headerlink" title="数据类型空间计算"></a>数据类型空间计算</h3><p>在 C 语言中，通过sizeof操作符来获取各种变量或数据类型的空间大小，而Swift则分别通过sizeof(_:)和sizeofValue(_:)来获取指特定类型或值所占的内存空间大小。然而与 C 语言中的sizeof不同，Swift中的sizeof(_:)和sizeofValue(_:)函数未将因内存对齐而增加的额外空间计算在内。例如，在Darwin中以 C 方式来获取timeval结构体的空间是16字节，而通过Swift获取则是12字节。</p>
<p>（译者注：在最新的 Xcode 8 beta 6 中，这里提到的获取size的函数均被新的Enum MemoryLayout取代。由于官方英文文档尚未更新，所以译文暂不改动）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">printf(<span class="built_in">sizeof</span>(timeval.<span class="keyword">self</span>))</span><br><span class="line"><span class="comment">// Prints &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>类似功能由 strideof(_:) 和 strideofValue(_:) 函数代替，这两个函数返回的内存空间大小与 C 的sizeof返回相同。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">printf(<span class="built_in">strideof</span>(timeval.<span class="keyword">self</span>))</span><br><span class="line"><span class="comment">// Prints &quot;16&quot;</span></span><br></pre></td></tr></table></figure>

<p>例如，setsockopt(_:_:_:_:_:)函数，可以通过接受一个timeval指针和指针所指值的大小来设置sokect接收超时时间，这就需要用strideof()来计算值的长度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sokfd = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> optval = timeval(tv_sec: <span class="number">30</span>, tv_usec: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> optlen = socklen_t(stridof(timeval.<span class="keyword">self</span>))</span><br><span class="line"><span class="keyword">if</span> setsockopt(sockfd, <span class="type">SOL_SOCKET</span>, <span class="type">SO_RCVTIMEO</span>, &amp;optavl, optlen) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<br>仅有哪些符合 C 函数调用规则的Swift函数类型可以作为函数指针参数。<br>与 C 函数指针相同，带有@convertion(c)属性的Swift函数类型不会捕获其周边的代码环境。<br>更多内容，请至《Swift编程语言》（Swift 3）中类型属性一章。</p>
<h2 id="单次初始化"><a href="#单次初始化" class="headerlink" title="单次初始化"></a>单次初始化</h2><p>在 C 语言中，POSIX的pthread_once()函数和 Grand Central Dispatch中的dipatch_once()、dispatch_once_f()函数都有保证代码仅被初始化一次的机制。在Swift中，全局常量和存储型属性即使被多个线程同时交替存取，也能保证仅初始化一次。这是由语言自身特点来实现的。相应的POSIX和Grand Central Dispatch C 函数不能在Swift中调用。</p>
<h2 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h2><p>Swift没有预处理程序。相应地，它通过编译属性，条件编译block，和语言特性来实现相同功能。因此，预处理命令不会被引入到Swift中。</p>
<h2 id="简单宏命令"><a href="#简单宏命令" class="headerlink" title="简单宏命令"></a>简单宏命令</h2><p>在Swift中可通过全局常量来代替，在 C 和Objective-C中由#define定义的常量。例如，#define FADE_ANNOTATION_DURATION 0.35，可以在Swift中被更好的表示为 let FADE_ANNOTATION_DURATION = 0.35。由于宏定义的常量可以被直接映射为Swift的全局变量，所以编译器会自动引入那些定在 C 和Objective—C源文件中的简单宏定义。</p>
<h2 id="复杂宏命令"><a href="#复杂宏命令" class="headerlink" title="复杂宏命令"></a>复杂宏命令</h2><p>Swift不支持 C 或者Objective-C中的复杂宏命令，这里的复杂宏是指那些带有括号，与函数类似，却未用于定义常量的宏。C 和Objective-C中的复杂宏命令通常被用来规避类型检查限制，或者充当被大量使用的代码的模板。与此同时宏也让debuging和重构变困难。Swfit中可以通过函数和泛型来更好地达到这一目的。综上，C 和Objective-C中的复杂宏命令在Swift代码中是无效。</p>
<h2 id="条件编译Block"><a href="#条件编译Block" class="headerlink" title="条件编译Block"></a>条件编译Block</h2><p>Swift和Objective-C通过不同的方式实现了条件编译。Swift通过_条件编译block_来实现。例如，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> <span class="type">DEBUG_LOGGING</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flag enabled.&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<p>编译条件判断中可以包含true和false字面值，自定义条件判断flag（通过 -D &lt;#flag#&gt;指定)，和下表所列的平台判断方法。</p>
<table>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">Valid arguments</th>
</tr>
</thead>
<tbody><tr>
<td align="left">os()</td>
<td align="left">OSX, iOS, watchOS, tvOS, Linux</td>
</tr>
<tr>
<td align="left">arch()</td>
<td align="left">x86_64, arm, arm64, i386</td>
</tr>
<tr>
<td align="left">swift()</td>
<td align="left">&gt;=followed by version number</td>
</tr>
</tbody></table>
<p>注意<br>通过arch(arm)来判断ARM 64设备，不会返回true。当代码以32位iOS模拟器为目标编译时，arch(i386)会返回true。</p>
<p>通过逻辑与 &amp;&amp; 和逻辑或 || 符号可以混合判断条件，通过逻辑否 ！可以做假条件判断，还可以通过 #elseif 和 #else 来添加条件判断分支，此外在一个选择编译block中还能嵌套另一个选择编译block。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> arch(arm) || arch(arm64)</span><br><span class="line"><span class="keyword">#if</span> <span class="type">Swift</span>(&gt;=<span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Using Swift 3 ARM code&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Using Swift 2.2 ARM code&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#elseif</span> arch(x86_64)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Using 64-bit x86 code.&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Using general code.&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<p>与 C 语言的预编译不同，Swift的条件编译block必须完整且语法正确，这是因为Swift代码即使尚未被编译，也会进行语法检查。<br>特例，如果条件编译block包含swift()判断，那么这个表达式仅在Swift版本与判断条件相匹配的时候才会去解析该表达式。这是为了确保旧版编译器不会去尝试解析较新版本的Swift语法。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文译自《Using Swift with Cocoa and Objective-C》书中 Interacting with C APIs 一章。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>C 语言</tag>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Swift与 C API的交互（Swift 4 beta）</title>
    <url>/2017/07/14/Interactive-with-C-APIs-Swift-4-beta/</url>
    <content><![CDATA[<p>作为与 Objective-C 交互的一部分，Swift 对 C 语言的类型和特性也提供了良好的兼容。Swift还提供了相应的交互方式，以便在需要时可以在代码中使用常见的 C 结构模式。</p>
<a id="more"></a>

<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>虽然 Swift 提供了与 C 语言中 char，int，float 和 double 等基本类型等价的类型。但这些类型，如 Int，不能与 Swift 核心类型进行隐式转换。因此除非代码中有明确要求（使用等价的 C 类型），否则都应使用 Int（等 Swift 核心类型）。</p>
<table>
<thead>
<tr>
<th align="left">C</th>
<th align="left">Swift</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">CBool</td>
</tr>
<tr>
<td align="left">char, signed char</td>
<td align="left">CChar</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">CUnsignedChar</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">CShort</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">CUnsignedShort</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">CInt</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">CUnsignedInt</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">CLong</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">CUnsignedLong</td>
</tr>
<tr>
<td align="left">long long</td>
<td align="left">CLongLong</td>
</tr>
<tr>
<td align="left">unsigned long long</td>
<td align="left">UnsignedLongLong</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">CWideChar</td>
</tr>
<tr>
<td align="left">char16_t</td>
<td align="left">CChart16</td>
</tr>
<tr>
<td align="left">char32_t</td>
<td align="left">CChart32</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">CFloat</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">CDouble</td>
</tr>
</tbody></table>
<h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>定义在 C 和 Objective-C 源文件中的全局常量，会自动被 Swift 编译器引入为全局常量。</p>
<h4 id="导入的枚举和结构体"><a href="#导入的枚举和结构体" class="headerlink" title="导入的枚举和结构体"></a>导入的枚举和结构体</h4><p>在 Objective-C 中，常量通常用来为属性和函数参数提供一组可选值。Ojbective-C 中那些被 NS_STRING_ENUM 或 NS_EXTENSIBLE_STRING_ENUM 宏标注的 typedef 声明，会被 Swift 以普通类型的成员的方式导入。通过 NS_STRING_ENUM 声明的枚举不可以在添加额外的值进行扩展，而通过 NS_EXTENSIBLE_STRING_ENUM 声明的枚举，则可以在 Swift 的扩展（extension）中进行扩展。</p>
<p>通过 NS_STRING_ENUM 宏声明的一组常量，会被导入为结构体。例如，下面这段在 Objective-C 中 被声明为字符串常量的 TraficLightColor 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString * TrafficLightColor NS_STRING_ENUM;</span><br><span class="line">TrafficLightColor const TraficLightColorRed;</span><br><span class="line">TrafficLightColor const TraficLightColorYellow;</span><br><span class="line">TrafficLightColor const TraficLightColorGreen;</span><br></pre></td></tr></table></figure>

<p>下面是 Swift 导入后结果: </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrafficLightColor</span>: <span class="title">RawRepresentable</span> </span>&#123;<span class="comment">//注意区别，Swift 3 中是导入为枚举的</span></span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">RawValue</span> = <span class="type">String</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">RawValue</span>)</span><br><span class="line">	<span class="keyword">var</span> rawValue: <span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> red: <span class="type">TrafficLightColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> yellow: <span class="type">TrafficLightColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">var</span> green: <span class="type">TrafficLIghtColor</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 NS_EXTENSIBLE_STRING_ENUM 宏声明的一组可扩展的常量值，同样会被导入为结构体。例如，下面这段在 Objective-C 中被声明为字符串常量的 StateOfMatter 类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString * StateOfMatter NS_EXTENSIBLE_STRING_ENUM;</span><br><span class="line">StateOfMatter const StateOfMatterSolid;</span><br><span class="line">StateOfMatter const StateOfMatterLiquid;</span><br><span class="line">StateOfMatter const StateOfMatterGas;</span><br></pre></td></tr></table></figure>

<p>下面是 Swift 导入后结果:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateOfMatter</span>: <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">RawValue</span> = <span class="type">String</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">init</span>(<span class="keyword">_</span> rawValue: <span class="type">RawValue</span>) <span class="comment">//注意该构造器在 Swift 3中是没有的。</span></span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">RawValue</span>)</span><br><span class="line">	<span class="keyword">var</span> rawValue: <span class="type">RawValue</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> solid: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> liquid: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> gas: <span class="type">StateOfMatter</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以可扩展形式声明的常量，在被导入后，会额外添加一个可忽略参数标签的构造器，以便扩展添加新值。</p>
<p>通过 NS_EXTENSIBLE_STRING_ENUM 宏声明的常量，导入后，可在 Swift 代码中扩展添加新值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StateOfMatter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> plasma: <span class="type">StateOfMatter</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">StateOfMatter</span>(rawValue: <span class="string">&quot;plasma&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###函数</p>
<p>Swift可以把任何声明在 C 头文件中的函数作为全局函数导入。例如，下面的 C 函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">product</span><span class="params">(<span class="keyword">int</span> multiplier, <span class="keyword">int</span> multiplicand)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> devisor, <span class="keyword">int</span> *remainder)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Point2D <span class="title">createPoint2D</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">distance</span><span class="params">(struct Point2D from, struct Point2D to)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面是 Swift 导入后结果:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(<span class="keyword">_</span> multiplier: Int32, <span class="keyword">_</span> multiplicand: Int32)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quotient</span><span class="params">(<span class="keyword">_</span> dividen: Int32, <span class="keyword">_</span> devison: Int32, UnsafeMutablePointer&lt;Int32&gt;!)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPoint2D</span><span class="params">(<span class="keyword">_</span> x: Float, <span class="keyword">_</span> y: Float)</span></span> -&gt; <span class="type">Point2D</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distance</span><span class="params">(<span class="keyword">_</span> from: Point2D, <span class="keyword">_</span> to: Point2D)</span></span> -&gt; <span class="type">Float</span></span><br></pre></td></tr></table></figure>

<h4 id="变参函数-Variadic-Functions"><a href="#变参函数-Variadic-Functions" class="headerlink" title="变参函数(Variadic Functions)"></a>变参函数(Variadic Functions)</h4><p>在 Swift 中，可以通过 <code>getValist(\_:)</code> 或者 <code>withValist(\_:\_:)</code> 来调用 C 中诸如 vaspritf 这样的变参函数。 <code>getValist(\_:)</code> 函数接收一个包含 CVarArg 值的数组，并返回一个 CVaListPointer，与直接返回不同的是 <code>withValist(\_:\_:)</code> 通过接受一个闭包来实现。其结果 CVaListPointer 最后会作为 va_lsit 参数传递给 C 变参函数。</p>
<p>例如，下面的代码展示了如何在 Swift 中调用 vasprintf 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swiftprintf</span><span class="params">(format: String, argument: CVarArg...)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> withValist(arguments) &#123; va_list <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">var</span> buffer: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;? = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> format.withCstring &#123; <span class="type">CString</span> <span class="keyword">in</span> </span><br><span class="line">			<span class="keyword">guard</span> vasprintf(&amp;buffer, <span class="type">CString</span>, va_list) != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="type">String</span>(validatingUTF8: buffer!)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Swiftprintf</span>(format: <span class="string">&quot;√2 ≅ %g&quot;</span>, arguments: sqrt(<span class="number">2.0</span>))!)</span><br><span class="line"><span class="comment">// Prints &quot;√2 ≅ 1.41421&quot;</span></span><br></pre></td></tr></table></figure>

<pre><code>注意
可选类型指针不能传入 `withVaList(_:invoke:)` 函数，
可以通过 `Int.init(bitPattern:)` 构造函数，来将可选类型指针转为 Int，
在所有支持的平台上该指针的调用规则与 C 相同。</code></pre>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Swift 可以把任何头文件中声明的 C 结构体引入为 Swift 结构体，引入后的结构体会为每一个原 C 结构体成员生成一个存储型属性和一个逐一成员构造器。如果被引入的成员均有默认值，那么 Swift 同时会生成一个无参数的默认构造器。例如下面这个 C 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">	<span class="keyword">float</span> r, g, b;</span><br><span class="line">&#125;:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> <span class="title">Color</span>;</span></span><br></pre></td></tr></table></figure>

<p>下面是与之相应的 Swift 结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r: <span class="type">Float</span></span><br><span class="line">	<span class="keyword">var</span> g: <span class="type">Float</span></span><br><span class="line">	<span class="keyword">var</span> b: <span class="type">Float</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span>()</span><br><span class="line">	<span class="keyword">init</span>(r: <span class="type">Float</span>, g: <span class="type">Float</span>, b: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将函数引入为类型成员"><a href="#将函数引入为类型成员" class="headerlink" title="将函数引入为类型成员"></a>将函数引入为类型成员</h4><p>CoreFoundation 框架中的 C API，大都提供了用于创建、存取、以及修改 C 结构体的函数。可以通过在代码添加CF_SWIFT_NAME 宏标记，来让 Swift 将这些 C 函数引入为结构体的成员函数。例如，下面这段C函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Color <span class="title">ColorCreateWithCMYK</span><span class="params">(<span class="keyword">float</span> c, <span class="keyword">float</span> m, <span class="keyword">float</span> y, <span class="keyword">float</span> k)</span> <span class="title">CF_SWFIT_NAME</span><span class="params">(Color.init(c:m:y:k:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ColorGetHue</span><span class="params">(Color color)</span> <span class="title">CF_SWIFT_NAME</span><span class="params">(getter:Color.hue(self:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ColorSetHue</span><span class="params">(Color color, <span class="keyword">float</span> hue)</span> <span class="title">CF_SWIFT_NAME</span><span class="params">(setter:Color.hue(self:newvalue))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorDarkenColor</span><span class="params">(Color color, flaot amout)</span> <span class="title">CF_SWIFT_NAME</span><span class="params">(Color.Darken(self:amount:))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">const</span> Color ColorBondiBlue <span class="title">CF_SWIFT_NAME</span><span class="params">(Color.boundiBlue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorGetCalibrationColor</span><span class="params">(<span class="keyword">void</span>)</span> <span class="title">CF_SWIFT_NAME</span><span class="params">(getter:Color.calibration())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Color <span class="title">ColorSetCalibrationColor</span><span class="params">(Color color)</span> <span class="title">CF_SWIFT_NAME</span><span class="params">(setter:Color.calibration(newValue:))</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面展示了 Swift 如何将它们以类型成员的方式导入：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">color</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>(<span class="built_in">c</span>: <span class="type">Float</span>, m: <span class="type">Float</span>, y: <span class="type">Float</span>, k: <span class="type">Float</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> hue: <span class="type">Float</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">darken</span><span class="params">(amount: Float)</span></span> -&gt; <span class="type">Color</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> bondiBlue: <span class="type">Color</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> calibration: <span class="type">Color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入 CF_SWIFT_NAME 宏的参数语法与 <code>#selector</code> 表达式相同。CF_SWIFT_NAME 宏中的 self，表示接收该方法的实例对象。</p>
<pre><code>注意
使用 CF_SWIFT_NAME 宏时不能改变被引入成员函数的参数顺序和数量。
如果想更Swift点，可以重写一个Swift函数，然后在其内部再调用所需的 C 函数
（译者：用Swift再做一层封装）</code></pre>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Swift 可以把任何使用 NS_ENUM 宏标记的 C 枚举引入为 Int 类型的 Swift 枚举。无论是系统框架还是其它代码，引入后的枚举都会自动移除原命名前缀，<br>例如，下面这个通过 NS_ENUM 宏声明的 C 枚举:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSInteger, UITableViewCellStyle)</span></span>&#123;</span><br><span class="line">	UITableViewCellStyleDefault, </span><br><span class="line">	UITableViewCellStyleValue1, </span><br><span class="line">	UITableViewCellStyleValue2, </span><br><span class="line">	UITableViewCellStyleSubtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 导入后，会呈现为以下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UITableViewCellStyle</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> &#x27;<span class="keyword">default</span>&#x27;</span><br><span class="line">	<span class="keyword">case</span> value1</span><br><span class="line">	<span class="keyword">case</span> value2</span><br><span class="line">	<span class="keyword">case</span> subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过点语法（译者注：.valueName）来引用一个枚举值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cellStyle: <span class="type">UITableViewCellStyle</span> = .<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<pre><code>注意：
Swift 引入的 C 枚举，在构造时即使入参与声明不一致，也不会导致构造失败。
这么处理是为了与 C 兼容，因为 C 枚举允许任意类型的值，即使这个值没有暴露在头文件中，
而仅仅是供内部使用。</code></pre>
<p>那些使用 NS_ENUM 或 NS_OPTIONS 宏声明的 C 枚举会被导入为 Swift 结构体。C 枚举中的每个成员都会被导入为一个与结构体类型相同的只读的全局计算型属性，而非结构体成员属性。</p>
<p>例如，下面这个未使用 NS_ENUM 宏声明的 C 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	MessageDispositionUnread = <span class="number">0</span>,</span><br><span class="line">	MessageDispositionRead = <span class="number">1</span>,</span><br><span class="line">	MessageDispositionDeleted = <span class="number">-1</span></span><br><span class="line">&#125; MessageDisposition;</span><br></pre></td></tr></table></figure>

<p>在 Swift 中，它会被导入为以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MessageDisposition: RawRePresentable, Equatable&#123;&#125;</span><br><span class="line"></span><br><span class="line">var MessageDispositionUnread: MessageDisposition &#123; get &#125;</span><br><span class="line">var MessageDispositionRead: MessageDisposition &#123; get &#125;</span><br><span class="line">var MessageDispositionDeleted: MessageDisposition &#123; get &#125;</span><br></pre></td></tr></table></figure>
<p>Swift 会自动为导入的 C 枚举类型适配 Equaltable 协议。</p>
<h4 id="选项型枚举（Option-sets）"><a href="#选项型枚举（Option-sets）" class="headerlink" title="选项型枚举（Option sets）"></a>选项型枚举（Option sets）</h4><p>Swift 同样可以把 NS_OPTIONS 宏标注的 C 选项型枚举导入为 Swift 的选项（Option set）。与先前枚举的引入类似，选项的命名前缀也会被移除。<br>例如，下面这个在 Objective-C 声明的选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing)&#123;</span><br><span class="line">	UIViewAutoresizingNone &#x3D; 0,</span><br><span class="line">	UIViewAutoresizingFlexibleLeftMargin &#x3D; 1 &lt;&lt; 0,</span><br><span class="line">	UIViewAutoresizingFlexibleWidth &#x3D; 1 &lt;&lt; 1, </span><br><span class="line">	UIViewAutoresizingFlexibleRightMargin &#x3D; 1 &lt;&lt; 2,</span><br><span class="line">	UIViewAutoresizingFlexibleTopMargin &#x3D; 1 &lt;&lt; 3,</span><br><span class="line">	UIViewAutoresizingFlexibleHeight &#x3D; 1 &lt;&lt; 4,</span><br><span class="line">	UIViewAutoresizingFlexibleBottomMargin &#x3D; 1 &lt;&lt; 5</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 Swift 中会被导入为以下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UIViewAutoresizing</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleLeftMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleWidth: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleRightMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleTopMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleHeight: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> flexibleBottomMargin: <span class="type">UIViewAutoresizing</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中，选项型枚举实际上是整型位掩码。既可以通过位或运算符（｜）来组合选项值，又可以通过位与运算符（&amp;)检查选项值。我们还可以通过常量或表达式来创建选项，空选项用常量零（0）表示。</p>
<p>在 Swift 中，选项是以一个遵从 OptionSet 协议的结构体来实现的，每个选项都是该结构体的一个静态变量。与枚举类似，我们既可以通过字面量数组来创建一个选项，又可以通过点（.）语法获取选项的一个值。一个空的选项既可以通过字面量空数组（［］）创建，也可以通过调用其默认构造函数创建。</p>
<pre><code>注意
当引入 NS_OPTIONS 宏标记的 C 枚举时，任何值为 0 的选项成员都会被 Swift 标记为无效，
因为 Swift 中使用空选项来表示没有选项。</code></pre>
<p>选项与 Swift 中的 Set 集合类型相似，可以通过 <code>insert(\_:)</code> 或 <code>formUnion(\_:)</code> 函数添加选项值，也可以通过 <code>remove(\_:)</code> 或 <code>substract(\_:)</code> 函数删除一个选项值，还可以通过 <code>contains(\_:)</code> 来查验选项值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options: <span class="type">Data</span>.<span class="type">Base64EncodingOptions</span> = [</span><br><span class="line">	.lineLength64Characters,</span><br><span class="line">	.endLineWithLineFeed</span><br><span class="line">]</span><br><span class="line">	</span><br><span class="line"><span class="keyword">let</span> string = data.base64EncodedString(options:options)</span><br></pre></td></tr></table></figure>

<h4 id="联合体（Unions）（译者注：该部分为新增加内容个，Swift-3-是不支持的）"><a href="#联合体（Unions）（译者注：该部分为新增加内容个，Swift-3-是不支持的）" class="headerlink" title="联合体（Unions）（译者注：该部分为新增加内容个，Swift 3 是不支持的）"></a>联合体（Unions）（译者注：该部分为新增加内容个，Swift 3 是不支持的）</h4><p>Swift 会把 C 联合体导入为 Swift 的结构体。虽然 Swift 不支持联合体，但是被导入后其使用仍与 C 联合体非常相似。例如，下面这个拥有 isAlive 和 isDead 两个域的联合体 SchroedingersCat:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">SchroedingersCat</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> isAlive;</span><br><span class="line">	<span class="keyword">bool</span> isDead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Swift 中会将其导入为一下形式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">sturct <span class="type">SchroedingsCat</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> isAlive: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> isDead: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span>(isAlive: <span class="type">Bool</span>)</span><br><span class="line">	<span class="keyword">init</span>(isDead: <span class="type">Bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 C 中的联合体所有域共享一段内存，所以被 Swift 导入后生成的所有计算型属性也具有相同的内存结构。因此，当改变任何一个该结构体实例的计算型属性时，那么该实例的其它属性也会发生相应改变。</p>
<p>例如下面这个例子，当改变 SchroedingersCat 实例上的 isAlive 计算型属性时，其另一个计算型属性 isDead 也发生来相应的变化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mittens = <span class="type">SchroedingersCat</span>(isAlive: fasle)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mittens.isAlive, mittens.isDead)</span><br><span class="line"><span class="comment">// Prints &quot;fasle false&quot;</span></span><br><span class="line"></span><br><span class="line">mittens.isAlive = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(mittens.isDead)</span><br><span class="line"><span class="comment">// Prints &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="位域（Bit-Fields）"><a href="#位域（Bit-Fields）" class="headerlink" title="位域（Bit Fields）"></a>位域（Bit Fields）</h4><p>Swift 可以把结构体中的位域，例如 Foundation 中的 NSDecimal 类型，导入为计算型属性。在对其进行访问时，Swift 会自动将其值转换为与 Swift 相兼容的类型。</p>
<h4 id="匿名的结构体和联合体域（Union-Fields）"><a href="#匿名的结构体和联合体域（Union-Fields）" class="headerlink" title="匿名的结构体和联合体域（Union Fields）"></a>匿名的结构体和联合体域（Union Fields）</h4><p>(译者注：这里变化很大，且受限译者理解水平，翻译的可能不够准确)</p>
<p>C 中的 Struct 和 union 类型可定义成匿名或者匿名类型，匿名域由具名的相邻结构题或联合体类型组成。</p>
<p>例如，这个名为 Cake 的 C 结构体，它包含一个拥有 layers 和 height 两个相邻域的匿名联合体，以及一个域为 toppings的匿名结构题类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cake</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> layers;</span><br><span class="line">		<span class="keyword">double</span> height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">bool</span> icing;</span><br><span class="line">		<span class="keyword">bool</span> sprinkles;</span><br><span class="line">	&#125; toppings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Cake 被导入后，可以这样初始化并调用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simpleCake = <span class="type">Cake</span>()</span><br><span class="line">simpleCake.layers = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(simpleCake.toppings.icing)</span><br><span class="line"><span class="comment">//	Prints &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>Cake 在被导入后，会生成一个逐一成员构造器，可为其域传自定义值来构造该结构体，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cake = <span class="type">Cake</span>( .<span class="keyword">init</span>(layers: <span class="number">2</span>), toppings: .<span class="keyword">init</span>(icing: <span class="literal">true</span>, sprinkles: <span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The cake has \(cake.layers) layers&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The cake has 2 layers.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Does it have sprinkes?&quot;</span>, cake.toppings.sprinkles ? <span class="string">&quot;Yes.&quot;</span> : <span class="string">&quot;No.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Does it have sprinkles? No.&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于 Cake 结构体的第一个域是匿名的，所以它的构造器的第一个参数也没有标签。由于 Cake 结构体的域含有匿名类型，所以使用 .init 构造器，通过类型推断的方式来为结构体的每个匿名域设置初始值。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Swift 一直在尽力避免直接访问指针。但仍提供了丰富的指针类型以备不时之需。下表使用 Type 来指代不同语言的相应类型。</p>
<p>变量、参数、返回值的指针对照关系如下：</p>
<table>
<thead>
<tr>
<th align="left">C Syntax</th>
<th align="left">Swift Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const Type *</td>
<td align="left">UnsafePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type *</td>
<td align="left">UnsafeMutablePointer&lt;Type&gt;</td>
</tr>
</tbody></table>
<p>类类型指针对照关系如下：</p>
<table>
<thead>
<tr>
<th align="left">C Syntax</th>
<th align="left">Swift Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Type * const *</td>
<td align="left">UnsafePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type * __strong *</td>
<td align="left">UnsafeMutablePointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">Type **</td>
<td align="left">AutoreleasingUnsafeMutablePointer&lt;Type&gt;</td>
</tr>
</tbody></table>
<p>无类型指针与原始内存（指针）的对照关系表：(译者注：swift 3中是不存在的)</p>
<table>
<thead>
<tr>
<th align="left">C Syntax</th>
<th align="left">Swift Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const void *</td>
<td align="left">UnsafeRawPointer&lt;Type&gt;</td>
</tr>
<tr>
<td align="left">void *</td>
<td align="left">UnsafeMutableRawPointer&lt;Type&gt;</td>
</tr>
</tbody></table>
<p>Swift 还提供来用于操作缓存的指针类型，请参见 缓存指针(Buffer Pointers)。</p>
<p>如果 Swift 中没有与 C 指针所指内容相应的类型，例如，一个不完全的结构体（incomplete struct）类型，那么这个指针会被导入为 OpaquePointer。</p>
<h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>一个接受 UnsafePointer&lt;Type&gt; 类型参数的函数，同样可以接受下列类型参数：</p>
<ul>
<li>一个 UnsafePointer&lt;Type&gt;，UnsafeMutalbePointer&lt;Type&gt;，或 AutoreleasingUnsafeMutablePointer&lt;Type&gt; 类型的值，如有必要它会被转换为 UnsafePointer&lt;Type&gt; 类型。</li>
<li>如果 Type 是 <code>Int8</code> 或 <code>UInt8</code> ，则可接受一个 String 类型的值。该字符串会自动被转换为一个 UTF8 字符缓存（buffer），然后将指向该缓存（buffer）的指针传入该函数。</li>
<li>一个包含一个或多个变量、属性、Type 类型下标引用的 in-out 表达式。表达式会以指向左起首位参数内存地址的指针形式被传入。</li>
<li>［Type］（一个含有Type类型元素的数组）,会以指向数组首地址的指针形式传入。</li>
</ul>
<p>传入函数的指针，仅保证在函数调用期间有效。不要尝试持有或在函数返回后访问该指针。</p>
<p>例如，这样一个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafePointer&lt;Float&gt;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样调用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span></span><br><span class="line">takesAPointer(&amp;x)</span><br><span class="line">takesAPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br></pre></td></tr></table></figure>

<p>一个接受 UnsafePointer&lt;Void&gt; 类型参数的函数，同样可以接受相同操作数的任意 Type 类型的 UnsafePointer&lt;Type&gt; 指针。</p>
<p>例如下面这个函数：（译者注：注意无类型指针的变动，由Void变成了Raw）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesARawPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafeRawPointer?)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">takesARawPointer(&amp;x)</span><br><span class="line">takesARawPointer(&amp;y)</span><br><span class="line">takesARawPointer([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] <span class="keyword">as</span> [<span class="type">Float</span>])</span><br><span class="line"><span class="keyword">let</span> intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">takesARawPointer(intArray)</span><br></pre></td></tr></table></figure>

<h4 id="可变指针（Mutable-Pointers）"><a href="#可变指针（Mutable-Pointers）" class="headerlink" title="可变指针（Mutable Pointers）"></a>可变指针（Mutable Pointers）</h4><p>一个接受 UnsafeMutablePointer&lt;Type&gt;类型参数的函数，同样可以接受下列类型参数：</p>
<ul>
<li>一个 UnsafeMutablePointer&lt;Type&gt; 类型的值</li>
<li>一个含有一个或多个变量、属性、Type类型下标引用的 in-out 表达式，以指向多个值地址的指针的形式被传入。</li>
<li>一个包含多个变量、属性、或下标引用的［Type］类型的 in-out表达式，会以指向该数组起始地址的指针形式传入，与此同时其生命周期会被延长，持续于整个函数调用期间。</li>
</ul>
<p>例如下面这个函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(<span class="keyword">_</span> p: UnsafeMutablePointer&lt;Float&gt;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">var</span> a: [<span class="type">Float</span>] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">takesAMutablePointer(&amp;x)</span><br><span class="line">takesAMutablePointer(&amp;a)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">一个接受 <span class="type">UnsafeMutableRawPointer</span>\&lt;<span class="type">Void</span>\&gt; 类型参数的函数，同样可以接受相同操作数的任意 <span class="type">Type</span> 类型 的 <span class="type">UnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt; 指针。</span><br><span class="line"></span><br><span class="line">例如下面这个函数：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="comment">//译者注：注意无类型指针的变化。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAMutableRawPointer</span><span class="params">(<span class="keyword">_</span> p: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Float</span> = <span class="number">0.0</span>, y: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> a: [<span class="type">Float</span>] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], b: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">takesAMutableRawPointer(&amp;x)</span><br><span class="line">takesAMutableRawPointer(&amp;y)</span><br><span class="line">takesAMutableRawPointer(&amp;a)</span><br><span class="line">takesAMutableRawPointer(&amp;b)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">#### 自释放指针（autoreleasing <span class="type">Pointers</span>）</span><br><span class="line"></span><br><span class="line">一个接受 <span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt; 类型参数的函数，同样可以接受下列类型参数：</span><br><span class="line"></span><br><span class="line">- 一个 <span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">Type</span>\&gt; 类型的值</span><br><span class="line">- 一个含有一个或多个变量、属性、<span class="type">Type</span>类型下标引用的 <span class="keyword">in</span>-out 表达式，它会被按位拷贝到一个非持有的临时缓存，随之指向该缓存的指针会被传入，并且在返回时，缓存中的值会被加载，持有，并赋值到操作数中。</span><br><span class="line"></span><br><span class="line">注意：上表<span class="keyword">_</span>不包含数组<span class="keyword">_</span>。</span><br><span class="line"></span><br><span class="line">例如下面这个函数：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(<span class="keyword">_</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以这样被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">NSDate?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="type">AutoreleasingUnsafeMutablePointer</span>(&amp;x)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">指针所指的类型不会被转换（bridged）。例如，<span class="type">NSString</span> \*\* 会被 <span class="type">Swift</span> 导入为 <span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">NSString?</span>\&gt;，而不是 <span class="type">AutoreleasingUnsafeMutablePointer</span>\&lt;<span class="type">String?</span>\&gt;。</span><br><span class="line"></span><br><span class="line">#### 函数指针</span><br><span class="line"></span><br><span class="line">通过 <span class="meta">@convention</span>(<span class="built_in">c</span>) 标注，<span class="type">Swift</span> 会根据 <span class="type">C</span> 函数指针调用规则将其引入为闭包。例如，一个 `int (x) (void)`类型的 <span class="type">C</span> 函数指针，在 <span class="type">Swift</span> 中会被导入为 `@convertion(<span class="built_in">c</span>) () -&gt; <span class="type">Int32</span>` 。当调用一个接受函数指针类型参数的函数时，可以直接传入一个顶级的 <span class="type">Swift</span> 函数，一个 closure literal，或者 <span class="literal">nil</span>。还可以传入一个泛型闭包属性，或者一个闭包参数列表和者闭包体中都没有引用泛型参数的泛型函数。例如，<span class="type">Core</span> <span class="type">Foundation</span> 中的 `<span class="type">CFArrayCreateMutable</span>(<span class="keyword">_</span>:<span class="keyword">_</span>:<span class="keyword">_</span>:)` 函数。`<span class="type">CFArrayCreateMutable</span>(<span class="keyword">_</span>:<span class="keyword">_</span>:<span class="keyword">_</span>:)` 函数，接受一个初始化为函数指针的 <span class="type">CFArrayCallBacks</span> 结构体：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(<span class="keyword">_</span> p: UnsafeRawPointer?)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;? &#123;</span><br><span class="line">	<span class="comment">// return an Unmanaged&lt;CFString&gt;? value</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">var</span> callBacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">	version: <span class="number">0</span>,</span><br><span class="line">	retain: <span class="literal">nil</span>,</span><br><span class="line">	release: <span class="literal">nil</span>,</span><br><span class="line">	copyDescription: customCopyDescription,</span><br><span class="line">	<span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">DarwinBoolean</span> <span class="keyword">in</span> </span><br><span class="line">		<span class="comment">// return Bool value</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"> 	</span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, &amp;callbacks)</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">上面的例子中，<span class="type">CFArrayCallBacks</span>的构造函数，把 <span class="literal">nil</span> 分别赋值给 retain 和 release 参数，把 `customCopyDescription(<span class="keyword">_</span>:)` 函数作为参数赋给 copyDescription，并把一个闭包体作为参数赋值 <span class="built_in">equal</span>。</span><br><span class="line"></span><br><span class="line">	注意：</span><br><span class="line">	<span class="type">Only</span> <span class="type">Swift</span> function types with <span class="type">C</span> function reference calling convention may be used <span class="keyword">for</span> function pointer arguments. <span class="type">Like</span> a <span class="type">C</span> function pointer, a <span class="type">Swift</span> function type with the @convertions(<span class="built_in">c</span>) attribute does not capture the context of its surrounding scope.</span><br><span class="line"></span><br><span class="line">	欲了解跟多详情，请访问 _The <span class="type">Swift</span> <span class="type">Programming</span> <span class="type">Language</span> (<span class="type">Swift</span> <span class="number">4</span>) 中有关 <span class="type">Type</span> <span class="type">Attributes</span> 一节。</span><br><span class="line"></span><br><span class="line">#### 缓存指针（<span class="type">Buffer</span> <span class="type">Pointers</span>）</span><br><span class="line"></span><br><span class="line">缓存指针通常用于访问一个低级的内存区域。例如，使用缓存指针来高效地处理应用与服务器之间的数据交换。</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span> 有一下几种缓存指针类型：</span><br><span class="line"></span><br><span class="line">- <span class="type">UnsafeBufferPointer</span></span><br><span class="line">- <span class="type">UnsafeMutableBufferPointer</span></span><br><span class="line">- <span class="type">UnsafeRawBufferPointer</span></span><br><span class="line">- <span class="type">UnsafeMutableRawBufferPointer</span></span><br><span class="line"></span><br><span class="line">类型明确的缓存指针，<span class="type">UnsafeBufferPointer</span> 和 <span class="type">UnsafeMutableBufferPointer</span> 允许你查看或者改变一个相邻的内存块儿。该类型允许你把内存作为一个集合来访问，<span class="keyword">where</span> each item <span class="keyword">is</span> an instance of the buffer type&#x27;s <span class="type">Element</span> generic type parameter.</span><br><span class="line"></span><br><span class="line">原始缓存指针类型，<span class="type">UnsafeRawBufferPointer</span> 和 <span class="type">UnsafeMutableRawBufferPointer</span>，允许你把一整块儿的内存作为一个含有 <span class="type">Uint8</span> 值的集合进行查看和修改，在这块内存中，每个值与一个字节的内存相对应。这些类型允许你进入底层编程模式，与此同时直接内存操作也将得不到来自编译器类型安全检查帮助的，相应的对同一内存进行不同类型的解释也是不受限的（译者注：最后一句这里翻译地不准去）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 空指针</span><br><span class="line">在 <span class="type">Objective</span>-<span class="type">C</span> 中，指针类型的声明可以通过标注 \_Nullable 和 \_Nonnull 来表明是否可以接受空值 <span class="literal">nil</span> 或 <span class="type">NULL</span>。在 <span class="type">Swift</span> 中，空指针是通过一个值为 <span class="literal">nil</span> 的可选类型指针来实现。透过一个整数内存地址来构造指针，是可失败的。一个非可选的指针类型不能被赋值为 <span class="literal">nil</span>。</span><br><span class="line"></span><br><span class="line">对应关系如下：</span><br><span class="line"></span><br><span class="line">|  <span class="type">Objective</span>-<span class="built_in">c</span> <span class="type">Syntax</span>   |   <span class="type">Swift</span> <span class="type">Syntax</span>       |</span><br><span class="line">|:----------------------|:---------------------|</span><br><span class="line">|const <span class="type">Type</span> \* \_Nonnull|<span class="type">UnsafePointer</span>\&lt;type\&gt; |</span><br><span class="line">|const <span class="type">Type</span> * \_Nullable|<span class="type">UnsafePointer</span>\&lt;type\&gt;?|</span><br><span class="line">|const <span class="type">Type</span> \* _Null\_unspecified|<span class="type">UnsafePointer</span>\&lt;type\&gt;!|</span><br><span class="line"></span><br><span class="line">	注意(译者注：在<span class="type">Swift</span> <span class="number">4</span>版本中该注意内容以被移除)</span><br><span class="line">	在<span class="type">Swift</span> <span class="number">3</span>之前，nullable和non-nullable指针均通过一个非可选（non-<span class="keyword">optional</span>）指针类型实现。</span><br><span class="line">	将现有代码迁移至<span class="type">Swift</span>最新版本时，可能需要手动修改所有通过<span class="literal">nil</span>初始化的指针为可选类型。</span><br><span class="line">	</span><br><span class="line">#### 指针运算</span><br><span class="line">当处理未知数据类型时，可能会用到不安全的指针操作。在<span class="type">Swift</span>中，可通过运算符对一个指针的值进行位运算，以此来创建一个指定偏移量的新指针。</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="keyword">let</span> pointer: <span class="type">UnsafePointer</span>&lt;<span class="type">Int8</span>&gt;</span><br><span class="line"><span class="keyword">let</span> offsetPointer = pointer + <span class="number">24</span></span><br><span class="line"><span class="comment">// offsetPointer is 24 strides ahead of pointer</span></span><br><span class="line"><span class="comment">// offsetPointer 是一个向前偏移了24位的新指针</span></span><br></pre></td></tr></table></figure>
<pre><code>注意
如欲了解更多关于 Swift 是如何计算不同数据类型和值的空间大小的，请参考 数据类型空间计算（Data Type Size Calculation）。</code></pre>
<h4 id="数据类型空间计算（Data-Type-Size-Calculation）（译者注：注意该部分内容变动很大）"><a href="#数据类型空间计算（Data-Type-Size-Calculation）（译者注：注意该部分内容变动很大）" class="headerlink" title="数据类型空间计算（Data Type Size Calculation）（译者注：注意该部分内容变动很大）"></a>数据类型空间计算（Data Type Size Calculation）（译者注：注意该部分内容变动很大）</h4><p>在 C 语言中，可以通过 sizeof 和 alignof 操作符来获取任意变量或数据类型的内存占用大小及对齐情况。在 Swift 中可以通过访问 MemoryLayout<T> 的 size, stride 和 alignment 属性来了解 T 类型的相应情况。例如，timeval 结构体在 Darwin 系统上所占的空间大小和步长是 16, 对齐为 8:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">MemoryLayout</span>&lt;timeval&gt;.size)</span><br><span class="line"><span class="comment">// Prints &quot;16&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">MemoryLayout</span>&lt;timeval&gt;.<span class="built_in">stride</span>)</span><br><span class="line"><span class="comment">// Prints &quot;16&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">MemoryLayout</span>&lt;timeval&gt;.alignment)</span><br><span class="line"><span class="comment">// Prints &quot;8&quot;</span></span><br></pre></td></tr></table></figure>

<p>当在 Swift 中调用的 C 函数需要传入类型大小或值大小的时候，这些就派上用场了。例如，setsockopt(_:_:_:_:_:)函数，可以通过接受一个 timeval 指针和指针所指值的大小来设置sokect接收超时选项（SO_RCVTIMEO）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sokfd = socket(<span class="type">AF_INET</span>, <span class="type">SOCK_STREAM</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> optval = timeval(tv_sec: <span class="number">30</span>, tv_usec: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> optlen = socklen_t（<span class="type">MemoryLayout</span>&lt;timeval&gt;.size)</span><br><span class="line"><span class="keyword">if</span> setsockopt(sockfd, <span class="type">SOL_SOCKET</span>, <span class="type">SO_RCVTIMEO</span>, &amp;optavl, optlen) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>欲了解更多信息，请参见 MemoryLayout</p>
<h3 id="仅一次的初始化（One-Time-Initialization）"><a href="#仅一次的初始化（One-Time-Initialization）" class="headerlink" title="仅一次的初始化（One-Time Initialization）"></a>仅一次的初始化（One-Time Initialization）</h3><p>在 C 语言中，POSIX 的 <code>pthread_once()</code> 函数和 Grand Central Dispatch 中的 <code>dipatch_once()</code>、<code>dispatch_once_f()</code> 函数都有保证代码仅被初始化一次的机制。在 Swift 中，全局常量和存储型属性即使被多个线程同时交替存取，也能保证仅初始化一次。这是由语言自身特点来实现的, 因此 POSIX 和 Grand Central Dispatch 中相应的 C 函数未在 Swift 开放。</p>
<h3 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h3><p>Swift 编译器没有预处理程序。相应地，它通过编译属性，条件编译 block，和语言特性来实现相同功能。因此，预处理命令不会被导入到 Swift 中。</p>
<h3 id="简单宏命令"><a href="#简单宏命令" class="headerlink" title="简单宏命令"></a>简单宏命令</h3><p>在 Swift 中可通过全局常量来代替，在 C 和 Objective-C 中由 #define 定义的常量。例如，#define FADE_ANNOTATION_DURATION 0.35，可以在 Swift 中被更好的表示为 let FADE_ANNOTATION_DURATION = 0.35。由于宏定义的常量可以被直接映射为 Swift 的全局变量，所以编译器会自动引入那些定在 C 和 Objective—C 源文件中的简单宏定义。</p>
<h3 id="复杂宏命令"><a href="#复杂宏命令" class="headerlink" title="复杂宏命令"></a>复杂宏命令</h3><p>Swift 没有与 C 或 Objective-C 中的复杂宏命令相应的构功能特性，这里的复杂宏是指那些带有括号，与函数类似，却未用于定义常量的宏。C 和 Objective-C 中的复杂宏命令通常被用来规避类型检查限制，或者充当被大量使用的代码的模板。与此同时宏也让debuging和重构变困难。Swfit中可以通过函数和泛型来更好地达到这一目的。综上，C 和Objective-C中的复杂宏命令在Swift代码中是无效。</p>
<h3 id="条件编译代码块（Conditional-Compilation-Blocks"><a href="#条件编译代码块（Conditional-Compilation-Blocks" class="headerlink" title="条件编译代码块（Conditional Compilation Blocks)"></a>条件编译代码块（Conditional Compilation Blocks)</h3><p>Swift 和 Objective-C 通过不同的方式实现了代码的条件编译。Swift 通过_条件编译代码块_来实现。例如，如果通过 swift -D DEBUG_LOGGING 设置 DEBUG_LOGGING 条件编译标识，那么编译器就会引入位于条件代码块中的代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> <span class="type">DEBUG_LOGGING</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flag enabled.&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<p>编译条件判断中可以包含 true 和 false 字面值，自定义条件判断标识（通过 -D &lt;#flag#&gt;指定)，和下表所列的平台判断标识。</p>
<table>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">Valid arguments</th>
</tr>
</thead>
<tbody><tr>
<td align="left">os()</td>
<td align="left">OSX, iOS, watchOS, tvOS, Linux</td>
</tr>
<tr>
<td align="left">arch()</td>
<td align="left">x86_64, arm, arm64, i386</td>
</tr>
<tr>
<td align="left">swift()</td>
<td align="left">&gt;=followed by version number</td>
</tr>
</tbody></table>
<pre><code>注意
通过arch(arm)来判断ARM 64设备，不会返回true。当代码以32位iOS模拟器为目标编译时，arch(i386)会返回true。</code></pre>
<p>通过逻辑与 &amp;&amp; 和逻辑或 || 符号可以混合判断条件，通过逻辑否 ！可以做假条件判断，还可以通过 #elseif 和 #else 来添加条件判断分支，此外在一个选择编译代码块儿中还能嵌套另一个选择编译代码块儿。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">#if</span> arch(arm) || arch(arm64)</span><br><span class="line">	<span class="keyword">#if</span> <span class="type">Swift</span>(&gt;=<span class="number">3.0</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Using Swift 3 ARM code&quot;</span>)</span><br><span class="line">	<span class="keyword">#else</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;Using Swift 2.2 ARM code&quot;</span>)</span><br><span class="line">	<span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#elseif</span> arch(x86_64)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Using 64-bit x86 code.&quot;</span>)</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Using general code.&quot;</span>)</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<p>与 C 语言的预编译不同，Swift 的条件编译代码块儿必须完整且语法正确，这是因为 Swift 代码即使尚未被编译，也会进行语法检查。<br>特例，如果条件编译代码块儿包含 swift() 判断，那么这个表达式仅在 Swift 版本与判断条件相匹配的时候才会去解析该表达式。这是为了确保旧版编译器不会去尝试解析较新版本的 Swift 语法。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文译自《Using Swift with Cocoa and Objective-C （Swift 4 beta）》书中 Interacting with C APIs 一章。相对于 Swift 3 新版本既对原有实现作出了改变，又有新增加了一些对 C 的支持，为了便于对比还是选择新开了一篇文章。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>C 语言</tag>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】不安全的Swift：通过指针与 C 交互</title>
    <url>/2017/01/10/Unsafe-Swift-Using-Pointers-And-Interacting-With-C/</url>
    <content><![CDATA[<p>默认情况下，Swift 是内存安全的，这意味着禁止对内存进行直接访问，并确保所有对象在使用前都已被正确初始化。既然是“默认”，那么就意味着如果有需要，Swift 还是允许通过指针对内存进行直接访问的。</p>
<a id="more"></a> 

<p>本文将带你领略 Swift 的 “Unsafe” 特性。这里的 “Unsafe“ 可能有点让人困惑，它并不意味着你写的代码即危险又糟糕，相反它是在提醒你，提醒你要格外小心地编写自己的代码，因为编译器将不在帮你进行一些必要的审查。</p>
<p>在运用 Swift 一些非安全特性与诸如 C 这类非安全语言交互之前，我们还需要了解一些额外的与运行相关的知识。本文讨论的是一个进阶性的话题，如果有 Swift 基础，那么你会更好的理解本文所涉内容。C 语言开发经验也会有所帮助，但不是必须的。</p>
<h2 id="开始（Getting-Started）"><a href="#开始（Getting-Started）" class="headerlink" title="开始（Getting Started）"></a>开始（Getting Started）</h2><p>本文由三个 playgrounds 构成。首先，会通过几段代码来熟悉一些内存排布和非安全指针操作的相关知识。其次，会把一个用于数据流压缩的 C API 封装成 SWift API。最后, 创建一个全平台的随机数生成器用于取代<strong>arc4random</strong>, 并通过 Unsafe Swift 相关技术向用户隐藏细节.</p>
<p>首先新建一个 playground, 命名为 <strong>UnsafeSwift</strong>。 平台任意, 本文所涉的代码均无平台限制。接下来导入 Foundation 框架。</p>
<h2 id="内存排布（Memory-Layout）"><a href="#内存排布（Memory-Layout）" class="headerlink" title="内存排布（Memory Layout）"></a>内存排布（Memory Layout）</h2><p><em>【译者注】这一小节翻译的特别不好，尤其是“内存对齐”，为了避免误导，如果你从未了解过内存排布知识，请先参考其它书籍了解相关知识，如《计算机系统》</em></p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/01/memory-480x214.png" alt="Sample memory"></p>
<p>Swift 的非安全操作直接与系统内存打交道。内存可以被看做是一系列排列整齐的盒子（实际上有数以亿计之多），每个里面都有一个数字。每个盒子都有一个唯一的<strong>内存地址</strong>与之关联。最小的存储地址单元被称为一个 <strong>字节（byte）</strong>，它通常由 8 个连续的<strong>比特（bit）</strong>构成。一个 8 位的字节可以存储 0-255 的任意数值。虽然一个单词占据的内存通常不只一个字节，但是处理器同样可以对其进行高效存取。以64位系统为例，一个字母是 8 字节 64 个比特。</p>
<p>通过 Swift 提供的 <strong>MemoryLayout</strong> 表达式可以查看内存中对象的大小和对齐情况。</p>
<p>在 playground 中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.size          <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.alignment     <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.<span class="built_in">stride</span>        <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.size        <span class="comment">// returns 2</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment   <span class="comment">// returns 2</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span>      <span class="comment">// returns 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.size         <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.alignment    <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.<span class="built_in">stride</span>       <span class="comment">// returns 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.size        <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.alignment   <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.<span class="built_in">stride</span>      <span class="comment">// returns 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.size       <span class="comment">// returns 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.alignment  <span class="comment">// returns 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.<span class="built_in">stride</span>     <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p><code>MemoryLayout&lt;Type&gt;</code> 用于在编译期侦测指定类型的 <strong>size</strong>，<strong>alignmen</strong> 和 <strong>stride</strong>，其返回值以字节为单位。例如，<strong>Int16</strong> 在 <strong>size</strong> 上占用两个字节，且恰好与两个字节 <strong>对齐</strong>，占满两个字节。</p>
<p>举个例子，在地址100上开辟一个 <strong>Int16</strong> 是合法的，101则不可以，因为这违反内存对齐原则（译者注：0偏移）。</p>
<p>当有一串 <strong>Int16</strong> 时，那么她们每个之间以一个 <strong>stride</strong> 串联在一起，基础类型的 <strong>size</strong> 和 <strong>stirde</strong> 相同。（译者注：类似链表？）</p>
<p>接下来，在playground中添加如下代码，看看用户定义的结构体在内存中的排布情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyStruct</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.size      <span class="comment">// returns 0</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.alignment <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SampleStruct</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> number: <span class="type">UInt32</span></span><br><span class="line"><span class="keyword">let</span> flag: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.size       <span class="comment">// returns 5</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.alignment  <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.<span class="built_in">stride</span>     <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p>这个空结构体的 size 为 0，由于它可以被定为在任意内存地址上，所以 alignment 是 1，同样 stride 也是 1，这是因为任何一个 <strong>EmptyStruct</strong> 在创建时都有一个唯一的内存地址，虽然大小为 0。</p>
<p>而 <strong>SampleStruct</strong> 的 <strong>size</strong> 是 5 <strong>stride</strong> 是 8 。这是因为它必须要对齐到 4 个字节（即4的倍数），所以 Swift 会以 8 字节的间隔（译者注：<strong>stride</strong>）去访问。</p>
<p>接下来添加:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.size      <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.alignment <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> number: <span class="type">Int64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> flag: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.size      <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.alignment <span class="comment">// returns 8 (on 64-bit)</span></span><br></pre></td></tr></table></figure>

<p>由于类是引用类型，所以 <strong>MemoryLayout</strong> 返回的是“引用”自身的大小： 8 字节。</p>
<p>如果想了解更多关于内存布局方面的知识，可以看看这段 Mike Ash 的精彩<a href="https://realm.io/news/goto-mike-ash-exploring-swift-memory-layout/">讲解</a>。</p>
<h2 id="指针（Pointers）"><a href="#指针（Pointers）" class="headerlink" title="指针（Pointers）"></a>指针（Pointers）</h2><p>一个指针包含了一个内存地址。为了与内存直接操作的“不安全”相应，指针被冠以“Unsafe”前缀，该指针类型称为 UnsafePointer. 虽然要多打点字，但是它可以提醒你正在脱离编译器的帮助，错误的处理可能引起<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">不可预料的行为</a>（并不限于崩溃）。</p>
<p>Swift的设计者，本可以只提供一种与 C 语言中 char * 等价的，可任意访问内存的 <strong>UnsafePointer</strong> 类型。但是他们没有，相反 Swift 提供了近乎一打的指针类型，以适用不同的场景和目的。选择合适的指针类型至关重要，可以帮助你避免一些不可预料的行为。</p>
<p>Swift 指针采用了非常鲜明的命名方式，以便人们通过类型即可清楚其特点。可变还是不可变的, 类型明确还是类型未知的, 连续还是不连续。下面这张表罗列了这 8 中指针。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/pointers-650x444.png" alt="unsafe swift pointers"></p>
<p>下面，我们将学习这些指针类型。</p>
<h2 id="裸指针的应用-（Using-Raw-Pointers）"><a href="#裸指针的应用-（Using-Raw-Pointers）" class="headerlink" title="裸指针的应用 （Using Raw Pointers）"></a>裸指针的应用 （Using Raw Pointers）</h2><p>在playground中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.<span class="built_in">stride</span></span><br><span class="line"><span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.alignment</span><br><span class="line"><span class="keyword">let</span> byteCount = <span class="built_in">stride</span> * <span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Raw pointers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">pointer.deallocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">pointer.storeBytes(of: <span class="number">42</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">pointer.advanced(by: <span class="built_in">stride</span>).storeBytes(of: <span class="number">6</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">pointer.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">pointer.advanced(by: <span class="built_in">stride</span>).load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> bufferPointer = <span class="type">UnsafeRawBufferPointer</span>(start: pointer, <span class="built_in">count</span>: byteCount)</span><br><span class="line"><span class="keyword">for</span> (index, byte) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;byte \(index): \(byte)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例中我们使用不安全的 Swift 指针去存取2个整数。</p>
<p>代码解释如下:</p>
<ol>
<li>这些常量保存一些常用的值:</li>
</ol>
<ul>
<li><strong>count</strong> 表明需要存储几个整形数值</li>
<li><strong>stride</strong> 表示保存Int类型的步长</li>
<li><strong>alignment</strong> 用于存储Int类型对齐所需空间大小</li>
<li><strong>byteCount</strong> 表示总占用内存空间大小</li>
</ul>
<ol start="2">
<li><p><strong>do</strong> 代码块，用于指定一个作用域，以便在后面的例子中还可以继续使用相同的变量名。</p>
</li>
<li><p><code>UnsafeMutableRawPointer.allocate</code> 用于开辟指定字节数的内存，该方法返回一个 <code>UnsafeMutableRawPointer</code> 指针. 类型名称已经清楚的表明，该指针可以用于装载或存储（可变的）类型未知的裸字节.</p>
</li>
<li><p><code>defer</code> 代码块，可以确保指针在使用后能够得到正确地释放。在这里 ARC 是无效，你需要自己手动管理内存。可以从<a href="https://www.raywenderlich.com/130197/magical-error-handling-swift">这里</a>了解到更多有关 <code>defer</code> 的知识。</p>
</li>
<li><p><code>storeBytes</code> 和 <code>load</code> 方法用于存储和装载字节。 第二个整数的内存地址，可以通过指针的 <strong>stride</strong> 计算取得。</p>
</li>
</ol>
<p>既然指针可以步进，那么就可以对指针进行类似这样的运算<code>(pointer+stride).storeBytes(of: 6, as: Int.self)</code>。</p>
<ol start="6">
<li><code>UnsafeRawBufferPointer</code>可以对存有一串连续字节的内存进行访问。也就是说可通过它遍历所有字节，可以通过下标，或者以 <strong>filter</strong>, <strong>map</strong> <strong>reduce</strong> 等更酷的方式去访问。buffer pointer需要通过裸指针来初始化。</li>
</ol>
<h2 id="类型指针的应用（Using-Typed-Pointers）"><a href="#类型指针的应用（Using-Typed-Pointers）" class="headerlink" title="类型指针的应用（Using Typed Pointers）"></a>类型指针的应用（Using Typed Pointers）</h2><p>前面的例子可以通过类型指针简化. 在playground中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Typed pointers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pointer = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="built_in">count</span>)</span><br><span class="line">pointer.initialize(to: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">pointer.deinitialize(<span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">pointer.deallocate(capacity: <span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pointer.pointee = <span class="number">42</span></span><br><span class="line">pointer.advanced(by: <span class="number">1</span>).pointee = <span class="number">6</span></span><br><span class="line">pointer.pointee</span><br><span class="line">pointer.advanced(by: <span class="number">1</span>).pointee</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bufferPointer = <span class="type">UnsafeBufferPointer</span>(start: pointer, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;value \(index): \(value)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以下不同:</p>
<ul>
<li>通过<code>UnsafeMutablePointer.allocate</code>方法开辟了一块内存. 而传入的参数是告诉swift该指针用于装载和存储 <strong>Int</strong> 类型</li>
<li>类型明确了的内存，在使用和销毁前都必需初始化，初始化和销毁可通过<code>initialize</code> 和 <code>deinitialize</code> 方法来完成。 Update: as noted by user atrick in the comments below, deinitialization is only required for non-trivial types. That said, including deinitialization is a good way to future proof your code in case you change to something non-trivial. Also, it usually doesn’t cost anything since the compiler will optimize it out.</li>
<li>类型明确的指针提供了一个 <strong>pointee</strong> 属性，通过它可以以类型安全方式装载和存储相应类型的值。</li>
<li>当移动类型指针时，可以简单地通过指定需要移动的距离来移动指针。指针会根据其所指向的类型自动计算正确的步长。指针运算又一次发挥了作用。如<code>(pointer+1).pointee = 6</code>。</li>
<li>与之前的 buffer pointer类似：只是一个遍历的是值，另一个遍历的是字节。</li>
</ul>
<h2 id="裸指针到类型指针的转换（Converting-Raw-Pointers-to-Typed-Pointers）"><a href="#裸指针到类型指针的转换（Converting-Raw-Pointers-to-Typed-Pointers）" class="headerlink" title="裸指针到类型指针的转换（Converting Raw Pointers to Typed Pointers）"></a>裸指针到类型指针的转换（Converting Raw Pointers to Typed Pointers）</h2><p>类型指针除了直接初始化得到，还可以通过裸指针取得。</p>
<p>在playground中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Converting raw pointers to typed pointers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rawPointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">rawPointer.deallocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> typedPointer = rawPointer.bindMemory(to: <span class="type">Int</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span>)</span><br><span class="line">typedPointer.initialize(to: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">typedPointer.deinitialize(<span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedPointer.pointee = <span class="number">42</span></span><br><span class="line">typedPointer.advanced(by: <span class="number">1</span>).pointee = <span class="number">6</span></span><br><span class="line">typedPointer.pointee</span><br><span class="line">typedPointer.advanced(by: <span class="number">1</span>).pointee</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bufferPointer = <span class="type">UnsafeBufferPointer</span>(start: typedPointer, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;value \(index): \(value)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例与前一个类似，不同处在于它先创建了一个裸指针。之后通过将内存 <strong>binding</strong> 给指定的 <strong>Int</strong> 类型来得到类型指针。由于绑定了内存，所以可以以类型安全的方式访问。内存绑定是在创建类型指针时在后台完成的。</p>
<p>余下的内容与前一个示例相同。一旦转换成类型指针，就可以调用 <code>pointee</code> 了。</p>
<h2 id="获取一个实例的字节（Getting-The-Bytes-of-an-Instance）"><a href="#获取一个实例的字节（Getting-The-Bytes-of-an-Instance）" class="headerlink" title="获取一个实例的字节（Getting The Bytes of an Instance）"></a>获取一个实例的字节（Getting The Bytes of an Instance）</h2><p>通常，可以通过<code>withUnsafeBytes(of:)</code>函数来获取某个类型示例所占字节的大小。</p>
<p>在playground添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Getting the bytes of an instance&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">withUnsafeBytes(of: &amp;sampleStruct) &#123; bytes <span class="keyword">in</span></span><br><span class="line"><span class="keyword">for</span> byte <span class="keyword">in</span> bytes &#123;</span><br><span class="line"><span class="built_in">print</span>(byte)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里打印了 <strong>SampleStruct</strong> 实例的裸字节。<code>withUnsafeBytes(of:) </code>让你可以在闭包中访问一个 <code>UnsafeRawBufferPointer </code>。</p>
<p><code>withUnsafeBytes</code> 在 <strong>Array</strong> 和 <strong>Data</strong> 实例上同样有效。</p>
<h2 id="求和校验（Computing-a-Checksum）"><a href="#求和校验（Computing-a-Checksum）" class="headerlink" title="求和校验（Computing a Checksum）"></a>求和校验（Computing a Checksum）</h2><p><code>withUnsafeBytes(of:)</code> 方法可以返回一个值，下面的例子以此来计算一个结构体的字节校验和。</p>
<p>在playground中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Checksum the bytes of a struct&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> checksum = withUnsafeBytes(of: &amp;sampleStruct) &#123; (bytes) -&gt; <span class="type">UInt32</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> ~bytes.<span class="built_in">reduce</span>(<span class="type">UInt32</span>(<span class="number">0</span>)) &#123; $<span class="number">0</span> + <span class="built_in">numericCast</span>($<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;checksum&quot;</span>, checksum) <span class="comment">// prints checksum 4294967269</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The reduce call adds up all of the bytes and ~ then flips the bits. Not a particularly robust error detection, but it shows the concept.</p>
<h2 id="非安全操作三原则（Three-Rules-of-Unsafe-Club）"><a href="#非安全操作三原则（Three-Rules-of-Unsafe-Club）" class="headerlink" title="非安全操作三原则（Three Rules of Unsafe Club）"></a>非安全操作三原则（Three Rules of Unsafe Club）</h2><p>编写不安全代码的时候务必小心，以避免那些不可预料的行为。这里罗列了一些糟糕的例子。</p>
<p><strong>不要通过 <code>withUnsafeBytes</code> 返回指针（Dont’t return the pointer from withUnsafeBytes）!</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule #1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1. Don&#x27;t return the pointer from withUnsafeBytes!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bytes = withUnsafeBytes(of: &amp;sampleStruct) &#123; bytes <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> bytes <span class="comment">// strange bugs here we come ☠️☠️☠️</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Horse is out of the barn!&quot;</span>, bytes)  <span class="comment">/// undefined !!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要在 <code>withUnsafeBytes(of:)</code> 作用域外调用指针。或许一时可用，但…</p>
<p><strong>一时间只绑定一种类型（Only bind to oen type at a time）!</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Rule #2</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2. Only bind to one type at a time!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span></span><br><span class="line"><span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment</span><br><span class="line"><span class="keyword">let</span> byteCount =  <span class="built_in">count</span> * <span class="built_in">stride</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> typedPointer1 = pointer.bindMemory(to: <span class="type">UInt16</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Breakin&#x27; the Law... Breakin&#x27; the Law  (Undefined behavior)</span></span><br><span class="line"><span class="keyword">let</span> typedPointer2 = pointer.bindMemory(to: <span class="type">Bool</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span> * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you must, do it this way:</span></span><br><span class="line">typedPointer1.withMemoryRebound(to: <span class="type">Bool</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span> * <span class="number">2</span>) &#123;</span><br><span class="line">(boolPointer: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Bool</span>&gt;) <span class="keyword">in</span></span><br><span class="line"><span class="built_in">print</span>(boolPointer.pointee)  <span class="comment">// See Rule #1, don&#x27;t return the pointer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/badpun-480x175.png" alt="badpun"></p>
<p>绝不要将内存同时绑定给两个不相关的类型。这被称为类型双关而 Swift 不喜欢双关。但可以通过 <code>withMemoryRebound(to:capacity:)</code> 方法暂时地重新绑定内存。同样，将一个普通类型（例如：Int）重新绑定到一个非普通类型（例如：类）也是不合法的。所以千万别这么做。</p>
<p><strong>千万别越界（Don’t walk off the end… whoops）!</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule #3... wait</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;3. Don&#x27;t walk off the end... whoops!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span></span><br><span class="line"><span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment</span><br><span class="line"><span class="keyword">let</span> byteCount =  <span class="built_in">count</span> * <span class="built_in">stride</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(bytes: byteCount, alignedTo: alignment)</span><br><span class="line"><span class="keyword">let</span> bufferPointer = <span class="type">UnsafeRawBufferPointer</span>(start: pointer, <span class="built_in">count</span>: byteCount + <span class="number">1</span>) <span class="comment">// OMG +1????</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> byte <span class="keyword">in</span> bufferPointer &#123;</span><br><span class="line"><span class="built_in">print</span>(byte)  <span class="comment">// pawing through memory like an animal</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在已出现的 off-by-one 错误中，尤以不安全代码最糟糕。所以务必小心审查，测试你的代码!</p>
<h2 id="不安全的Swift-示例-1-压缩（算法）（Unsafe-Swift-Example-1-Compression）"><a href="#不安全的Swift-示例-1-压缩（算法）（Unsafe-Swift-Example-1-Compression）" class="headerlink" title="不安全的Swift 示例 1: 压缩（算法）（Unsafe Swift Example 1: Compression）"></a>不安全的Swift 示例 1: 压缩（算法）（Unsafe Swift Example 1: Compression）</h2><p>接下来我们运用之前所讲的知识来对一个 C API 进行封装。Coca 框架中包含一个 C 模块，其实现了一些常用的压缩算法。例如 LZ4压缩算法速度最快，LZ4A算法的压缩比最高，但相对速度较慢，ZLIB算法在时间和压缩比上比较均衡，此外还有一个新的（开源）LZFSE算法，更好的平衡了空间和压缩速率。</p>
<p>创建一个新的 playground，命名为 Compression（压缩）。默认设置即可。然后用下面的代码替换原有内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Compression</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressionAlgorithm</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> lz4   <span class="comment">// speed is critical</span></span><br><span class="line"><span class="keyword">case</span> lz4a  <span class="comment">// space is critical</span></span><br><span class="line"><span class="keyword">case</span> zlib  <span class="comment">// reasonable speed and space</span></span><br><span class="line"><span class="keyword">case</span> lzfse <span class="comment">// better speed and space</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressionOperation</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> compression, decompression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return compressed or uncompressed data depending on the operation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="keyword">_</span> operation: CompressionOperation,</span></span></span><br><span class="line"><span class="function"><span class="params">on input: Data,</span></span></span><br><span class="line"><span class="function"><span class="params">using algorithm: CompressionAlgorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">workingBufferSize: Int = <span class="number">2000</span>)</span></span> -&gt; <span class="type">Data?</span>  &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来执行压缩和解压缩操作的 <strong>perform</strong> 函数还是空的，只是简单地返回 nil。稍后我们会添加一些“非安全代码”。</p>
<p>在 playground 中代码的最后添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compressed keeps the compressed data and the algorithm</span></span><br><span class="line"><span class="comment">// together as one unit, so you never forget how the data was</span></span><br><span class="line"><span class="comment">// compressed.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Compressed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data: <span class="type">Data</span></span><br><span class="line"><span class="keyword">let</span> algorithm: <span class="type">CompressionAlgorithm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(data: <span class="type">Data</span>, algorithm: <span class="type">CompressionAlgorithm</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.data = data</span><br><span class="line"><span class="keyword">self</span>.algorithm = algorithm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compress the input with the specified algorithm. Returns nil if it fails.</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">compress</span><span class="params">(input: Data,</span></span></span><br><span class="line"><span class="function"><span class="params">with algorithm: CompressionAlgorithm)</span></span> -&gt; <span class="type">Compressed?</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> data = perform(.compression, on: input, using: algorithm) <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Compressed</span>(data: data, algorithm: algorithm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncompressed data. Returns nil if the data cannot be decompressed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decompressed</span><span class="params">()</span></span> -&gt; <span class="type">Data?</span> &#123;</span><br><span class="line"><span class="keyword">return</span> perform(.decompression, on: data, using: algorithm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Compressed</strong> 结构体存有压缩后的数据和相应的压缩算法。这可以在解压时减少因算法侦测不正确而导致的错误。</p>
<p>在 Playground 的代码末尾添加如下内容:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For discoverability, add a compressed method to Data</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns compressed data or nil if compression fails.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compressed</span><span class="params">(with algorithm: CompressionAlgorithm)</span></span> -&gt; <span class="type">Compressed?</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Compressed</span>.compress(input: <span class="keyword">self</span>, with: algorithm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = <span class="type">Data</span>(bytes: <span class="type">Array</span>(repeating: <span class="type">UInt8</span>(<span class="number">123</span>), <span class="built_in">count</span>: <span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compressed = input.compressed(with: .lzfse)</span><br><span class="line">compressed?.data.<span class="built_in">count</span> <span class="comment">// in most cases much less than orginal input count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> restoredInput = compressed?.decompressed()</span><br><span class="line">input == restoredInput <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>主入口是一个 <strong>Data</strong> 类型的扩展。我们已经添加了一个名为 <code>compressed(with:)</code> 的函数，它返回一个可选类型的 <strong>Compressed</strong> 结构体。该方法只是简单地调用了 <strong>Compressed</strong> 的静态方法 <code>compress(input:with:)</code>。</p>
<p>滚动到首次进入时的代码块，<code>perform(_:on:using:workingBufferSize:)</code> 函数实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="keyword">_</span> operation: CompressionOperation,</span></span></span><br><span class="line"><span class="function"><span class="params">on input: Data,</span></span></span><br><span class="line"><span class="function"><span class="params">using algorithm: CompressionAlgorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">workingBufferSize: Int = <span class="number">2000</span>)</span></span> -&gt; <span class="type">Data?</span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the algorithm</span></span><br><span class="line"><span class="keyword">let</span> streamAlgorithm: compression_algorithm</span><br><span class="line"><span class="keyword">switch</span> algorithm &#123;</span><br><span class="line"><span class="keyword">case</span> .lz4:   streamAlgorithm = <span class="type">COMPRESSION_LZ4</span></span><br><span class="line"><span class="keyword">case</span> .lz4a:  streamAlgorithm = <span class="type">COMPRESSION_LZMA</span></span><br><span class="line"><span class="keyword">case</span> .zlib:  streamAlgorithm = <span class="type">COMPRESSION_ZLIB</span></span><br><span class="line"><span class="keyword">case</span> .lzfse: streamAlgorithm = <span class="type">COMPRESSION_LZFSE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the stream operation and flags</span></span><br><span class="line"><span class="keyword">let</span> streamOperation: compression_stream_operation</span><br><span class="line"><span class="keyword">let</span> flags: <span class="type">Int32</span></span><br><span class="line"><span class="keyword">switch</span> operation &#123;</span><br><span class="line"><span class="keyword">case</span> .compression:</span><br><span class="line">streamOperation = <span class="type">COMPRESSION_STREAM_ENCODE</span></span><br><span class="line">flags = <span class="type">Int32</span>(<span class="type">COMPRESSION_STREAM_FINALIZE</span>.rawValue)</span><br><span class="line"><span class="keyword">case</span> .decompression:</span><br><span class="line">streamOperation = <span class="type">COMPRESSION_STREAM_DECODE</span></span><br><span class="line">flags = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">/// To be continued</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Swift 类型转换为 C 类型需要用到 compression 库中提供的压缩算法和操作。</p>
<p>接下来用如下代码替换<code>return nil</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1: create a stream</span></span><br><span class="line"><span class="keyword">var</span> streamPointer = <span class="type">UnsafeMutablePointer</span>&lt;compression_stream&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">streamPointer.deallocate(capacity: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: initialize the stream</span></span><br><span class="line"><span class="keyword">var</span> stream = streamPointer.pointee</span><br><span class="line"><span class="keyword">var</span> status = compression_stream_init(&amp;stream, streamOperation, streamAlgorithm)</span><br><span class="line"><span class="keyword">guard</span> status != <span class="type">COMPRESSION_STATUS_ERROR</span> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">compression_stream_destroy(&amp;stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3: set up a destination buffer</span></span><br><span class="line"><span class="keyword">let</span> dstSize = workingBufferSize</span><br><span class="line"><span class="keyword">let</span> dstPointer = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">UInt8</span>&gt;.allocate(capacity: dstSize)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">dstPointer.deallocate(capacity: dstSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">/// To be continued</span></span><br></pre></td></tr></table></figure>

<p>代码释义如下:</p>
<ol>
<li>创建一个compression_stream并且通过defer代码块儿，确保其能够及时释放。</li>
<li>接下来，通过访问 pointee 属性得到 steam，并且将其传递给compression_stream_init方法.编译器会做一些特殊的处理（必要的初始化）。 通过输入输出标识符 &amp; 将接收的 compression_stream自动转换为UnsafeMutablePointer<compression_stream>。 (当然直接传递streamPointer也可以，这样就不需要转换了)</li>
<li>左后，创建一个目标缓存，作为工作输出的缓冲区。</li>
</ol>
<p>用如下代码替换掉<code>return nil</code>，以完成 <code>perform</code> 函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// process the input</span></span><br><span class="line"><span class="keyword">return</span> input.withUnsafeBytes &#123; (srcPointer: <span class="type">UnsafePointer</span>&lt;<span class="type">UInt8</span>&gt;) <span class="keyword">in</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> output = <span class="type">Data</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">stream.src_ptr = srcPointer</span><br><span class="line">stream.src_size = input.<span class="built_in">count</span></span><br><span class="line">stream.dst_ptr = dstPointer</span><br><span class="line">stream.dst_size = dstSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">while</span> status == <span class="type">COMPRESSION_STATUS_OK</span> &#123;</span><br><span class="line"><span class="comment">// process the stream</span></span><br><span class="line">status = compression_stream_process(&amp;stream, flags)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect bytes from the stream and reset</span></span><br><span class="line"><span class="keyword">switch</span> status &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_OK</span>:</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">output.append(dstPointer, <span class="built_in">count</span>: dstSize)</span><br><span class="line">stream.dst_ptr = dstPointer</span><br><span class="line">stream.dst_size = dstSize</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_ERROR</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_END</span>:</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">output.append(dstPointer, <span class="built_in">count</span>: stream.dst_ptr - dstPointer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">fatalError</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才是真正执行压缩任务的代码. 下面是代码释义:</p>
<ol>
<li>创建一个Data对象，用于存储输出数据，具体是压缩后的数据还是解压后的数据取决与当前操作。</li>
<li>设置输入输出指针，及其大小。</li>
<li>持续掉用compression_stream_process 直至完成 即状态COMPRESSION_STATUS_OK.</li>
<li>目标 buff 被拷贝到 output 其从中会被返回</li>
<li>当传入最后一个包时, marked with COMPRESSION_STATUS_END only part of the destination buffer potentially needs to be copied.</li>
</ol>
<p>在这个例子中，我们可以看到含有10000个元素的数组被压缩到153字节。</p>
<h2 id="不安全的Swift-示例2-随机数生成器（Unsafe-Swift-Example-2-Random-Generator）"><a href="#不安全的Swift-示例2-随机数生成器（Unsafe-Swift-Example-2-Random-Generator）" class="headerlink" title="不安全的Swift 示例2:随机数生成器（Unsafe Swift Example 2: Random Generator）"></a>不安全的Swift 示例2:随机数生成器（Unsafe Swift Example 2: Random Generator）</h2><p>无论是游戏还是机器学习类的应用，随机数至关重要。macOS 提供了 <code>arc4random</code> 函数用于生成随机数。糟糕的是 Linux 上不可用。此外 <code>arc4random</code> 仅提供 UInt32类型的随机数。而 <code>/dev/urandom</code> 提供了一个无限的随机数源。</p>
<p>这一小节，我们会运用新学到的知识读取这个文件，并创建类型安全的随机数。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/hexdump-480x202.png" alt="hexdump"></p>
<p>先创建一个新的playground, 命名为“RandomNumbers”。确保平台选择macOS.<br>创建完毕后，用一下代码替换原有默认内容:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RandomSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> file = fopen(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="string">&quot;r&quot;</span>)!</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;random&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; [<span class="type">Int8</span>] &#123;</span><br><span class="line"><span class="keyword">let</span> capacity = <span class="built_in">count</span> + <span class="number">1</span> <span class="comment">// fgets adds null termination</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;.allocate(capacity: capacity)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">data.deallocate(capacity: capacity)</span><br><span class="line">&#125;</span><br><span class="line">queue.sync &#123;</span><br><span class="line">fgets(data, <span class="type">Int32</span>(capacity), file)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Array</span>(<span class="type">UnsafeMutableBufferPointer</span>(start: data, <span class="built_in">count</span>: <span class="built_in">count</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 file 声明为静态变量，以保证系统中仅存在一个实例。当线程退出时系统会关闭打开的文件。由于存在多个进程获取随机数的可能，所以通过一个串行的 GCD 队列来保证它的存取顺序。所有实现都在 get 方法中。首先创建capacity，因为 fgets 总是以 0 结束，所以这里要额外的加 1。从file中得到数据，确保操作是运行在 GCD 队列上，最后，将数据拷贝到一个由 <code>UnsafeMutableBufferPointer</code> 指针指向起始位的标准的数组中。现在我们得到一个含有 Int8 数值的数组。</p>
<p>接下来在 playground 末尾添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> randomized: <span class="type">Self</span> &#123;</span><br><span class="line"><span class="keyword">let</span> numbers = <span class="type">RandomSource</span>.<span class="keyword">get</span>(<span class="built_in">count</span>: <span class="type">MemoryLayout</span>&lt;<span class="type">Self</span>&gt;.size)</span><br><span class="line"><span class="keyword">return</span> numbers.withUnsafeBufferPointer &#123; bufferPointer <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> bufferPointer.baseAddress!.withMemoryRebound(to: <span class="type">Self</span>.<span class="keyword">self</span>, capacity: <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> $<span class="number">0</span>.pointee</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Int8</span>.randomized</span><br><span class="line"><span class="type">UInt8</span>.randomized</span><br><span class="line"><span class="type">Int16</span>.randomized</span><br><span class="line"><span class="type">UInt16</span>.randomized</span><br><span class="line"><span class="type">Int16</span>.randomized</span><br><span class="line"><span class="type">UInt32</span>.randomized</span><br><span class="line"><span class="type">Int64</span>.randomized</span><br><span class="line"><span class="type">UInt64</span>.randomized</span><br></pre></td></tr></table></figure>

<p>这里在通过扩展 Integer 协议，为其所有子类型添加了一个静态的 randomized 属性(可查阅<a href="https://www.raywenderlich.com/148448/introducing-protocol-oriented-programming">protocol oriented programming</a>了解更多)。</p>
<h2 id="接下来（-Where-to-Go-From-Here-）"><a href="#接下来（-Where-to-Go-From-Here-）" class="headerlink" title="接下来（ Where to Go From Here?）"></a>接下来（ Where to Go From Here?）</h2><p>这是完整的<a href="https://koenig-media.raywenderlich.com/uploads/2017/01/Unsafe.zip">playgrounds</a>。下面还提供了一些额外的一些资源，以便加深了解:</p>
<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md">Swift Evolution 0107: UnsafeRawPointer API</a> 更详细的介绍了Swift内存模型，可以帮助你更好的读懂API文档.</li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md">Swift Evolution 0138: UnsafeRawBufferPointer API</a>更多的讲述了如何与untyped memory的交互，并提供了一些开源工程连接，以便更好的运用。</li>
<li>如果你正在向Swift 3迁移非安全代码，可以看看这篇<a href="https://swift.org/migration-guide/se-0107-migrate.html">The Migration Guide</a>。即使你还没开始前一，文中也提供了大量有趣的例子，值得一看。</li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html">Interacting with C APIs</a> 可以帮助更深入的了解与C API的交互。<br>Mike Ash 在<a href="https://realm.io/news/goto-mike-ash-exploring-swift-memory-layout/">Exploring Swift Memory Layout</a>分享了一些非常棒的经验。<br>希望大家能喜欢这篇文章. 如果你有什么问题，或者有什么经验要分享，欢迎大家将其发布到论坛上，我会时刻关注的!</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文翻译自 <a href="https://www.raywenderlich.com/148569/unsafe-swift">Unsafe Swift: Using Pointers And Interacting With C</a>， 由 <a href="https://www.raywenderlich.com/u/rayfix">Ray Fix</a> 发表于<a href="https://www.raywenderlich.com/">Raywenderlich</a>。</p>
<p>受限于译者英语水平及翻译经验，译文难免有词不达意，甚至错误的地方，还望不吝赐教，予以指正</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Pointers</tag>
        <tag>C 语言</tag>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>Other linker flags</title>
    <url>/2021/06/23/Other-linker-flags/</url>
    <content><![CDATA[<p>CocoPod 是一个了不起的工具，很多团队也都通过它实现了项目的组件化。但在使用过程中不知道你是否也遇到过链接错误的问题。通常这都是因为 CocoaPod 在生成项目时自动在 Other Linker Flags 中添加  <code>-ObjC</code> 引起，那么  <code>-ObjC</code> 这个参数具体是做什么的呢，还有哪些参数呢？</p>
<a id="more"></a>

<h2 id="ObjC-的意义"><a href="#ObjC-的意义" class="headerlink" title="-ObjC 的意义"></a>-ObjC 的意义</h2><p><code>-ObjC</code> 参数的意义是告诉链接器，将静态库中所有实现了 Objective-C 或 Category 的成员（目标文件），链接到最终的可执行文件中。那这又是为什么呢？为什么需要给这么一个选项呢？在解决这个问题之前，先来回顾一下有关链接的知识。</p>
<h2 id="静态语言的链接"><a href="#静态语言的链接" class="headerlink" title="静态语言的链接"></a>静态语言的链接</h2><p>像 C 这样的典型静态语言，所有“源文件”都会被编译为包含着可执行函数和静态数据的“目标文件”，之后在由“链接器”负责，将这些目标文件整合为一个可执行文件。</p>
<p>通常来说我们的工程中源文件不会只有一个，而且各个源文件之间还可能存在引用关系。例如： <code>A.c</code> 中用到了 <code>B.c</code> 中的一个名为 <code>doSomething()</code> 的函数。当编译器遇到这个函数时，它会将一个 “undefined symbol” 写入到生成的目标文件中，表示这个位置“缺少东西”。之后，当链接器遇到这个标记时，它就会知道这里有空缺需要填补。随着连接器的深入，它在<code>B.o</code> 中找到了<code>doSomething()</code> 的实现，这时它就会用这个实现的地址将 <code>A.o</code> 中的 “undefined symbol” 替换掉，从而将 <code>A.o</code> <code>B.o</code> 链接在一起。</p>
<p>UNIX 静态库是一个目标文件的集合，只有那些可以填补“undefined symbol”（空缺）的目标文件才会被整合到最终的可执行文件中，这样做也是为了减少最终可执行文件的体积。</p>
<h2 id="动态语言的链接"><a href="#动态语言的链接" class="headerlink" title="动态语言的链接"></a>动态语言的链接</h2><p>在当下面试都要手撕“Runtime”的时代，大家对于 Objective-C 是一门动态语言，一定不会感到陌生。那么它跟 静态语言有什么不同呢，其中一个最大的区别就是：直到方法被调用，否则在此之前无从得知这个方法的实现具体在什么位置。因此，Objective-C 的编译器也就没必要为方法设置“链接标识”了，但是类的链接标识依然存在。</p>
<p>举例来说，假设在源文件 <code>A.m</code> 有这样一条语句 <code>[b doSomething]</code> ，那么经过编译后，<code>A.o</code> 中会有一个用来指示“ <code>b</code> 空缺”的“undefined symbol”，但方法 <code>doSomething</code> 的“undefined symbol”却不会有。</p>
<h2 id="Other-linker-flags"><a href="#Other-linker-flags" class="headerlink" title="Other linker flags"></a>Other linker flags</h2><p>Objective-C 这种动态语言特性为我们带来了很多便利，但也存在一些弊端。例如，当我们的静态库中包含 category 时。根据前面介绍的动态语言链接特性，不难看出，category 的目标文件将不会被链接到可执行文件中，因为其它目标文件中都没有需要链接到位于 category 中的方法的“undefined symbol”。这样生成的可执行文件，在运行时就可能会出现 “selector not recognized” 的异常。</p>
<p>综上，我们也就不难理解 <code>-ObjC</code> 的意义了。那除此之外还有没有其它标识呢？</p>
<h2 id="Linker-flags-list"><a href="#Linker-flags-list" class="headerlink" title="Linker flags list"></a>Linker flags list</h2><p>答案是肯定的。因为我们只能让链接器覆盖大部分情况，一些边边角角的问题，还是需要人为干预。怎么干预呢，正是通过下面这些标识：</p>
<ul>
<li>-all_load ： 加载静态库中所有成员（简单暴力，但通常代价也不小）</li>
<li>-force_load &lt;路径参数&gt; : 加载指定路径静态库中的所有成员（这样目标就明确多了）</li>
<li>-arch &lt;架构名&gt;：加载指定架构的目标文件，例如：armv7，arm64，i386。</li>
<li>-framework &lt;name[, suffix]&gt;：为链接器指定 “name.framework/name”的framework检索地址。如果指定了后缀，那么将优先检索。例如：“name.framework/name_suffix”.</li>
</ul>
<p>这里仅列举了部分常见的，欲了解更多，请在终端中输入 <code>man ld</code> 查阅 manpage。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个问题其实自己遇到很多次了，但总是看完之后，过后一段时间不用就又忘了。此外，国内中文环境越来越差，稍微有点价值的内容都被各个平台封闭在自己圈中，要不就是SEO污染，想通过搜索引擎检索到有意义的内容越来越难了。这也算是略近绵薄之力吧。</p>
<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><a href="https://developer.apple.com/library/archive/qa/qa1490/_index.html#//apple_ref/doc/uid/DTS10004097">Building Objective-C static libraries with categories</a><br><a href="https://stackoverflow.com/questions/14497872/other-linker-flags-list">Other linker flags list</a></p>
]]></content>
      <tags>
        <tag>Objective-C</tag>
        <tag>连接器</tag>
        <tag>编译</tag>
      </tags>
  </entry>
</search>
